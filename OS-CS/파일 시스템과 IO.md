#### 파일 시스템 (File System)의 목표
파일 시스템은 다스크라는 단순한 물리적 저장소 위에 **"파일(File)"** 과 **"디렉터리(Directory)"** 라는 사용자 친화적인 논리적 추상화를 제공함.
- 목표 1: 추상화: 디스크의 물리적 섹터 주소를 숨기고, 이름을 가진 논리적 객체(파일)로 제공함.
- 목표 2: 영구성과 보안: 시스템이 꺼져도 데이터가 유지되며, 접근 권한을 통해 데이터를 보호함.

#### 파일 시스템의 핵심 구조
파일 시스템은 디스크를 단순히 데이터 저장 공간으로 사용하는 것이 아니라, **메타데이터(Metadata)** 와 데이터를 체계적으로 관리함.

##### 데이터 블록 (Data Blocks)
- 실제 파일 데이터가 저장된느 디스크의 물리적 영역임. (일반적으로 4KB 크기의 블록 단위로 관리)
- 연결고리: Allocator가 메모리(RAM)를 블록 단위로 쪼개듯, 파일 시스템은 디스크들을 블록 단위로 쪼개어 관리함.

##### i-node (아이노드)
- 정의: 파일 그 자체에 대한 모든 메타데이터를 담고 있는 자료구조.
- 포함 정보: 파일의 소유자, 접근 권한, 파일 크기, 생성/수정 시간, 그리고 가장 중요한 데이터 블록의 주소 목록.
- 통찰: 디렉터리는 파일 이름과 그 파일의 i-node 번호만을 저장함. OS가 파일을 찾으려면 먼저 디렉터리에서 i-node 번호를 얻은 후, i-node를 통해 실제 데이터 블록의 위치(주소)를 찾아감.

#### 디스크 할당 방법 (Disk Allocation Methods)
파일의 데이터 블록을 디스크의 빈 공간에 어떻게 배치할 것인가에 대한 전략임.

| 방법                 | 원리                                                    | 장점                    | 단점 (연결고리)                                                                            |
| ------------------ | ----------------------------------------------------- | --------------------- | ------------------------------------------------------------------------------------ |
| 연속 할당 (Contiguous) | 파일을 디스크의 연속된 블록에 저장.                                  | 접근 속도가 매우 빠름 (순차 I/O) | **외부 파편화(External Fragmentation)** 가 발생하여, 큰 파일을 저장할 공간이 부족해질 수 있음. (메모리 할당의 단점과 동일) |
| 연결 할당 (Linked)     | 각 데이터 블록이 다음 데이터 블록의 주소를 가리킴.                         | 단편화 발생 없음.            | 임의 접근(Random Access) 속도가 매우 느림. (연결 리스트의 단점과 동일)                                     |
| 색인 할당 (Indexed)    | **색인 블록(Index Block)** 을 두어, 모든 데이터 블록의 주소를 이 색인에 저장. | 임의 접근 속도가 빠름.         | 파일이 커지면 색인 블록이 너무 커지거나, 다단계 색인이 필요해짐. (B+ Tree 인덱스 논리와 동일)                           |

#### 파일 I/O 시스템의 동작 (커널 영역)
파일 I/O 요청은 프로세스 영역(User Space)에서 발생하지만, 실제 동작은 OS의 커널 영역(Kernel Space)에서 이루어짐.
1. 사용자 요청: `read()`나 `write()`와 같은 시스템 호출(System Call) 발생.
2. 커널 진입: CPU가 모드를 User -> Kernel로 전환하고, OS가 해당 요청을 처리.
3. 버퍼 캐시(Buffer Cache) 확인: 커널은 디스크 접근 속도를 높이기 위해 RAM의 일부를 디스크 캐시로 사용함, 요청한 데이터가 캐시에 있다면 디스크 접근 없이 바로 반환 (캐시 히트).
4. 디스크 접근: 캐시에 없다면, i-node를 통해 실제 디스크의 물리적 주소를 찾은 후, 디스크 스케줄링을 거쳐 데이터를 읽어 옴. (가장 느린 단계)

#### 디스크 스케줄링: 물리적 효율성
목표: 디스크 헤드(Head)의 불필요한 움직임(Seek Time)을 최소화하여 I/O 처리율 극대화. (디스크는 순차 접근이 빠르고 임의 접근이 느린 장치)
- SSTF (Shortest Seek Time First): 현재 헤드 위치에서 가장 가까운 요청부터 처리. (Greedy 방식)
- SCAN/C-SCAN (엘리베이터 알고리즘): 헤드가 한 방향으로 이동하며 만나는 모든 요청을 처리한 후, 끝에 도달하면 방향을 바꾸거나(SCAN) 처음으로 돌아가서(C-SCAN) 다시 처리. (응답 시간 편차 최소화)

# 결론:
파일 시스템은 자료구조(트리, 인덱스)와 알고리즘 (Greedy, 스케줄링)을 디스크라는 물리적 제약 환경에 적용한 복합체임. 특히 i-node의 다단계 색인 구조는 B+ Tree와 직접적인 연결고리가 됨.
