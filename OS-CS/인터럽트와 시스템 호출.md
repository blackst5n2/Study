# 운영체제의 심장 (인터럽트와 시스템 호출)
프로그램은 기본적으로 **'감옥(User Mode)'** 에 갇혀 있음. 메모리를 직접 할당하거나(`mmap`), 디스크를 읽거나(`read`), 네트워크를 쏘는 행위는 금지되어 있음. 오직 **운영체제(Kernel)** 만이 이 권한을 가짐.

이 경게를 넘나드는 메커니즘을 이해해야함.

#### 1. 보호 링 (Protection Rings): 넘을 수 없는 벽
CPU는 하드웨어적으로 권한 레벨을 구분함. (x86 아키텍처 기준)
- Ring 0 (Kernel Mode): 모든 하드웨어 접근이 가능한 신의 영역 (OS 커널).
- Ring 3 (User Mode): 하드웨어 직접 접근이 불가능하며, 제한된 메모리만 볼 수 있음.
`Allocator`가 힙 메모리를 다 쓸 때 OS에게 "메모리 좀 더 줘(`sbrk`, or `mmap`)"라고 요청하는 순간, 프로그램은 Ring 3에서 Ring 0로 점프해야 함. 이 점프는 단순한 함수 호출(`CALL`)로는 불가능함.

#### 2. 시스템 호출 (System Call): 유일한 통로
시스템 호출은 유저 프로그램이 커널에게 기능을 요청하는 표준화된 인터페이스임. `printf("Hello");`를 실행하면 내부적으로 `write()` 시스템 호출이 발생하며 다음 과정을 거침.

##### 시스템 호출의 처리 메커니즘 (The Mechanism)
1. 준비 (Setup): 유저 프로그램은 시스템 호출 번호(예: `write`는 4번)와 인자들을 CPU 레지스터(EAX 등)에 집어 넣음.
2. 트랩 발동 (Trap/Interrupt): 유저 프로그램이 `syscall` (또는 `int 0x80`)이라는 특수 명령어를 실행함.
	- 이것이 소프트웨어 인터럽트임. CPU에게 "하던 일을 멈추고 나 좀 봐줘!"라고 신호를 보내는 것.
3. 모드 전환 (Mode Switch): CPU는 즉시 권한을 Ring 3 -> Ring 0로 격상시키고, 미리 등록된 커널의 **시스템 호출 핸들러(Handler)** 로 점프함.
4. 검증 및 실행: 커널은 요청이 정당한지 검사한 후 하드웨어를 제어하여 작업을 수행함.
5. 복귀 (Return): 작업이 끝나면 `sysret` 명령어로 다시 Ring 0 -> Ring 3로 권한을 낮추고 유저 프로그램으로 돌아감.
연결고리: 해커들이 사용하는 **쉘코드(Shellcode)** 는 바로 이 메커니즘을 악용함. 레지스터에 `execve` 시스템 콜 번호를 넣고 `syscall` 명령을 직접 때려서, 커널에게 강제로 쉘을 띄우게 만드는 것.

#### 3. 인터럽트 (Interrupt): 하드웨어의 외침
시스템 호출이 **소프트웨어(코드)** 가 커널을 부르는 것이라면, 인터럽트는 하드웨어가 커널을 부르는 것.
- 비동기성 (Asynchronous): 키보드를 누르거나, 패킷이 도착하거나, 당신이 공부한 ADC 변환이 완료되는 것은 언제 일어날지 모름.
- 하드웨어의 동작:
	1. 하드웨어(예: 타이머, ADC)가 CPU의 인터럽트 라인에 전기 신호를 보냄.
	2. CPU는 현재 실행 중인 명령어 주소(PC)와 상태를 스택에 대피시킴.
	3. **인터럽트 벡터 테이블(IVT)** 을 참조하여 해당 장치에 맞는 ISR(Interrupt Service Routine) 함수로 강제 점프함.
통찰: 운영체제의 **스케줄러(Scheduler)** 는 바로 이 타이머 인터럽트 덕분에 존재함. 1ms마다 하드웨어 타이머가 인터럽트를 걸어주기 때문에, OS는 실행 중인 프로세스를 멈추고 "너 너무 오래 썼어, 다음 차례!"라고 강제로 교체(Context Switch)할 수 있는 것.

#### 4. 문맥 교환 (Context Switching): 환상의 비용
이 모든 과정(시스템 콜, 인터럽트)이 발생할 때 문맥 교환이 일어남. 이것은 공짜가 아님.
- 비용: CPU 레지스터를 저장하고 복원하는 것뿐만 아니라, **MMU의 TLB가 초기화(Flush)** 되거나 캐시가 오염된느 비용이 발생함.
- 연결고리: `Memory Allocator`를 만들 때, 매번 `mmap`(시스템 콜)을 호출하지 않고 **큰 메모리 블록(Pool)**을 한 번 할당받아 내부에서 쪼개 쓰는 이유가 바로 이 시스템 콜과 문맥 교환의 비용을 줄이기 위함임.

# 요약
1. Ring 0 vs Ring 3: 하드웨어를 보호하기 위한 CPU 차원의 벽.
2. 시스템 콜: 벽을 넘기 위한 유일한 문이며, `syscall` 명령어를 통해 소프트웨어 인터럽트를 발생시킴.
3. 인터럽트: 하드웨어가 CPU를 멈추는 방식이며, OS 스케줄링의 근원임.
4. 비용: 이 모든 과정은 문맥 교환 비용을 수반하므로, 시스템 프로구래머는 이를 최소화 해야함.
