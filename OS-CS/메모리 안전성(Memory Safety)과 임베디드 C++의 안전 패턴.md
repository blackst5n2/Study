**실행 중 절대로 멈추거나 메모리 누수가 발생하지 않는** 코드를 작성하는 방법.

# 임베디드 C++의 금지된 영역: 동적 할당 (`new`/`malloc`)
PC 환경에서는 `new`를 자유롭게 쓰지만, 임베디드 시스템에서 **힙(Heap)** 메모리 사용은 **가장 위험한 행위 중** 하나.

#### 힙 조각화 (Heap Fragmentation)
- 문제: 프로그램이 실행되면서 다양한 크기의 메모리(10바이트, 500바이트, 20바이트...)를 요청(`new`) 하고 해제(`delete`)함.
- 현상: 힙 영역 전체에 **작은 빈 공간(구멍)** 들이 흩어짐.
- 결과: 전체 빈 공간을 합하면 1MB가 넘는데도, 연속된 공간 50KB 공간이 없어 **새로운 `new` 요청이 실패** 함. 시스템은 멈춤.
- 해결: **동적 할당을 최소화** 하거나, **메모리 풀(Memory Pool)** 기법을 사용하여 메모리를 미리 일정한 크기의 블록으로 쪼개서 관리.

#### 메모리 누수 (Memory Leak)
`new`를 썼는데 `delete`를 빼먹으면, 그 메모리는 영원히 회수되지 않고 결국 힙 고갈로 시스템이 다운됨.

# 스택 오버플로우 관리: 제한된 자원
스택의 위험성을 막는 실질적인 코딩 기법.

#### 지역 변수 크기 제한
함수 내에서 크기가 큰 배열이나 버퍼는 절대로 선언해서는 안 됨.
```c
// [위험!] 스택을 순식간에 고갈시킬 수 있음
void process_data(void) {
	uint8_t large_buffer[4096]; // 4KB, 스택 용량의 큰 부분을 차지
	// ...
}
```

- 대안: 이런 대용량 버퍼는 **전역(Global) 변수** 나 **정적(Static) 변수** 로 선언하여 **BSS/Data 영역 (RAM)** 으로 빼야 함.

#### 런타임 감시
- Stack Canary: 컴파일러 옵션을 켜서 스택의 맨 끝에 특수 값(Canary)을 심어둠. 함수 종료 시 이 값이 깨졌는지 확인하여 Stack Overflow를 감지하고 경고를 줌.
- Map 파일 검토: 링커 스크립트(.map) 파일을 보고 스택의 최대 크기를 설정하고, 디버깅 시 최대 택 사용량이 그 경계를 넘지 않는지 주기적으로 확인해야 함.

# C++ 기능 필터링: 코드 크기 & 예측 불가능성
C++에는 임베디드 시스템에 엄청난 오버헤드를 유뱔하는 기능들이 있음.

| 기능                    | 문제점                                                  | 임베디드 권장 사항                                  |
| --------------------- | ---------------------------------------------------- | ------------------------------------------- |
| Exceptions (예외)       | 코드 크기를 기하급수적으로 늘리고 (Blob), 예외 발생 시 스택을 풀면서 CPU가 멈칫함. | 컴파일러 옵션으로 비활성화 (`-fno-exceptions`)          |
| RTTI (`dynamic_cast`) | 객체 타입을 런타임에 확인하는 기능. 코드 크기를 늘리고 속도가 느림.              | 컴파일러 옵션으로 비활성화 (`-fno-rtti`)                |
| `std::shared_ptr`     | 참조 카운트를 관리하기 위해 원자적(Atomic) 연산을 사용해야 해서 오버헤드가 큼.     | 거의 사용 금지. 반드시 필요하다면 RTOS의 Mutex 등으로 보호해야 함. |

# C++의 축복: RAII와 스마트 포인터
임베디드 C++의 핵심 가치는 **"자원 해제를 잊어버릴 염려가 없는 코드"**.

#### RAII (Resource Acquisition Is Initialization)
- 원리: **자원(Resource)** 을 클래스의 **생성자(Constructor)** 에서 획득하고, 해제는 **소멸자 (Destructor)** 에서 담당하게 하는 설계 패턴.
- 효과: 함수를 `return` 하든, 중간에 `break`를 하든, 스코프를 벗어나는 순간 소멸자가 자동으로 호출 되어 자원을 해제함. 메모리 누수 방지.

```cpp
class GpioLocker {
public:
	GpioLocker(int pin) { /* 핀 락(Lock) 획득 */}
	~GpioLocker() { /* 핀 락 해제 */ } // 여기서 무조건 해제됨!
};

void critical_section() {
	GpioLocker lock(5); // 객체 생성 시 락 획득
	// ... 작업 중 실수로 return 하더라도	
} // 여기서 lock의 소멸자가 호출되어 락 자동 해제
```

#### `std::unique_ptr`의 제한적 사용
`std::unique_ptr`은 포인터를 담고 있다가, 스코프를 벗어나면 자동으로 `delete`를 호출함.
- 임베디드 권장: **`std::unique_ptr`** 은 오버헤드가 거의 없으므로, 아주 제한적으로 사용해야 하는 **동적 할당** 을 안전하게 관리하는 데 사용할 수 있음. (`new` 대신 `std::make_unique` 사용)

# 제로 오버헤드 (Zero Overhead) C++
C++을 쓰면서도 C보다 빠르게 만드는 기법.

#### `constexpr` (Compile-time 계산)
- 역할: 변수나 함수를 컴파일 시점에 미리 계산해서 코드에 값을 박아 넣음.
- 효과: 런타임에 CPU가 계산할 필요가 없어지므로 성능 향상. (예: 룩업 테이블, 비트 마스크 값 계산)

#### 템플릿 (Template)
- 역할: 코드를 찍어내는 기계. 함수 호출 오버헤드가 없는 **타입-안전한 매크로** 역할을 수행함. (예: Array 클래스, Max 함수)

# 결론

| 단계     | 지식                                | 목표                    |
| ------ | --------------------------------- | --------------------- |
| 1. 시스템 | CPU, 메모리 구조, RTOS                 | 시스템의 물리적 한계 이해        |
| 2. 언어  | C/C++ 포인터, 레지스터 접근, 링커            | 코드가 하드웨어에서 돌아가는 원리 이해 |
| 3. 실전  | GPIO, 타이머, UART/I2C/SPI, DMA, ADC | 하드웨어 제어와 외부 소통 능력 확보  |
| 4. 안전  | 메모리 안전성, RAII, C++ 필터링            | 시스템이 멈추지 않는 견고한 코드 설계 |
