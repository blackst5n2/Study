`kqueue`는 수만 개의 파일 디스크립터(소켓, 파일 등)를 감시할 때, **"어떤 녀석에게 데이터가 왔니?"** 라는 질문을 $O(1)$의 속도로 해결하기 위해 설계되었음.

#### 핵심 구조: `kevent`
`kqueue` 시스템의 핵심은 `kevent`라는 구조체임. 이 구조체는 **"무엇을 감시할 것인가"** 와 **'무슨 일이 있나는가"** 를 동시에 담음.
- Ident: 감시 대상 (예: 소켓 번호, 타이머 ID).
- Filter: 감시할 사건의 종류 (예: `EVFILT_READ`, `EVFILT_WRITE`, `EVFILT_VNODE`).
- Flags: 이벤트 처리 방식 (예: `EV_ADD` 추가, `EV_DELETE` 삭제).

#### 왜 `select`나 `poll`보다 압도적인가?
과거의 방식(`select`)은 매번 "이 1,000개 중에서 바뀐 거 있어?"라고 유저 모드에서 커널 모드로 전체 리스트를 복사해서 물어봐야 했음. ($O(N)$)

반면 `kqueue`는:
1. 커널 내부에 상태 저장: 커널이 이미 "내가 감시해야 할 목록"을 들고 있음. 유저는 바뀐 부분만 알려주면 됨.
2. 발생한 이벤트만 반환: 데이터가 도착하면 커널이 **"준비된 녀석들 리스트"** 를 따로 만들어 둠. 유저는 그 리스트만 쏙 가져오면 되므로 루프를 돌  필요가 없음. ($O(k)$, 여기서 $k$는 실제 사요건이 발생한 개수)

# kqueue만의 특별한 강점 (epoll과의 차이)
많은 사람이 리눅스의 `epoll`과 비슷하다고 생각하지만, `kqueue`는 훨씬 더 범용적이고 우아하게 설계됐음.

##### 모든 것을 감시한다 (Generic Filter)
`epoll`은 주로 네트워크 소켓(파일 디스크립터)에 집중하지만, `kqueue`는 시스템의 거의 모든 변화를 필터 하나로 감시할 수 있음.
- 파일 시스템 변화: 특정 파일이 수정되거나 이름이 바뀔 때(`EVFILT_VNODE`).
- 프로세스 상태: 특정 자식 프로세스가 종료되거나 `fork()`될 때(`EVFILT_PROC`).
- 타이머: 정밀한 타이머 이벤트(`EVFILT_TIMER`).
- 시그널: 시스템 시그널(`EVFILT_SIGNAL`).

##### 사용자 정의 이벤트 (User Events)
`EVFILT_USER`를 통해 개발자가 직접 이벤트를 정의하고 트리거할 수 있음. 이는 멀티스레드 환경에서 스레드 간 통신(IPC)용으로 매우 유용함.

# 지식과 연결하기
고부한 내용들과 `kqueue`를 엮어보면 이렇슴.
1. 비동기 I/O와 이벤트 루프: `kqueue`는 현대적인 Event Loop 아키텍처의 엔진임. Nginx나 Redis가 macOS에서 돌아갈 때 바로 이 `kqueue`를 사용하여 수만 개의 연결을 처리함.
2. 시스템 콜 비용 절약: `kevent()` 시스템 콜 하나로 "새로운 감시 대상 등록"과 "발생한 이벤트 수거"를 동시에 할 수 있음. 이는 System Call 오버헤드를 줄이려고 노력하는 것과 같은 맥락의 설계임.
3. 파일 I/O와의 연결: 파일이 변경되는지 감시할 때 루프를 돌며 `stat()`을 호출하는 대신, `kqueue`에 던져놓고 커널이 알려줄 때까지 기다리면 CPU 자원을 거의 쓰지 않음.

# 간단한 비유
- select: 선생님 교실에서 "숙제 다 한 사람 손들어!"라고 매번 소리치고, 30명의 손을 일일이 확인 하는 것.
- kqueue: 숙제를 다 한 핵싱이 교탁 우의 **'제출함'** 에 숙제를 내고 가면, 선생님은 제출함에 쌓인 숙제만 확인하면 되는 것.
