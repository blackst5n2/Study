출력은 "내가 월할 때 명령하는 것"
입력은 **"외부 세상이 언제 나한테 신호를 보낼지 모르는 상태"**

**폴링(Polling)** 과 **인터럽트(Interrupt)** 의 차이를 하드웨어 레벨에서 분석

# 물리적 신호의 입력: 전압이 숫자가 되기까지
먼저, 버튼을 눌렀을 때 전기 신호가 어떻게 변수에 담기는지 확인.
1. 회로: 버튼을 누르면 3.3V 전압이 핀으로 들어옴 (High). 떼면 0V가 됨 (Low).
2. 슈미트 트리거 (Schmitt Trigger): 핀 바로 뒤에는 '슈미트 트리거'라는 문지기가 있음. 애매한 전압(1.5V 같은 노이즈)을 걸러내고, 확실한 0과 1 디지털 신호로 다듬어줌.
3. IDR (Input Data Register): 다듬어진 심호는 **IDR 레지스터** 의 특정 비트에 실시간으로 반영됨.

# 방식 1: 폴링 (Polling) - "계속 물어보기"
가장 원시적인 방법. CPU가 하던 일을 다 제쳐두고 버튼만 쳐다보고 있는 것.

#### 코드의 실체
```c
// 무한 루프 안에서 계속 검사함
while (1) {
	// GPIOA의 IDR 레지스터의 0번 비트가 1인지 확인
	if (GPIOA->IDR & (1 << 0)) {
		// 버튼 눌림! 처리 로직
	}
}
```

#### 하드웨어 관점에서의 문제점
- CPU 낭비: CPU는 1초에 수천만 번 명령어를 실행할 수 있는데, 고작 사람이 버튼 누르는 걸 기다리느라 `if` 문만 수억 번돌리며 전기를 태우고 있음.
- 반응 속도: 만약 CPU가 다른 긴 작업(예: 화면 그리기)을 하느라 `if` 문 체크가 늦어지면, 버튼을 눌렀는데도 인식을 못 할 수 있음.

	비유: 배달 음식이 왔나 확인하려고 1초마다 현관문을 열어보는 것과 같음. 아무것도 못 하고 현관문만 봐야 함.
# 방식 2: 인터럽트 (Interrupt) - "초인종 누르기"
임베디드 시스템의 존재 이유. CPU는 자기 할 일을 하고 있고, 버튼이 눌리면 **하드웨어가 CPU를 툭쳐서 깨움**

#### 핵심 부품: NVIC(Nested Vectored Interrupt Controller)
ARM 코어 내부에는 **NVIC**라는 아주 똑똑한 비서(인터럽트 컨트롤러)가 살고 있음.
1. 설정: 프로그래머가 NVIC에게 "GPIOA 0번 핀에 신호가 오면 나한테 알려줘"라고 등록함.
2. 동작:
	- CPU는 `main()` 함수의 `while(1)` 루프에서 다른 복잡한 계산을 열심히 수행 중.
	- 사용자가 버튼을 클릭! (전압 상승)
	- EXTI (External Interrupt) 감지기가 이를 포착하고 NVIC에게 신호를 보냄.
	- NVIC는 즉시 CPU에게 "멈춰!" 신호를 보냄.

#### CPU의 반응 (하드웨어적 절차)
이 과정은 순식간에 자동으로 일어남.
1. Stop: CPU는 현재 실행 중이던 명령어 주소(PC)와 상태 레지스터(PSR)를 스택에 대피시킴. (Context Save)
2. Jump: 미리 약속된 함수 (ISR: interrupt Service Routine)로 강제 이동.
3. Run: 버튼 처리 코드를 실행함.
4. Return: 스택에서 원래 위치를 꺼내와서, 아무 일도 없었다는 듯이 하던 계산을 계속함.

	비유: 초인종(인터럽트)을 달았음, 거실에서 TV를 보다가(Main Loop), 초인종이 울리면 나가서 피자를 받고(ISR), 다시 돌아와서 보던 장면부터 이어서 봄.

# 인터럽트 벡터 테이블 (Vector Table): 주소록
"인터럽트가 터지면 `EXTI0_IRQHandler`라는 함수로 점프해라"라는 건 누가 알려줄까?
플래시 메모리의 **가장 앞부분(0번지 근처)** 에는 **인터럽트 벡터 테이블** 이라는 주소록이 있음.

| 주소 (Offset) | 내용                | 설명             |
| ----------- | ----------------- | -------------- |
| 0x0000 0000 | Stack Pointer 초기값 | 스택 시작 위치       |
| 0x0000 0004 | Reset Handler     | 부팅 시 실행할 함수 주소 |
| ...         | ...               | ...            |
| 0x0000 0058 | EXTI0_IRQHandler  | 버튼 눌리면 갈 함수 주소 |
- 링커의 역할: C 코드에서 `void EXTI0_IRQHandler()` 함수를 만들면, 링커가 알아서 이 함수의 주소를 벡터 테이블의 `0x58`번지에 적어놓음.
- 하드웨어의 동작: NVIC는 0번 인터럽트가 발생하면, 무조건 메모리 `0x58`번지를 읽어서 그 안에 적힌 주소로 점프함.

# 실전 분석: 디버깅으로 확인하기
인터럽트가 제대로 동작하는지 확인하는 방법.
1. ISR 함수에 브레이크 포인트: `EXTI0_IRQHandler` 함수 안에 브레이크 포인트를 검.
2. 실행 (Run): 프로그램을 실행함. 아무 일도 안 일어남. (CPU는 main 루프를 돌고 있음)
3. 버튼 클릭: 물리 버튼을 누르는 순간, 화면이 멈추고 디버거가 ISR 함수 내부에서 멈춤.
4. Call Stack 확인: 호출 스택 창을 보면, `main()` -> `HardWare_Trigger` -> `ISR` 순서가 아니라, `main()`과는 전혀 관계없이 독립적으로 호출된 스택을 볼 수 있음. (Exception Frame)
# 요약
- 폴링: CPU가 수동으로 계속 검사함. 비효율적이지만 구현은 단순함.
- 인터럽트: 하드웨어(NVIC)가 CPU를 호출함. 효율적이고 즉각적이지만, 설정이 복잡하고 디버깅이 까다로움.
