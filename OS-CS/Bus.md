C언의 **포인터(Pointer)**가 실제로 하드웨어에서 무엇을 의미하는지, 그리고 변수 선언이 물리적으로 어떤 영향을 미치는지 이해하는 핵심 열쇠.

# 버스 시스템 (Bus System): CPU의 고속도로
CPU는 혼자서 아무것도 못 함. 데이터를 가져오고 내보내기 위해 '버스(Bus)'라는 전선 묶음을 사용. 임베디드 보드 설계도를 보면 수많은 선이 CPU에서 뻗어 나오는데, 크게 세 종류로 나뉨.

### 주소 버스 (Address Bus) -> "어디로 갈까?"
- CPU가 메모리나 장치의 **특정 위치(번지수)**를 지정할 때 사용.
- 포인터와의 관계: C언어 포인터 변수에 담긴 값(`0x20001000`)이 바로 이 주소 버스를 타고 흐르는 전기 신호.
- 너비의 중요성:
	- 32비트 CPU는 주소 버스가 32가닥. 즉, $2^{32} = 4,294,967,296$개의 주소를 만들 수 있어 최대 4GB의 메모리를 인식할 수 있음. (이것이 32비트 시스템의 한계)

### 데이터 버스 (Data Bus) -> "무엇을 옮길까?"
- 실제 데이터(변수 값, 명령어 등)가 이동하는 길.
- 성능과의 관계: 32비트 CPU는 데이터 버스도 32가닥. 한 번에 32비트(`int`자료형 크기)를 '쑥' 옮길 수 있음.
- 프로그래밍 팁: 32비트 CPU에서 8비트(`char`)나 16비트(`short`) 연산을 하면, CPU는 내부적으로 이를 32비트로 변환해서 처리하곤 함. 때로는 그냥 `int`(32비트)를 쓰는 것이 가장 빠를 수 있습니다.

### 제어 버스 (Control Bus) -> "읽을까, 쓸까?"
- CPU가 메모리에게 "지금 보내는 주소의 값을 **읽어(Read)** " 또는 "이 값을 저 주소에 **써(Write)"** 라고 신호를 보냄.

---

# Memory Mapped I/O (MMIO): 임베디드의 꽃
PC 프로그래밍과 임베디드의 가장 큰 차이점. "CPU는 어떻게 LED를 켜고, 모터 속도를 조절할까요?" -> **"모든 하드웨어 장치를 메모리 주소처럼 취급한다"** 입니다.
- 원리: 예를 들어, `0x40000000`번지에 진짜 메모리(RAM)가 아니라, **LED 컨트롤러와 연결된 레지스터** 일 수 있음.
- C언어 적용: 우리가 이 주소에 1을 쓰면 LED가 켜지고, 0을 쓰면 꺼짐.
```c
// 코드 예시
// 0x40021018이라는 주소를 "부호 없는 32비트 정수형 포인터"로 형변환하고,
// 그 내용을 역참조(*)하여 값을 넣음.

#define LED_PORT_REG (*((volatile unsigned int *)0x40021018))

void led_on() {
	LED_PORT_REG = 0x00000001; // 하드웨어 레지스터에 비트 쓰기 -> LED 켜짐.
}
```

핵심 키워드: `volatile` 위 코드에서 `volatile`은 컴파일러에게 **"이 변수(주소)는 하드웨어에 의해 언제든 값이 바뀔 수 있으니, 제발 최적화(생략)하지 마!"** 라고 경고하는 것. 임베디드에서 이걸 빼먹으면 코드가 오작동.

---

# 메모리 계층 구조 (Memory Hierarchy)
"메모리는 빠를수록 비싸고 용량이 작습니다." 컴퓨터는 이 딜레마를 해결하기 위해피라미드 구조를 만듦.

1. 레지스터 (Registers): CPU 내부. 가장 빠름. (변수 몇 개 저장)
2. 캐시 (Cache L1/L2): CPU 바로 옆. 매우 빠름. (자주 쓰는 데이터 복사본)
3. 메인 메모리 (RAM): 주기억장치. 빠름. (실행 중인 프로그램과 변수)
4. 스토리지 (Flash//SSD/HDD): 보조기억장치. 느림. (전원이 꺼져도 데이터 보존)

### 프로그래머가 알아야 할 "지역성(Locality)"
캐시(Cache)는 **한 번 쓴 놈은 또 쓴다(시간 지역성)"** 와 **"방금 쓴 놈 옆에 있는 놈을 쓸 것이다(공간 지역성)"** 라는 가설로 동작.
- 나쁜 예: 연결 리스트(Linked List)는 메모리 여기저기에 데이터가 흩어져 있어 캐시 적중률(Hit rate)이 떨어집니다. (CPU가 데이터를 기다리느라 놂)
- 좋은 예: 배열(Array)은 메모리에 연속적으로 붙어 있어, 한 번 읽을 때 덩어리로 캐시에 들어옴. 따라서 배열 순회가 훨씬 빠름.

---

# 엔디안 (Endianness): 데이터 저장 순서
데이터를 메모리에 배열할 때 순서가 다를 수 있습니다. 초보자가 통신프로그램을 짤 때 가장 많이 고생하는 부분.
- 빅 엔디안 (Big-endian): 사람이 읽는 순서대로 저장 (상위 바이트가 낮은 주소에). 네트워크 표준.
- 리틀 엔디안 (Little-endian): 거꾸로 저장 (하위 바이트가 낮은 주소에). Intel x86, ARM 등 대부분의 CPU 방식.
	- 상황: `0x12345678`이라는 32비트 값을 저장할 때
	- Little-endian: 78 56 34 12 순서로 메모리에 들어감.
	- PC에서 만든 데이터를 그대로 네트워크로 쏘면 순서가 뒤집혀서 전송될 수 있음. 그래서 `htons()`, `htonl()`같은 변환 함수가 필요.

---

# 정리
1. 포인터는 주소 버스의 네비게이션: 포인터를 이해하는 것은 메모리 지도를 이해하는 것.
2. MMIO는 하드웨어 제어의 기본: 특정 주소에 값을 쓰는 행위가 물리적인 동작(LED ON)을 일으킴.
3. 캐시를 고려한 코딩: 데이터 구조를 어떻게 잡느냐가 속도를 결정.

**"C언어 코드가 실행 파일이 되는 과정(컴파일 과정)"** 을 깊게 파기.
C언어 소스 코드가 어떻게 **전처리 -> 컴파일 -> 어셈블리 -> 링킹** 과정을 거쳐 기계어(바이너리)가 되는지, 그리고 그 바이너리가 메모리에 어떻게 로딩되는지 알면 임베디드 시스템의 부팅 원리까지 이해.