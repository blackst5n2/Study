CPU의 캐시나 MMU 동작과 연결되는지 그 **본질적인 이유** 를 함께 이해하는 것이 중요함.

# 알고리즘 성능의 척도: 시간/공간 복잡도
알고리즘의 성능을 측정하는 것인 **실행 시간(초)** 이 아니라, **입력 데이터의 크기($N$)가 변함에 따라 연산 횟수가 증가하는 비율** 임. 이것을 **점근적 복잡도(Asymptotic Complexity)** 라고 하며, **빅오 표기법($O(\cdot)$)** 으로 나타냄.

#### 시간 복잡도 (Time Complexity)
프로그램 실행에 필요한 **연산 횟수** 를 $N$에 대한 함수로 표현함. 상수 시간, 즉 $(O(1))$부터 기하급수적 시간인 $O(2^N)$까지 있음.

| 빅오 표기법        | 명칭                  | N 변화에 따른 연산 횟수               | 특정 및 예시                                                  |
| ------------- | ------------------- | ---------------------------- | -------------------------------------------------------- |
| $O(1)$        | 상수 시간 (Constant)    | 입력 크기과 무관하게 항상 일정            | 해시 테이블 삽입/조회, 배열 인데스 접근.                                 |
| $O(\log N)$   | 로그 시간 (Logarithmic) | $N$이 2배 커지면 연산은 1회 증가.       | 매우 빠름. 이진 탐색(Binary Search).                             |
| $O(N)$        | 선형 시간 (Linear)      | $N$에 정비례하여 연산 횟수 증가.         | 배열 순회, 선형 검색.                                            |
| $O(N \log N)$ | 로그 선형 시간            | $N$이 커질수록 효율이 좋음             | 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) 등 대부분의 효율적인 정렬 알고리즘. |
| $O(N^2)$      | 이차 시간 (Quadratic)   | $N$이 2배 커지면 연산은 4배 증가.       | 이중 반복문(Nested Loop), 비효율적인 정렬(버블 정렬).                    |
| $O(2^N)$      | 지수 시간 (Exponential) | 극도로 느림. $N = 30$만 되어도 계산 불가. | 순수한 무차별 대입 공격, 일부 여행하는 외판원 문제.                           |

#### 왜 빅오 표기법을 쓰는가?
1. 하드웨어 독립성: 특정 CPU의 클럭 속도에 의존하지 않고, **알고리즘 자체의 효율** 을 객관적으로 비교할 수 있음.
2. 가장 큰 항 우선: $O(N^2 + N + 10)$에서 $N$이 커지면 $N^2$의 영향이 지배적이므로, 가장 큰 영향력을 가진 항만 남겨 $O(N^2))$으로 표기함. (상수항이나 낮은 차수의 항은 무시)

# $O(1)$의 기적: 해시 테이블 (Hash Table)의 원리
해시 테이블(Hash Map, Dictionary)은 **키(Key)** 와 **값(Value)** 을 저장하며, **평균적인 상수 시간($O(1)$) 내에 검색, 삽입, 삭제가 가능한 혁신적인 자료구조** 임.

#### 내부 구조
1. 배열 (버킷, Bucket): 데이터를 실제로 저장하는 기본 공간.
2. 해시 함수 (Hash Function): 입력받은 **키(Key)** 를 **배열의 유효한 인덱스(Index)** 로 변환해 주는 함수.

#### 해시 테이블의 작동 과정
1. 삽입 (Insert):
	- 키(예: "Apple")를 해시 함수에 넣음.
	- 해시 함수가 인덱스(예: `100번`)를 반환함.
	- 데이터를 배열의 `100번` 위치에 저장함.
2. 조회 (Lookup):
	- 조회할 키("Apple")를 해시 함수에 넣음.
	- 해시 함수가 인덱스 `100번`을 반환함.
	- 배열의 `100번` 위치를 **단 한 번에 접근** 하여 데이터를 가져옴. -> $O(1)$ 달성.

#### 가장 큰 난제: 해시 충돌 (Hash Collision)
해시 함수의 출력이 제한적이기 때문에, **서로 다른 키** 가 **동일한 인덱스 (해시 값)** 를 반환하는 현상임. (예: "Apple"과 "Banana" 둘 다 인덱스 `100번`을 반환)

##### 충돌 해결 방법 1: 체이닝 (Chaining)
- 원리: 배열의 각 인덱스에 **연결 리스트(Linked List)** 를 연결함.
- 동작: 충돌이 발생하면, 해당 인덱스(버킷)의 연결 리스트에 데이터를 추가함.
- 성능: 리스트의 길이가 길어지면 **선형 검색($O(N)$)** 을 해야 하므로, $O(1)$ 성능을 유지하려면 **해시 함수가 고르게 분산** 되도록 설계하는 것이 핵심. (현대 언어의 표준 구현 방식)

##### 충돌 해결 방법 2: 개방 주소법 (Open Addressing)
- 원리: 충돌이 발생하면 해당 위치 대신, 배열의 **다른 비어있는 위치** 를 찾아 데이터를 저장함.
- 탐색: 비어있는 위치를 찾는 방식(선형탐자, 이차 탐사 등)이 필요함.
- 단점: 특정 위치에 데이터가 몰리는 **클러스터링(Clustering)** 현상이 발생하면 성능이 급격히 저하됨.

#### 시스템과의 연결: 캐시/MMU/DB
모든 고성능 시스템은 이 해시 테이블의 원리를 차용함.
1. CPU 캐시: **Set-Associative Cache** 는 메모리 주소의 인덱스 부분(Index)을 사용하여 **세트 번호** 를 찾음. 이는 **해시 테이블의 버킷** 을 찾는 과정과 유사함.
2. MMU/TLB: TLB는 가상 주소를 **물리 주소** 로 빠르게 변환하기 위한 작은 캐시임. 가상 주소를 **키** 로, 물리 주소를 **값** 으로 하는 **해시 테이블** 과 같은 역할을 수행함.
3. 데이터베이스: 파일 시스템의 **디렉터리** 구조와 데이터베이스의 **B-Tree** 인덱스도 결국 **'키(이름/값)를 통해 데이터의 위치를 빠르게 찾는'** 해시 또는 트리 기반의 자료구조.

