**데이터의 기밀성** 뿐만 아니라, **"이 데이터가 진짜 나에게 온 것이 맞는가?"** 를 보장하는 **인증(Authentication)** 과 **부인 방지(Non-repudiation)** 기술.

# 신뢰의 핵심: 공개 키 기반 구조 (PKI)
**PKI (Public Key Infrastructure)** 는 디지털 세게에서 신원을 확인하고 통신을 암호화하는 데 필요한 모든 구성 요소(정책, 인증 기관, 시스템)를 포괄하는 거대한 구조임.

#### 인증성 (Certificate)
- 정체: 특정 주체(웹사이트, 서버, 개인)의 **공개 키(Public Key)** 와 그 주체의 **신원 정보** 를 묶어 신뢰할 수 있는 제3자(인증 기관)가 **서명** 해준 디지털 문서임. (예: SSL/TLS 통시 시 서버가 브로우저에게 보내는 파일)
- 포함 정보: 주체의 이름/도메인, 공개 키, 인증 기관(CA)의 디지털 서명, 유효 기간.

#### 인증 기관 (CA: Certificate Authority)
- 역할: 인증서의 **발급, 관리, 폐지** 를 담당하는 **가장 신뢰받느 제3자**.
- 신뢰의 고리: CA는 자신의 개인 키로 발급한 인증서에 서명함. 모든 운영체제와 브라우저는 **'루트 CA'** 의 공개 키를 미리 가지고 잇어, 이 서명을 검증하고 해당 인증서가 진짜임을 확인함.

# 무결성과 신원 확인: 디지털 서명 (Digital Signature)
**디지털 서명** 은 데이터의 **무결성(Integrity)** 과 **부인 방지(Non-repudiation)** 를 동시에 확보하는 핵심 기술.

#### 디지털 서명의 생성 (Sender)
1. 데이터 해시: 보낼 원본 데이터 전체를 **해시 함수(SHA-256 등)** 로 돌려 **고정 길이의 메시지 다이제스트(Digest)** 를 생성함. (무결성 확보)
2. 개인 키로 암호화: 이 다이제스트를 **보내는 사람의 개인 키(Private Key)** 로 암호화함. 이것이 바로 **디지털 서명**임.

#### 서명의 검증 (Receiver)
1. 해시 생성: 수신된 **원본 데이터**를 수신자도 동일한 해시 함수로 돌려 **새로운 다이제스트(A)** 를 만듦.
2. 공개 키로 복호화: 수신된 디지털 서명을 **보낸 사람의 공개 키(Public Key)** 로 복호화하여 **원래의 다이제스트(B)** 를 복원함.
3. 비교: (A)와 (B)를 비교함.
	- 일치: 1) 데이터가 위변조되지 않았고, 2) 서명자의 개인 키로 서명되었음이 입증됨. (무결성 + 부인 방지 완료)
	- 불일치: 데이터가 위변조되었거나, 서명자가 사칭되었음.

	 TLS 연결: 웹 서버는 인증서에 포함된 **자신의 개인 키**로 클라이언트와의 통신 정보를 서명하여 "나는 이 서버가 맞다"고 신원을 확인함.

# 최종 정리
> 이론을 단 하나의 프로젝트에 통합하기.
> 1. 하드웨어 선택: 원하는 MCU (예: ESP32 또는 Raspberry Pi Pico W)를 선정함.
> 2. 운영체제 적용: RTOS 또는 경량 Linux 커널을 포팅.
> 3. 통합 프로젝트:
> 	- 센서 데이터 수집 (ADC/Timer)
> 	- 데이터를 파일 시스템(LittleFS)에 기록
> 	- 네트워크(LwIP/Sockets)를 통해 클라우드 서버 연결
> 	- MQTT/HTTPS 프로토콜을 사용하며 TLS/PKI를 적용하여 안전하게 데이터 전송 (가장 중요)

