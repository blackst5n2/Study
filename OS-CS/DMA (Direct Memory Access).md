폴링, 인터럽트는 모드 CPU가 직접 데이터를 나르는 방식. 마치 사장(CPU)이 직접 트럭을 운전해서 물건을 배달하는 꼴. 사장은 그 시간에 경영(알고리즘 연산)을 해야 했음.

DMA는 사장이 고용한 **"전문 배달 기사(하드웨어)"**

# DMA의 존재 이유: CPU에게 자유를!
고속 SPI 통신(10Mbps)으로 1MB 크기의 화면 데이터를 보낸다고 가정.
- 인터럽트 방식: 1바이트 보낼 때마다 인터럽트가 걸림. CPU는 하던 일을 100만 번이나 멈추고 `ISR`로 점프했다가 돌아와야 함. (Context Switching 오버헤드 폭발) -> 시스템 마비
- DMA 방식: CPU가 DMA에게 "야, 메모리 `0x2000`번지부터 1MB만큼 SPI로 보내놔. 다 끝나면 전화해."라고 명령만 함. -> CPU는 바로 리턴해서 다른 복잡한 연산을 수행.

DMA 컨트롤러는 CPU를 거치지 않고, 버스(BUS)를 통해 메모리(RAM)와 주변 장치(Peripheral)를 직접 연결해 줌.

# DMA의 동작 원리: 버스 쟁탈전 (Bus Arbitration)
DMA도 결국 데이터를 나르려면 '시스템 버스(고속도로)'를 써야 함. 그런데 도로는 하나뿐이고, CPU도 메모리를 읽으려면 도로를 써야 함.

여기서 **"버스 중재(Bus Matrix)"** 라는 개념이 나옴.
1. Request: UART나 SPI가 "데이터 준비됐어요!"라고 DMA에게 신호를 보냄.
2. Bus Grant: DMA는 버스 제어기에게 "도로 좀 쓸게"라고 요청함. CPU가 급한 일을 안 하고 있다면, 버스 제어권이 DMA로 넘어감.
3. Transfer: DMA가 메모리에서 데이터를 퍼서 UART 레지스터로 씀. (이 순간 CPU는 잠깐 멈칫할 수 있음. 이를 *Cycle Stealing* 이라고 함.)
4. Interrupt: 지정한 개수만큼 전송이 끝나면, DMA가 비로소 CPU에게 인터럽트(Transfer Complete)를 날려 보고함.

# 핵심 기능: 원형 모드 (Circular Mode)
임베디드에서 오디오나 센서 데이터를 다룰 때 가장 중요한 기능.
- Normal Mode: 한 번 보내면 끝남. 다시 보내려면 CPU가 설정을 다시 해줘야 함.
- Circular Mode: 버퍼의 끝에 도달하면 자동으로 다시 처음으로 돌아감.
	- 활용 (Double Buffering):
		- DMA가 버퍼의 **절반(Half)** 을 채우면 "반 찼다!" 인터럽트를 줌. -> CPU는 이 절반을 처리함.
		- 그동안 DMA는 멈추지 않고 나머지 절반을 계속 채움.
		- 이렇게 하면 데이터가 끊기지 않고 무한히 스트리밍될 수 있음. (MP3 플레이어의 원리)

# 하드웨어적 함정: 캐시 일관성 (Cache Coherency) 문제
초보자가 DMA를 처음 쓰면 무조건 겪는 **"데이터가 안 바뀌는데요?"** 문제. 하드웨어 지식이 없으면 며칠 밤을 새우는 원인.

#### 문제 상황:
1. CPU는 속도를 높이기 위해 RAM 데이터를 **캐시(Cache)** 에 복사해두고 씀.
2. DMA가 RAM의 실제 값을 새로운 센서 데이터로 바꿈. (DMA는 캐시를 거치지 않고 RAM에 직접 씀.)
3. CPU는 RAM이 바뀐 줄 모르고, 여전히 **자기 캐시에 있는 옛날 값**을 읽음.
4. 결과: "분명히 DMA 완료 인터럽트가 떴는데, 데이터는 그대로예요!"

	해결책 (Code):  DMA가 전송을 완료했다는 신호가 오면. CPU가 해당 메모리 영역의 캐시를 강제로 미우도(Invalidate) 명령해야 함.
```c
// DMA 완료 인터럽트 핸들러(ISR)에서
void DMA1_Stream0_IRQHandler(void) {
	if (TransferComplete) {
		// "야 CPU야, 0x2000번지부터 100바이트만큼 캐시 맏지 말고 RAM 가서 다시 읽어와!"
		SCB_InvalidateDCache_by_Addr((uint32_t *)buffer, 100);
	}
}
```

# 요약: 사장님(CPU)의 업무 위임 기술
1. DMA는 메모리 복사를 대신해 주는 하드웨어 알바생.
2. 인터럽트 횟수 감소: 1바이트마다 걸리던 인터럽트가, 데이터 1000개를 다 보낸 후 단 1번만 걸리게 됨.
3. 캐시 조심: CPU의 눈(캐시)과 실제 창고(RAM)의 상태가 다를 수 있으니, 캐시 관리(Cache Maintenance) 함수를 꼭 써야 함.


