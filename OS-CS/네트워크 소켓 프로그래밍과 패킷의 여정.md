"모든 것은 파일이다(Everything is a file)"라는 리눅스/유닉스 철학에 따라, **네트워크 연결** 도 예외가 아님.

OS 커널 입장에서 네트워크 연결은 그저 **"쓰고 읽을 수 있는 또 하나의 파일"** 일 뿐임.

# 소켓(Socket)의 정체: "전화기 만들기"
C언어에서 소켓을 만들면 `int` 형 숫자가 하나 툭 튀어나옴. 이것이 바로 **파일 디스크립터(File Descriptor, FD)** 임.

#### `socket()` 함수: 전화기 개통
```c
int server_fd = socket(AF_INET, SOCK_STREAM, 0);
```
- 유저 영역: `server_fd`라는 변수에 숫자 `3`이 담김. (0, 1, 2는 표준 입출력이므로 보통 3부터 시작)
- 커널 영역: 메모리에 **TCB (Transmission Control Block)** 라는 거대한 구조체를 하나 생성함. 여기에는 "이 소켓의 상태(State)", "IP 주소/포트", "송수신 버퍼" 등이 저장됨.
- 연결: 숫자 `3`은 커널에 있는 이 TCB를 가리키는 **인덱스(Index)** 임.

#### `bind()`: 전화번호 할당
```c
bind(server_fd, (struct sockaddr *)&address, ...);
```
- 역할: "이 전화기(소켓)에 `192.168.0.10:80` 이라는 번호를 부여해라."
- 커널 동작: TCB에 해당 IP와 Port 정보를 기록함. 만약 이미 누가 쓰고 있는 포트라면 에러(`EADDRINUSE`)를 냄.

# 연결 수립: 3-Way Handshake의 코드 구현
TCP 연결 과정이 코드로는 어떻게 표현되는가.

#### 서버 측: `listen()`과 `accept()`
1. `listen(server_fd, 10)`: 소켓을 "대기 모드"로 바꿈. 이제부터 외부에서 연결 요청(SYN)이 오면 **대기열(Backlog Queue)** 에 쌓아둠.
2. `accept(server_fd, ...)`: 대기열에서 연결이 완성된 놈을 하나 꺼냄.
	- 중요: `accept`는 **새로운 소켓(`new_socket`)** 을 반환함.
	- 기존 `server_fd`는 계속 "전화 받는 용도(Listening)"로만 쓰고, 실제 대화는 새로 만든 `new_socket`으로 함. (서버가 여러 클라이언트를 동시에 처리하는 비결)

#### 클라이언트 측: `connect()`
```c
connect(client_fd, (struct sockaddr *)&server_addr, ...);
```
- 동작: 이 함수를 호출하는 수간, 커널은 **SYN 패킷** 을 날리고, 서버의 응(SYN, ACK)을 받아 ACK를 보낼 때까지(3-way Handshake 완료 시까지) **함수를 리턴하지 않고 대기(Blocking)** 함.

# 데이터 전송: `send()`의 거대한 착각
가장 오해가 많은 부분. `send(sock, buffer, size` 함수가 성공적으로 리턴되었다고 해서, **상대방이 데이터를 받았다는 뜻은 절대 아님.**

#### 패킷의 여정 (User to Hardware)
1. User Space: `send()` 호출.
2. Kernal Copy: 커널은 유저가 넘겨준 `buffer` 데이터를 **커널 영역의 소켓 전송 버퍼(Socket Send Buffer)** 로 **복사(`memcpy`) 함.
	- `send()` 리턴 시점: 바로 이 **복사가 끝난 시점** 임. 데이터는 아직 내 컴퓨터의 RAM 안에 있음.
3. TCP Layer: 커널이 알아서 버퍼의 데이터를 쪼개고(Segmentation), TCP 헤더(Seq Num 등)를 붙임.
4. IP Layer: 목적지 IP 주소를 보고 IP 헤더를 붙이고, 라우팅 테이블을 확인함.
5. Driver & Ring Buffer: 완성된 패킷(`sk_buff`)을 네트워크 가드의 **Ring Buffer(DMA 영역)** 에 넣음.
6. Hardware: NIC(네트워크 카트)가 DMA로 데이터를 가져가 전기 신호로 씀.

# 임베디드 관점의 네트워크 최적화
임베디드(IoT) 장비는 메모리가 적어서 이 TCP/IP 스택을 그대로 쓰기 힘듦.

#### Zero-Copy (복사 줄이기)
`send()`를 할 때 유저 버퍼 -> 커널 버퍼로 복사하는 과정은 CPU를 낭비함.
- DMA 직접 연결: 고성능 임베디드 시스템은 유저가 만든 데이터를 **복사 없이** 바로 네트워크 카드가 DMA로 가져가게 설계하여 속도를 극대화함.

#### LwIP (Lightweight IP)
리눅스의 거대한 네트워크 스택 대신, 임베디드 전용으로 만든 가벼운 TCP/IP 라이브러리.
- 메모리 할당을 최소화하고(`pbuf` 구조체 사용), 불필요한 기능은 뺌. STM32나 ESP32 같은 MCU에서 주로 사용함.
