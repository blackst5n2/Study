#### Edge-Triggered (ET) vs Level-Triggered (LT) 로직
`kqueue`는 기본적으로 LT 방식으로 동작하지만, 성능을 극한으로 끌어올리려면 ET 방식을 고민해야 함.
- LT (기본값): 수신 버퍼에 데이터가 남아있으면 `kqueue`가 계속 알려줌. 안전하지만 중복 알림이 발생함.
- ET (`EV_CLEAR` 플래그): 데이터가 새로 들어온 순간 딱 한 번만 알려줌.
	- 로직 설계: ET를 쓰려면 한 번 알림이 왔을 때 `EAGAIN` 에러가 뜰 때까지 `recv`를 루프 돌여야 함.
	- 선택: `ArenaAllocator`의 속도가 빠르므로, ET 방식을 채택하여 시스템 콜 횟수를 줄이는 설계를 할 수 있음.

#### 송신(Write) 이벤트 관리 로직
초보적인 서버는 `send()`를 그냥 호출하지만, 정교한 서버는 **`EVFILT_WRITE`** 를 사용함.
- 문제: 상대방의 수신 버퍼가 꽉 찼을 때 `send()`를 호출하면 스레드가 블로킹되거나 에러가 남.
- 로직 설계: 1. 보낼 데이터를 일단 **보낼 큐(Send Queue)** 에 쌓아둠 2.  `kqueue`에 "이 소켓 이제 쓸 수 있어?"라고 `EVFILT_WRITE`를 등록함. 3. 커널이 "지금 써도 돼!"라고 신호를 줄 때만 큐에서 꺼내 실제 `send()`를 수행함. 4. 다 보냈으면 다시 `EVFILT_WRITE` 알림을 끔.

#### 타이머 이벤트 (Timer) 통합
`kqueue`는 소켓 이벤트뿐만 아니라 커널 타이머도 관리할 수 있음. (`EVFILT_TIMER`)
- 로직 설계: 별도의 타이머 스레드를 만들지 않고, `kqueue` 메인 루프 안에서 **"5초마다 핑(Ping) 보내기"** 나 "10초 동안 무응답인 세션 끊기" 같은 로직을 커널이 직접 신호를 주도록 설정할 수 있음.
	- 이렇게 하면 모든 시간 관련 로직이 네트워크 이벤트와 같은 흐름(Single Flow)으로 처리되어 동기화가 매우 쉬워짐.

#### 에러 및 예외 처리 (EOF/Disconnected)
단순히 `recv`가 0을 리턴하는 것 외에, 커널이 알려주는 플래그를 더 정교하게 읽어야 함.
- `EV_EOF`: 상대방이 소켓을 닫았음을 커널이 즉시 알려줌. `recv`를 시도하기 전에 미리 알 수 있어 자원 정리 로직을 더 빨리 실행할 수 있음.
