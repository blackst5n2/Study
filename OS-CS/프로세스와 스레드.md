#### 프로세스와 스레드: 근본적인 차이
OS 이론의 핵심 질문은 **"컴퓨터와 자원(CPU, 메모, I/O)을 누가 소유하고, 누가 실행할 것인가?"** 임. 이 질문에 대한 OS의 답변이 바로 프로세스와 스레드.

| 구분       | 프로세스 (Process)                              | 스레드 (Thread)                   |
| -------- | ------------------------------------------- | ------------------------------ |
| 정의       | 실행 중인 프로그램. OS로부터 독립적인 자원 할당을 받은 자원의 소유 단위. | 프로세스 내에서 CPU 명령어를 실행하는 실행의 단위. |
| 자원의 소유   | 독립적                                         | 공유 (프로세스 내)                    |
| 문맥 교환 비용 | 매우 높음 (자원 영역 교체 필요)                         | 상대적으로 낮음 (자원 영역 공유)            |

#### 프로세스(Process): 자원의 소유자 (The Owner)
프로세스는 OS가 관리하는 독립적인 공간. 이는 할당자가 작동하는 **'최상위 컨테이너'** 의 역할.
- 핵심 자원 (독립적 소유):
	- 코드 영역 (Text/Code): 프로그램 실행 명령어.
	- 데이터 영역 (Data): 전역 변수, 정적 변수.
	- 힙 영역 (Heap): 할당자들이 관리하는 동적 하당 메모리 영역
	- 프로세스 제어 블록 (PCB, Process Control Block): OS가 프로세스를 관리하기 위해 저장하는 메타데이터 (상태, 레지스터 값, 메모리 맵 정보 등).
- OS의 역할: OS는 각 프로세스에게 독립적인 가상 주소 공간을 할당함. 메모리를 요청할 때, OS는 이 가상 주소 공간의 일부를 해당 프로세스에 할당해 주는 것.

#### 스레드 (Thread): 실행의 흐름 (The Flow)
스레드는 프로세스 내에서 CPU 시간을 할당받아 명령을 수행하는 실질적인 일꾼임.
- 공유 자원: 같은 프로세스에 속한 모든 스레드는 코드, 데이터, 힙 영역을 공유함.
	- 연결고리: 이 때문에 멀티스레드 환경에서 힙(Heap)에 접근할 때, 두 스레드가 동시에 메모리를 변경하지 않도록 상호 배제(Mutex, Lock) 메커니즘이 필요해짐. 이는 할당자가 반드시 고려해야 할 동시성(Concurrency) 문제임.
- 개별 자원 (독립적 소유):
	- 스택 (Stack): 각 스레드는 **독립적인 호출 스택(Call Stack)** 을 가짐.
	- 연결고리: **함수 호출의 프롤로그/에필로그(Stack Frame)** 는 각 스레드마다 독립적으로 관리되는 영역임. 이 스택 영역에 지역 변수와 복귀 주소(`LR`)가 저장됨.
	- 레지스터 집합 (Registers): PC(Program Counter) 등 CPU의 상태를 저장하는 레지스터 값.

#### 문맥 교환 (Context Switching)의 비용: 왜 스레드가 효율적인가?
CPU는 한 번에 하나의 프로세스/스레드만 실행할 수 있음. 따라서 OS는 시간을 쪼개어 번갈아 실행시키는데, 이 과정을 **문맥 교환(Context Switching)** 이라고 함.
- 프로세스 문맥 교환:
	1. 현재 프로세스의 PCB와 레지스터 상태를 메모리에 저장.
	2. 새 프로세스의 PCB와 레지스터 상태를 CPU에 로드.
	3. 메모리 관리 유닛(MMU)의 TLB 및 페이지 테이블 전체 교체. (매우 높은 비용)
- 스레드 문맥 교환:
	1. 현재 스레드의 스택과 레지스터 상태만 저장.
	2. 새 스레드의 스택과 레지스터 상태만 로드.
	3. 힙, 코드, 데이터 영역을 공유하므로, **TLB와 캐시(Cache)**를 그대로 재사용할 가능성이 높음. (비용이 훨씬 낮음)

통찰: 스레드가 프로세스보다 가볍고 효율적인 이유는 자원의 공유 덕분에 문맥 교환 싯 시스템 자원의 재설정 비용을 최소화할 수 있기 때문임.
