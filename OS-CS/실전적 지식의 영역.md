이론은 CPU와 레지스터를 배웠지만, 실제 보드에서는 이 지식을 물리적으로 연결해야 함.

# 실물 하드웨어와 소통하는 법 (데이터 시트 & 회로도)

#### 데이터시트 분석 능력
- 놓친 부분: 우리가 배운 레지스터의 주소(`0x40001000` 등)는 누가 정해줄까? 바로 MCU 제조사가 제공하는 **데이터시트(Datasheet)** 에 명시되어 있음.
- 실전: "GPIO 포트 B의 5번 핀을 출력으로 설정해야지!" 라는 코드를 짜려면, 해당 MCU의 데이터시트를 펼쳐서 GPIO 레지스터의 구조(Mode, Output Data Register 등)와 그 레지스터의 메모리 주소를 찾아야 함.

#### 회로도(Schematic) 해독 능력
- 놓친 부분: 본인이 짠 코드의 `LED_PIN = 1` 명령이 하드웨어에서 어떤 물리적 선을 따라 흐르는지 알아야 함.
- 실전: LED가 켜지지 않을 때, 회로도를 보고 "이 핀이 풀업 저항에 연결되었는지, 아니면 트랜지스터를 거쳐서 연결되었는지"를 판단하여 코드의 로직(Active High/Low)을 결정함.

# 디버깅 및 분석 Workflow
가장 중요한 차이. 코드가 항상 완벽하게 돌아가지는 않음.

#### 디버깅 툴 사용 능력 (JTAG / SWD)
- 놓친 부분: 본인이 작성한 `g_rx_buffer` 전역 함수의 값이 실시간으로 RAM의 `0x20000324` 주소에서 어떻게 변하는지를 보려면 디버거가 필요함.
- 실전: JTAG나 SWD 같은 하드웨어 디버깅 인터페이스를 이용하여, 프로그램 실행을 멈추고(Breakpoint) 레지스터 값, 스택 상태, 전역 변수 값 등을 직접 조회하고 수정하는 능력이 필수임.

#### 프로파일링 (Profiling)
- 놓친 부분: 코드가 느린 진짜 원인을 찾아내는 능력.
- 실전: "이 함수가 30%의 CPU 시간을 잡아먹고 있네"라는 정보를 프로파일러를 통해 객관적인 수치로 확인하고, 그 부분을 비트 연산이나 인라인으로 최적화하는 과정이 필요함.

# 협업과 안전성 (Version Control & Testing)
코드가 혼자 돌아가는 것이 아니며, 고장나서는 안 됨.
#### 버전 관리 (Git)
- 놓친 부분: 전공생들은 코드를 쓰는 것만큼이나 코드의 변화를 기록하고 관리하는 것에 익숙함.
- 실전: Git을 사용하여 버그가 발생했을 때 언제부터 생겼는지 추적하고, 여러 사람이 동시에 코드를 합치는(Merge) 작업을 관리해야 함.

#### 튼튼한 코드 (Unit Testing)
- 놓친 부분: 임베디드 코드는 고장나면 안 됨.
- 실전: RTOS의 태스크나 드라이버의 핵심 함수를 떼어내어 **유닛 테스트(Unit Test)** 를 작성하여, 어떤 입력이 들어와도 정해진 출력을 보장하는지 확인하는 과정이 현업에서 매우 종요함.

> 이론적 지식(메모리  주소, 레지스터)을 실제 MCU와 연결하는 과정을 배워야 함.
> 
> 바로 JTAG/SWD 디버거의 원리와 사용법을 통해, C 코드 변수가 메모리의 물리적 주소에 ㅇ떻게 매핑되는지 눈으로 확인해 보는 것이 가장 효과적인 다음 단계가 될 것.

