CPU는 분기 예측을 위해 메모리나 디스크 같은 느린 저장소가 아닌, **매우 빠르고 작은 전용 하드웨어 구조체** 를 사용함.

#### BTB (Branch Target Buffer)
- 역할: 이전에 **어떤 주소** 에서 분기가 일어났을 때 **어디로 점프** 했는지(Target Address)를 저장하는 캐시임.
- 동작: CPU가 명령어 인출(IF) 단계에서 분기 명령을 발견하면, 메모리에 접근할 필요 없이 **BTB를 조회** 함.
	- 만약 BTB에 해당 분기 명령의 기록이 있다면, CPU는 즉시 BTB가 알려주는 **목표 주소(Target Address)** 로 다음 명령어를 인출함.
	- 이는 분기 며령의 해석(ID) 단계까지 기다릴 필요 없이, **파이프라인의 초기에 지연 없이** 다음 명령어를 가져오게 해줌.

#### BHT (Branch History Table)
- 역할: 특정 분기가 **'이전에 실제로 일어났는지(Taken)'** 또는 **'일어나지 않았는지(Not Taken)'** 의 이력을 저장함.
- 구조: 보통 **2-bit Saturation Counter (포화 계수기)** 를 사용함.
	- 이 2비트 카운터는 00부터 11까지의 상태를 가지며, 예측이 맞으면 카운트를 늘리고(분기할 확률 증가), 틀리면 카운트를 줄임(분기하지 않을 확률 증가)
	- 장점: 한두 번의 실수(틀린 예측)에 바로 예측을 바꾸지 않고, **두 번 연속 틀려야** 예측 방향을 완전히 바꾸기 때문에, **반복적인 패턴(예: for/while 루프)** 을 정확하게 예측하는 데 매우 효과적임.
#### GHR (Global History Register)
- 역할: 특정 분기 명령어뿐만 아니라, **최근에 실행된 여러 분기 명령의 결과(Taken/Not Taken)** 를 전역적으로 기록하는 레지스터.
- 장점: 현재의 분기 예측은 **이전의 다른 분기 결과** 에 의존하는 경우가 많음. (예: 함수 A의 결과에 따라 함수 B의 분기가 달라짐). GHR은 이러한 **상호 관계** 를 파악하여 예측 정확도를 높이는 데 사용됨.

# 코딩 최적화와의 연결
이러한 하드웨어 구조를 이해하면 코딩 시 다음 두 가지를 목표로 하게 됨.
1. 예측 가능한 분기: `if` 문이나 `for` 루프를 작성할 때, **가장 자주 실행될 조건** 을 `if` 문의 먼저 배치하여 CPU가 예측하기 쉽도록 힌트를 줄 수 있습니다.
2. 분기 최소화: **룩업 테이블(Look-up Table)** 을 사용하거나 **조건부 연산자(`? :`)** 를 사용하여, `if/else` 분기 자체를 명령어 수준에서 줄이는 노력을 함.
