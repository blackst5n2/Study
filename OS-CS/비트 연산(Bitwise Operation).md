C언어가 하드웨어를 가장 직접적으로 제어하는 유일한 방법.

CPU는 모든 것을 0과 1의 전기 신호로 처리함. 비트 연산은 이 0과 1의 개별 스위치를 켜고 끄는 기술이며, 하드웨어 레지스터 제어 및 극단적인 메모리 절약을 위한 핵심 알고리즘.

## 비트 연산이 임베디드에서 중요한 이유
### 하드웨어 레지스터 제어
앞서 배운 MMIO(Memory Mapped I/O)에서 특정 기능을 켜거나 끄는 것은 결국 **특정 메모리 주소의 비트 한두 개를 조작** 하는 것.
- 예: "GPIO 포트 C의 13번 핀을 출력 모드로 설정해라." -> CPU가 0과 1로 이루어진 특정 레지스터 값의 일부 비트만 변경해야 함.

### 효율성 (속도 & 메모리)
- 속도: 비트 연산은 ALU(산술 논리 장치)가 단일 클럭 사이클 안에 처리할 수 있는 가장 빠른 연산. 곱셉이나 나눗셈보다 수십 배 빠름.
- 메모리: 불필요한 `int` 변수 대신 8개의 플래그 정보를 1바이트 변수 하나에 담아 메모리를 절약할 수 있음.

## 핵심 비트 연산자 및 응용
C언어에서 비트 연산자는 6가지가 있음. 이를 조합하여 하드웨어 레지스터를 조작하는 3가지 기본 알고리즘을 숙달 해야 함.

### 켜기 (SET): 특정 비트를 1로 만들기
`|` (OR 연산)을 사용함. 현재 비트 값이 0이든 1이든, 마스트(Mask)와 OR연산을 하면 무조건 1이 됨.

$$ Value | Mask $$
응용 예시 (LED 켜기):
1. 목표: 32비트 레지스터에서 13번 비트만 1로 만들고 나머지는 유지한다.
2. 마스크: `(1 << 13)` -> 1을 왼쪽으로 13번 시프트하면 `0b0010000000000000` (13번째만 1)이 됨.
3. 코드:
```c
#define LED_PIN_13 (1 << 13) //마스크 정의

// 레지스터 값에 LED_PIN_13 마스크를 OR 연산
REG_CONTROL |= LED_PIN_13;
```

### 끄기 (CLEAR): 특정 비트를 0으로 만들기
`&` (AND 연산)과 `~` (NOT 연산)을 조합하여 사용함.
$$Value & (~Mask)$$
응용 예시 (LED 끄기):
1. 목표: 13번 비트만 0으로 만들고 나머지는 유지한다.
2. 마스크: `~(1 << 13)` -> 13번째 비트만 0이고 나머지가 모두 1인 마스크를 만듦.
3. 코드:
```c
// 레지스터 값에 LED_PIN_13의 NOT 마스크를 AND 연산
REG_CONTROL &= ~LED_PIN_13;
```

### 토글 (TOGGLE): 현재 비트 상태를 반전시키기
`^` (XOR 연산)을 사용함. XOR은 두 비트가 다를 때만 1이 됨.
- 비트가 0일 때 마스크(1)와 XOR하면 -> 1 (켜짐)
- 비트가 1일 때 마스크(1)와 XOR하면 -> 0 (꺼짐)
응용 예시 (LED 깜빡이기):
```c
// REG_CONTROL 값이 현재 0이면 1로, 1이면 0으로 바뀜
REG_CONTROL ^= LED_PIN_13;
```

## 실전 알고리즘: 값 추출 및 삽입 (Value Extraction & Insertion)
특정 비트 필드(N비트 묶음)에 들어있는 값을 읽거나, 그곳에 새로운 값을 쓰는 것은 임베디드 프로그래밍에서 흔한 일.

### 값 추출 (Extraction): 특정 비트 필드의 값 읽기
32비트 레지스터의 5번 비트부터 8번 비트까지 (총 4비트)의 값을 읽고 싶을 때.
1. 마스킹 (`&`): 필요한 4비트 외의 모든 비트를 0으로 만듦.
2. 시프팅 (`>>`): 추출된 4비트를 레지스터의 가장 오른쪽(LSB)으로 밀어내어 순수한 값으로 만듦.
```c
// 5번 비트부터 4비트 너비의 값을 추출
#define SHIFT_POS 5 // 시작 위치
#define MASK_WIDTH 0b1111 // 4비트 마스크 (0xF)

uint32_t raw_value = REG_STATUS;
// 1. & 연산: 5번~8번 비트만 남김
uint32_t masked_value = raw_value & (MASK_WIDTH << SHIFT_POS);
// 2. >> 연산: 값을 오른쪽 끝으로 밀어 순수한 값 추출
uint32_t extracted_value = masked_value >> SHIFT_POS;
```

### 값 삽입 (Insertion): 특정 비트 필드에 값 쓰기
새로운 값 `0b1011`을 5번 비트부터 8번 비트에 삽입하고 싶을 때.
1. Clear (`&`와 `~`): 먼저 기존에 있떤 5~8번 비트의 값을 0으로 깨끗하게 지움.
2. Shift & Set (`<<`와 `|`): 삽입할 값을 5번 위치로 시프트한후, 기존 레지스터 값과 OR 연산으로 합침.
```c
uint32_t new_data = ob1011; // 삽입할 4비트 값

// 1. Clear: 해당 비트 필드를 0으로 초기화
REG_CONTRROL &= ~(MASK_WIDTH << SHIFT_POS);
// 2. Set: 새로운 데이터를 시프트하여 합치기
REG_CONTROL |= (new_data << SHIFT_POS);
```

## C++에서의 발전: 비트 필드(Bit Field) 구조체
C++에서는 `struct` 안에 비트 필드(Bit Field) 문법을 사용하여 레지스터의 비트 단위 구조를 직관적으로 표현할 수 있음.
```c++
typedef sturct {
	uint32_t mode : 2; // 0~1번 비트: Mode 설정 (2비트)
	uint32_t speed : 4; // 2~5번 비트: 속도 설정 (4비트)
	uint32_t enable : 1; // 6번 비트: Enable 플래그 (1비트)
	uint32_t reserverd : 25; // 7~31번 비트: 예약 공간 (사용 안 함)
} ControlRegister;

// 메모리에 이 레지스터를 매핑
#define REG_CONTROL (*(volatile ControlRegister*)0x40001000)

void set_high_speed() {
	REG_CONTROL.speed = 10; // C++이 자동으로 비트 연산을 처리
	REG_CONTROL.enable = 1;
}
```
이 바식은 코드를 깨끗하게 만들지만, 내부적으로는 컴파일러가 위에 설명한 `&`, `|`, `<<`, `>>` 연산을 생성해주는 것과 같음. (컴파일러 최적화에 따라 다소 달라질 수 있으므로, 안전을 위해 C++보다는 C스타일의 직접 연산을 선호하는 임베디드 현장도 많음.)

---

# 요약
비트 연산은 단순한 수학이 아니라, 하드웨어 제어의 언어임.
1. Set/Clear/Toggle 알고리즘을 잊지 않기.
2. 레지스터 데이터 시트를 보며 Bit Masking을 설계하는 연습.

이제 컴퓨터의 하드웨어부터 코드가 실행되는 원리, 자료구조, 그리고 가장 낮은 레벨의 비트 조작 알고리즘까지 마침.

마지막으로, 이 모든 것이 실시간으로 협력하여 돌아가게 만드는 **"운영체제"** 개념이 필요합니다. 임베디드에서는 **RTOS (Real-Time Operating System)**라고 불림.

**"RTOS의 기본 개념, 태스크(Task) 스케줄링, 그리고 공유 자원(Shared Resource) 관리 기술"** 에 대해 알아보는 것이 훌륭한 임베디드 프로그래머가 되는 마지 퍼즐 조각.