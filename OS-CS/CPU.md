# CPU의 내부 구조 (The Anatomy)
CPU는 단순히 "계산기"가 아님. Registers와 Bus를 알아야 함.

## [[레지스터 (Registers)]]: CPU 내부의 초고속 저장 공간.
- 범용 레지스터 (General Purpose): 연산 데이터를 잠시 저장. (C언어의 `register` 키워드가 힌트를 주는 곳)
- PC (Program Counter): 다음에 실행할 명령어의 주소를 가리킴. 함수 호출, `if`문 분기할 때 이 PC값이 변함.
- SP (Stack Pointer): 현재 스택 메모리의 최상단을 가리킴. 지역 변수와 함수 복귀 주소가 저장되는 곳을 관리. (스택 오버플로우의 원인ㅇ를 이해하는 핵심.)
- Status Register (Flags): 연산 결과가 0인지, 음수인지, 오버플로우가 났는지를 비트(Bit) 단위로 저장.

## [[ALU (Arithmetic Logic Unit)]]: 산술(덧셈, 뺄셈) 및 논리(AND, OR, NOT) 연산을 당당하는 계산 장치. C언어의 비트 연산자가 이곳에서 직접 처리되므로 매우 빠름.

## [[CU (Control Unit)]]: 지휘자. 메모리에서 명령어를 가져와 해석하고, ALU나 입출력 장치에 신호를 보냄.

## [[버스 (Bus)]]: 데이터가 이동하는 도로.
- Data Bus: 데이터 이동 (32비트 CPU는 이 도로 폭이 32비트).
- Address Bus: 메모리 주소 전달 (이 폭이 넓을수록 사용 가능한 RAM 용량이 커짐).

# CPU의 동작 사이클 (The Heartbeat)
CPU는 전원이 켜져 있는 동안 Fetch - Decode - Execute라는 단순한 작업을 무한 반복. 이름 **명령어 사이클(Instruction Cycle)** 이라고 함.

1. Fetch (인출): PC(Program Counter)가 가리키는 메모리 주소에서 명령어를 가져옴.
2. Decode (해독): 가져온 명령어가 무엇인지(덧셈인지, 메모리 이동인지) CU가 분석.
3. Execute (실행): ALU를 통해 계산하거나 데이터를 이동.
4. Write-back (저장): 결과를 레지스터나 메모리에 씀.

임베디드 개발자 TIP: C언어의 한 줄(`a = b + c;`)은 CPU 내부에서 여러 개의 명령어(Load, Add, Store)로 쪼개져 실행. 이 과정 하나하나가 클럭(Clock)을 소모.

# 임베디드 프로그래머가 꼭 알아야 할 핵심 개념
단순한 구조를 넘어, "성능"과 "실시간성(Real-time)"을 다루기 위해 다음 개념들이 필수적.

### 인터럽트 (Interrupt)
CPU가 하던 일을 멈추고 긴급한 일을 처리하는 메커니즘.
- 상황: 버튼이 눌리거나, 타이머가 만료되거나, 센서 데이터가 도착.
- 동작: CPU는 현재 실행 중인 코드 위치(PC)와 상태를 스택에 저장, **ISR(Interrupt Service Routine)** 이라는 특수 함수로 점프.
- C언어 적용: 임베디드에서는 `main()` 문보다 ISR을 얼마나 효율적으로 짜느냐가 시스템 성능을 좌우.

### 파이프라인 (Pipeline)
명령어 처리 속도를 높이기 위해, 공장 컨베이어 벨트처럼 작업을 겹쳐서 수행하는 기법.
- 명령어 1이 '실행' 단계일 때, 명령어 2는 '해독', 명령어 3은 '인출'을 동시에 함.
- 주의점: `if` 문을 잘못 써서 분기 예측이 틀리면, 파이프라인에 들어와 있던 명령어들을 다 버려야 해서 성능 저하가 발생. (이를 Branch Penalty라고 함.)

### 캐시 메모리 (Cache Memory)
CPU는 엄청 빠른데 메인 메모리(RAM)는 상대적으로 느림. 이 속도 차이를 줄이기 위해 CPU 내부에 두는 고속 메모리.
- C언어 적용: 데이터를 연속적으로 배치하는 배열(Array)이 띄엄띄엄 연결된 리스트 (Linked List)보다 빠른 이유가 바로 캐시 적중률(Cache Hit) 때문입니다.

### RISC vs CISC (아키텍쳐)
- CISC (inter x86 등): 복잡하고 다양한 명령어를 가짐. PC/서버용.
- RISC (ARM 등): 단순하고 핵심적인 명령어만 가짐. 전력 소모가 적고 효율적이라 임베디드(스마트폰, IoT)의 90% 이상이 ARM 기반 RISC를 사용.

# C/C++ 코드와 하드웨어의 매핑
작성한 코드가 하드웨어에 어떻게 들어가는지 시각화.

| C 코드 영역                | 메모리 영역 (Memory Map) | 설명                               |
| ---------------------- | ------------------- | -------------------------------- |
| `void func() { ... }`  | Code (Text) Segment | 컴파일된 기계어 코드가 저장되는 곳 (읽기 전용)      |
| `int global_var = 10;` | Data Segment        | 초기화된 전역 변수/정적 변수.                |
| `int global_no_init;`  | BSS Segment         | 초기화되지 않은 전역 변수 (0으로 자동 초기화).     |
| `malloc()`, `new`      | Heap                | 런타임에 동적으로 할당되는 메모리.              |
| `int local_var;`       | Stack               | 지역 변수, 매개변수, 리턴 주소, 함수 종료 시 사라짐. |
중요: 임베디드 시스쳄 (특히 MCU)은 메모리가 매우 작습니다(예: 수 KB ~ 수 MB). 따라서 `Heap` 사용을 지양하고 `Stack` 크기를 잘 계산하는 것이 훌륭한 프로그래머의 자질.

# 정리
CPU를 이해했다는 것은 **"나의 C 코드가 전기 신호가 되어 어떻게 흐르는지 머릿속으로 그릴 수 있다."** 는 뜻.
1. CPU는 뇌, 클럭은 심장: 클럭 주파수$(Hz)$가 높을수록 빠르지만 전력을 많이 먹음.
2. 레지스터는 작업대: 모든 연산은 레지스터 위에서 일어남.
3. 메모리 맵은 지도: 내 변수가 어디에 저장되는지 항상 의식.

"CPU가 외부 세상(메모리나 센서)과 데이터를 주고받는 '버스(Bus) 시스템'과 '메모리 계층 구조'에 대해 "