**"실시간 데이터 수집 및 전송 시스템"** 설계.
#### 시스템 요구사항 (Scenario)
1. 동작 1: 1ms(1000Hz) 주기로 **센서 데이터(ADC)** 를 읽어 RAM에 저장한다.
2. 동작 2: 1초마다 LED를 깜빡여 시스템 생존을 알린다.
3. 동작 3: 저장된 데이터를 처리하여 UART로 PC에 전송한다.

# 지식 통합 아키텍쳐  (The Systhesis)
요구사항 만족을 위해, 하드웨어와 소프트웨어 지식을 어떻게 연결해야 하는지 분석.

| 요구사항          | 필요 기술                              | 하드웨어 동작 원리                                                                                                |
| ------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------- |
| 1ms 주기로 센서 읽기 | Timer + ADC + DMA                  | Timer 레지스터 설정으로 정확히 1ms 간격의 펄스를 만듦. 이 펄스가 ADC 변환을 트리거하고, 변환된 값은 CPU 개입 없이 DMA를 통해 RAM 버퍼에 쌓임. (CPU 부하 0%) |
| 1초마다 LED 깜빡임  | RTOS (Task) + Timer                | Timer를 기반으로 작동하는 RTOS 스케줄러가 Task (LED 제어)를 정확히 1000ms 후에 깨움. Task는 GPIO 레지스터를 토글함.                        |
| 데이터 처리 및 전송   | RTOS (Task) + UART + DMA           | 데이터 처리 Task는 ADC DMA 버퍼가 절반 또는 끝까지 찼다는 신호를 받고 깨어남. 처리된 데이터는 UART DMA 전송을 통해 전송됨.                          |
| 시스템 안전성       | Mutex + Volatile + Cache Coherency | 센서 데이터가 쌓이는 DMA 버퍼는 데이터를 읽는 Task와 데이터를 쓰는 DMA가 동시에 접근하므로, 읽기 전 RTOS Mutex로 잠금. (C/C++ 메모리 안전성)            |

## 코드의 추상화 계층 (Abstraction Layer)
실제 코드를 작성할 때, 하위 레지스터 조작을 RTOS의 힘을 빌려 Task라는 추상화 계층으로 나눔.

#### Task 1: DataAcquisitionTask (고속, 하드웨어 제어)
- 기능: ADC/DMA 설정만 함. 무한루프는 없음.
- 주요 코드: `HAL_ADC_Start_DMA(buffer, size)`
- CPU 활동: DMA 완료 인터럽트가 발생할 때만 잠시 깨어남.

#### Task 2: DataProcessingTask (저속, 연산 및 통신)
- 기능: DMA 버퍼를 분석하고 PC로 출력함.
- 주요 코드:
	1. `osMutexAcquire(data_lock)`: 메모리 안전성(Lock) 확보
	2. `SCB_InvalidateDCache_by_Addr(...)`: DMA 캐시 무효화
	3. `calculate_average(buffer)`: 데이터 연산
	4. `HAL_UART_Transmit_DMA(output_buffer, size)`: UART DMA 시작
	5. `osMutexRelease(data_lock)`: Lock 해제

#### Task 3: HeartBeatTask (저속, 생존 알림)
- 기능: 시스템이 살아있음을 알림.
- 주요 코드: `osDelay(500); GPIO_Toggle(LED_PIN);`
- CPU 활동: CPU를 낭비하지 않고 `osDelay` 상태로 Task Block 상태를 유지함,

# 마무리
- CPU 동작 원리와 메모리 구조 (기반)
- RTOS의 멀티태스킹과 함수 호출 규약 (운영 시스템)
- 주변 장치 레지스터 제어 및 통신 프로토콜 (입출력)
- DMA/인터럽트를 이용한 CPU 오프로딩 및 메모리 안전성 (최적화 및 견고함)

MCU의 데이터시트를 보면, **"어떤 레지스터를 설정해서 어떤 기능을 활성화 해야 하는가"** 에 대한 답을 스스로 찾아낼 수 있는 능력이 될 것.

> 이 지식을 적용할 첫 번째 임베디드 하드웨어(예: STM32, ESP32 등)를 선택하고, 위에 설계한 Task들을 직접 코딩하며 디버거로 레지스터와 DMA 버퍼의 변화를 눈으로 확인하는 것.

