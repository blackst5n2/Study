시스템 콜은 운영체제(OS)의 핵심 기능에 접근하기 위한 유일하고 표준화된 방법임. 저수준 I/O 함수들(`open`, `read`, `write`, `close`, `lseek` 등)은 모두 커널이 제공하는 시스템 콜을 직접적으로 호출하느 래퍼(Wrapper) 함수임.

## `open()`: 파일 열기 및 생성
`open()` 시스템 콜은 파일에 접근하기 위한 **파일 디스크립터(fd)** 를 생성하고 반환함.
#### 함수 시그니처 (리눅스 기준)

```c
int open(const char *pathname, int flags, mode_t mode);
```

#### 주요 `flags` (비트 OR 연산으로 조합 가능)

| 플래그          | 설명                                       |
| ------------ | ---------------------------------------- |
| `O_RDONLY`   | 앍기 전용으로 파일을 염.                           |
| `O_WRONLY`   | 쓰기 전용으로 파일을 염.                           |
| `O_RDWR`     | 읽기/쓰기 모두 가능하도록 염.                        |
| `O_CREAT`    | 파일이 없으면 생성함. (이때 `mode`) 인자가 필요함.        |
| `O_TRUNC`    | 파일이 존재하면 길이를 0으로 잘라냄 (기존 내용을 삭제),        |
| `O_APPEND`   | 파일 쓰기 시 항상 파일의 끝에 추가함.                   |
| `O_EXCL`     | `O_CREAT`와 함께 사용되며, 파일이 이미 존재하면 오류를 반환함. |
| `O_NONBLOCK` | I/O 작업 시 즉시 반환하며, 작업 완료를 기다리지 않음.        |

`mode` 인자 (권한 설정)

`O_CREAT` 플래그를 사용할 때만 의미가 있음. 파일 소유자, 그룹, 기타 사용자에게 부여할 접근 권한을 8진수로 지정함 (예: `0644`). 실제 권한은 이 모드 값과 프로세스의 umask 값의 상호작용으로 결정됨.

## `read()`: 파일에서 데이터 읽기
`read()`는 지정된 파일 디스크립터에서 데이터를 읽어 사용자 공간의 버퍼로 복사함.

#### 함수 시그니처
```c
ssize_t read(int fd, void *buf, size_t count);
```

#### 동작 방식
- `fd`가 가리키는 파일의 **현재 파일 오프셋(File Offset)** 부터 `count` 바이트만큼 데이터를 읽으려고 시도함.
- 읽은 데이터는 사용자 공간의 `buf` 메모리 영역에 저장됨.
- 성공적으로 읽은 바이트 수를 반환 하며, 이 수만큼 파일 오프셋이 자동으로 증가함.
- **파일의 끝(EOF)** 에 도달하면 `0`을 반환함.

#### `write()`: 파일에 데이터 쓰기
`write()`는 사용자 공간의 버퍼에 있는 데이터를 지정된 파일 디스크립터로 씀.

#### 함수 시그니처
```c
ssize_t write(int fd, const void *buf, size_t count);
```

#### 동작 방식
- `buf`에 있는 `count` 바이트의 데이터를 `fd`가 가리키는 파일의 현재 오프셋에 기록함.
- 성공적으로 쓴 바이트 수를 반환하며, 이 수만큼 파일 오프셋이 자동으로 증가함.
- `write()`가 반환에 성공했다고 해서 데이터가 **즉시 디스크에 저장되었다는 것을 의미하지 않음.** 데이터는 커널의 페이지 캐시(Page Cache)에 남아있을 수 있음.

## `close()`: 파일 디스크립터 닫기
`close()`는 더 이상 사용하지 않는 파일 디스크립터를 해제하고, 해당 fd에 연결된 커널 자원을 반환함.

#### 함수 시그니처
```c
int close(int fd);
```

#### 중요성
- 프로세스가 동시에 열 수 있는 파일 디스크립터의 개수에는 제한이 있으므로, 사용이 끝난 `fd`는 반드시 닫아야 함.
- `close()`를 호출하면 커널은 해당 파일 디스크립터를 **재사용 가능** 하도록 표시함.

## `lseek()`: 파일 오프셋 변경
`lseek()`는 다음에 읽거나 쓸 위치인 **파일 오프셋(File Offset, 파일 포인터)** 을 명시적으로 변경하는 시스템 콜임.

#### 함수 시그니처
```c
off_t lseek(int fd, off_t offset, int whence);
```

`whence` 인자 (기준 위치)
`lseek`는 파일 오프셋을 계산하기 위한 기준점을 설정함.

| `whence`   | 상수  | 설명                               |
| ---------- | --- | -------------------------------- |
| `SEEK_SET` | 0   | 파일의 **시작(Beginning)** 을 기준으로 함.  |
| `SEEK_CUR` | 1   | 파일의 **현재 위치(Current)** 를 기준으로 함. |
| `SEEK_END` | 2   | 파일의 **끝(End)** 을 기준으로 함.         |

#### 동작 방식
- 새로운 오프셋은 `offset`과 `whence`를 기준으로 계산됨. 예를 들어, 파일의 끝에서 100바이트 앞으로 이동하려면 `lseek(fd, -100, SEEK_END)`를 사용함.
- 성공 시 파일의 시작부터 계산된 **새로운 오프셋 값** 을 반환함.

# 시스템 콜의 처리 과정
시스템 콜 함수가 호출될 때 내부적으로 발생하는 과정을 시각적으로 이해하면 TDD에 도움이 될 것.

응용 프로그램이 `write()` 같은 함수를 호출했을 때의 흐름은 다음과 같음.
1. 사용자 코드 호출: `write(fd, buffer, size);`
2. libc 래퍼 함수: C 라이브러리의 `write()` 함수가 호출됨. 이 함수는 실제 시스템 콜 번호와 인자들을 레지스터에 설정함.
3. 커널 진입: 특수 명령어(`SYSCALL` 등)를 통해 CPU의 실행 모드가 **사용자 모드** 에서 **커널 모드** 로 전환됨.
4. 커널 핸들러: 커널의 **시스템 콜 핸들러** 가 실행되어, 레지스터에 저장된 시스템 콜 번호를 확인하고 해당하는 커널 함수(예: `sys_write`)를 실행함.
5. I/O 수행: 커널 함수는 파일 디스크립터 테이블 등을 참조하여 실제 파일 시스템 I/O 작업을 수행함.
6. 사용자 모드 복귀: 작업이 완료되면 커널은 반환 값(성공한 바이트 수 등)을 레지스터에 설정하고 CPU 모드를 **사용자 모드** 로 되돌림.
7. libc 함수 반환: 래퍼 함수는 레지스터의 값을 읽어 사용자 코드에게 반환함.
