# 하드웨어 인터페이스와 디버깅 Workflow
### 1단계: 하드웨어 인터페이스의 핵심 (JTAG/SWD)
코드를 CPU에 주입하고 제어하는 물리적인 통로를 이해해야 함.
- JTAG (Joint Test Action Group) / SWD (Serial Wire Debug): 아것은 MCU 칩의 특정 핀(Pin)을 통해 외부 디버거와 연결하는 통신 규악임.
	- 역할: CPU의 코어에 직접 접근하여, 코드를 멈추거나(Hatl), **한 줄씩 실행(Step)** 하거나, 레지스터의 값을 읽고 쓸 수 있게 해줌.
	- 의미: C 코드의 변수 이름이 RAM의 물리적 주소와 연결되는 마법이 일어나는 통로.

### 2단계: 브레이크 포인트 (Breakpoint)의 작동 원리
코드를 멈추게 하는 `Breakpoint`가 실제 하드웨어에서는 어떻게 작동할까?
- 원리: CPU 명령어의 특정 주소(`PC` 값)에 도착했을 때, 디버거가 **임시로 다른 명령어(예: 무한 루프나 트랩 명령어)** 를 삽입하여 CPU의 흐름을 강제로 멈춤.
- 실전 활용: 복잡한 함수 호출 체인 중간에 브레이크를 걸고, 스택 프레임을 한 단계씩 역추적하여 (Call Stack Window), 어떤 함수가 어떤 인자를 가지고 나를 불렀는지를 확인할 수 있음.

### 3단계: Watch Window와 메모리 덤프 (Memory Dump)
디버거의 핵심 기능. 우리가 설정한 변수가 메모리에서 어떻게 변하는지 보는 것.
- Watch Window: `int count` 변수를 등록하면, 디버거는 링커가 정의한 `count`의 RAM 주소(0x2000xxxx)를 지속적으로 읽어와 화면에 표시함.
- Memory Dump: CPU의 메모리 버스를 통해 특정 레지스터 주소(`0x4000xxxx`)에 직접 접근하여, **현재 하드웨어의 상태(0과 1)** 를 바이트 단위로 실시간 표시.
- 의미: `volatile` 키워드가 필요한 하드웨어 레지스터의 값이 실제로 디버거 화면에서 변하는 것을 볼 수 있음.
