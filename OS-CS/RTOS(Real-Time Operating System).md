# RTOS란 무엇인가? (vs GPOS)
Windows나 Linux 같은 일반 운영체제(GPOS)는 "공평함"과 "처리량"이 목표. 엑셀을 켜면서 유튜브를 볼 때 끊기지 않는 것이 중요함.

반면, RTOS의 핵심은 **"결정성(Determinism)"**임.
- 정의: "이 작업은 반드시 1ms 안에 끝나야 한다"는 마감 시간(Deadline)을 보장하는 OS임.
- 예시: 자동차 에어백 센서가 충격을 감지했는데, OS가 "잠시만요, 업데이트 중이에요"라고 하면 안 됨. -> RTOS는 무슨 일이 있어도 정해진 시간 내에 에어백을 터트림.

# 태스크(Task): 프로그램의 분신술
RTOS가 없는 시스템(Bare-metal)은 `main()` 안의 `while()` 루프 하나가 모든 일을 순서대로 처리 했음. 하지만 RTOS에서는 프로그램을 여러 개의 **태스크(Task)** 로 쪼갬.
- 구조: 태스크는 각각 독립적인 무한 루프 함수임.
- 핵심: 각 태스크는 자신만의 스택(Stack) 메모리를 가짐. (이게 중요함.)

### 태스크의 3가지 상태:
1. Running: 현재 CPU를 차지하고 실행 중인 상태. (CPU는 하나니까 오직 1개만 가능)
2. Ready: 실행될 준비는 됐는데, 더 높은 우선순위 태스크에 밀려 대기 중인 상태.
3. Blocked (Waiting): `delay()`를 불렀거나, 데이터가 오기를 기다리며 잠자고 있는 상태. (CPU를 쓰지 않음)

# 스케줄러(Scheduler)와 문맥 교환(Context Switching)
"CPU는 하나인데 어떻게 여러 태스크가 동시에 도는 것처럼 보일까요?" 아주 빠르게 번갈아 실행하기 때문임. 이 마술을 부리는 관리자가 스케줄러임.

### 문맥 교환 (Context Switching) 과정:
1. Tick 인터럽트: 1ms마다 타이머 알람이 울리면 스케줄러가 깨어남.
2. Save Context: 현재 실행 중인 태스크 A의 **레지스터 값(PC, SP, 범용 레지스터 등)** 을 태스크 A의 스택에 몽땅 저장함. (하던 일을 일시정지)
3. Select: 다음 실행할 태스크 B를 고름. (우선순위가 높은 놈으로)
4. Restore Context: 태스크 B의 스택에 저장되어 있던 레지스터 값들을 CPU로 복원.
5. Resume: 태스크 B는 자기가 멈췄던 줄 알지도 못한 채 이어서 실행됨.
	프로그래머의 주의점: 태스크를 많이 만들수록 각 태스크마다 스택 메모리를 할당해줘야 하므로 RAM 소모가 급격히 늘어남.

# 동시성 문제와 공유 자원 (Shared Resources)
RTOS의 가장 큰 적은 **"경쟁 상태(Race Condition)"** 임. 두 태스크가 하나의 전역 변수나 하드웨어 (예: UART 포트)를 동시에 건드리면 데이터가 깨짐.

이를 막기 위한 도구.

## 뮤텍스 (Mutex) - "화장실 열쇠"
상호 배제(Mutual Exclusion)의 약자임.
- 비유: 화장실(공유 자원)이 하나뿐이고 열쇠(Mutex)도 하나.
- 동작:
	1. 태스크 A가 열쇠를 쥐고 화장실에 들어감. (Lock)
	2. 태스크 B가 왔지만 열쇠가 없어서 밖에서 기다림. (Block)
	3. 태스크 A가 나와서 열쇠를 반납함. (Unlock)
	4. 태스크 B가 열쇠를 쥐고 들어감.
- 특징: 열쇠를 가진 주인(Owner)만이 열쇠를 반납할 수 있음.

## 세마포어 (Semaphore) - "빈 자리 카운터"
- 비유: 식당에 자리가 3개 있음.
- 이진 세마포어 (Binary Semaphore): 자리가 1개인 세마포어. 뮤텍스와 비슷하지만, **누가 반납해도 상관없다** 는 점이 다름. 주로 **"신호(Signaling)"** 용도로 씀, (예: 인터럽트가 "데이터 왔어!" 하고 깃발을 들면 태스크가 깨어남)
- 카운팅 세마포어 (Counting Semaphore): 자원이 N개 있을 때 사용함.

## 메시지 큐 (Message Queue)
태스크끼리 전역 변수로 대화하는 건 위험함. 대신 큐(파이프)를 통해 안전하게 데이터를 주고받음.
- 태스크 A가 큐에 데이터를 `Send`하고, 태스크 B가 `Receive`합니다. 큐가 비어있으면 태스크 B는 알아서 잠듦(Block).

# RTOS 프로그래밍의 고질병: 우선순위 역전 (Priority Inversion)
면접 단골 질문이자, 화성 탐사선 패스파인더(Pathfinder)호를 멈추게했떤 버그.
- 상황:
	1. 낮은 우선순위 태스크(L)가 뮤텍스를 잡고 작업 중.
	2. 높은 우선순위 태스크(H)가 깨어나서 그 뮤텍스를 달라고 하는데, L이 잡고 있어서 기다림 (Block).
	3. 갑자기 중간 우선순위 태스크 (M)가 나타나서 L을 새치기하고 CPU를 뺏어감. (L은 우선순위가 낮으니까.)
	4. 결과: H는 M 때문에 하염없이 기다리게 됨. M은 뮤텍스와 상관도 없는데 H를 방해하는 꼴이 됨.
- 해결책 (Priority Inheritance): L이 H가 원하는 뮤텍스를 잡고 있는 동안, L의 우선순위를 잠시 H만큼 높여줌. 빨리 일을 끝내고 비키라는 뜻.

# 정리
1. Hardware (CPU/Memory): 레지스터, 버스 스택의 물리적 의미를 이해.
2. Build Process: 코드가 기계어가 되어 메모리에 배치되는 과정을 앎.
3. Data Structures: `malloc`을 피하고 배열과 링 버퍼를 쓰는 이유를 배움.
4. Algorithms: 비트 연산으로 하드웨어를 제어하는 법을 익힘.
5. RTOS: 여러 작업을 시간 차질 없이 조율하는 지휘자가 됨.

"백문이 불여일타" 실제 보드를 가지고 프로젝트 진행.

1. Bare-metal: LED 깜빡이기부터 시작해서, 인터럽트로 버튼 입력 받기, UART 통신 구현하기. (레지스터 직접 제어 방식)
2. Driver: 온도 센서(I2C/SPI) 데이터를 읽어오는 드라이버 직접 작성하기.
3. RTOS Porting: FreeRTOS 같은 가벼운 OS를 올려서, 센서 값을 읽는 태스크와 화면에 뿌리는 태스크를 분리해 보기.