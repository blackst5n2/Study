운영체제는 어떻게 수많은 프로그램을 동시에 돌리고, 하드웨어를 안전하게 제어하는가?

# 프로세스 스케줄링 (Process Scheduling) 심화
스케줄러는 CPU라는 **한정된 자원(시간)** 을 여러 프로세스에게 어떤 기준으로 나눠줄기 결정하는 OS의 두뇌

#### 프로세스 상태 전이 (Process State Transition)
프로세스는 평생 동안 세 가지 상태를 오감.
1. 준비 (Ready): 실행할 모든 준비가 끝났고, CPU 차례만 기다리는 상태. (Ready Queue에 줄 서 있음)
2. 실행 (Running): 스케줄러에게 선택받아 CPU를 점유하고 코드를 실행하는 상태.
3. 대기 (Blocked/Waiting): I/O 요청(디스크 읽기, 키보드 입력)을 하고 그 응답을 기다리는 상태. CPU를 줘도 일을 못 하는 상태이므로, 스스로 CPU를 반납함.

#### 스케줄링 알고리즘 (Scheduling Algorithms)
스케줄러가 Ready Queue에 있는 놈들 중 "누구에게 CPU를 줄까?"를 결정하는 정책.

| 알고리즘                              | 방식                                                    | 장점                    | 단점                                                  | 임베디드/실전                   |
| --------------------------------- | ----------------------------------------------------- | --------------------- | --------------------------------------------------- | ------------------------- |
| FCFS IFirst-Come, First-Served)   | 먼저 온 놈이 먼저 씀 (선착순).                                   | 단순함.                  | 앞에 긴 작업이 있으면 뒤에 짧은 작업들이 하염없이 기다림 (Convoy Effect).   | 일괄 처리 시스템 외엔 거의 안 씀.      |
| SJF (Shortest Job First)          | 실행 시간ㄴ이 가장 짧은 놈 먼저.                                   | 평균 대기 시간이 가장 짤음 (최적). | 실행 시간을 미리 알 방법이 없음. (과거 기록으로 추측할 뿐)                 | 이론적으로만 최적.                |
| Round Robin (RR)                  | 정해진 시간(Time Slice) 만큼만 쓰고 강제로 쫓겨남.                    | 공평함. 응답 속도가 빠름.       | 문맥 교환(Context Switch) 오버헤드가 큼. Time Slice 크기 설정이 핵심 | 대부분의 시분할 OS(Linux 등)의 기본. |
| MLFQ (Multi-Level Feedback Queue) | 여러 개의 큐를 두고, CPU를 많이 쓰는 놈은 우선순위를 낮추고, I/O 위주인 놈은 높여줌. | 공평함과 성능을 모두 잡음.       | 구현이 매우 복잡함.                                         | 현대 범용 OS 스케즐러의 근간.        |

# 시스템 호출 (System Call): 유저와 커널의 경계
우리가 짠 프로그램(User Mode)이 하드웨어(디스크, 네트워크)를 직접 건드리면 시스템이 붕괴됨. 그래서 OS는 시스템 호출이라는 창구를 통해서만 하드웨어에 접근하도록 허락함.

#### 보호링 (Protection Rings)
CPU는 하드웨어적으로 권한 레벨을 구분함. (x86 기준)
- Ring 0 (Kernal Mode): 모든 하드웨어 접근 가능. (OS 커널)
- Ring 3 (User Mode): 하드웨어 접근 불가. 제한된 메모리만 접근 가능.
#### 시스템 호출의 동작 매터니즘 (The Mechanism)
C언어에서 `printf("Hello");`를 호출하면 내부적으로 `write()` 시스템 호출이 일어남.
1. 준비: 유저 프로그램이 **시스템 호출 번호** (예: write는 4번)를 CPU 레지스터(EAX 등)에 넣음.
2. 트랩 (Trap/Interrupt): 유저 프로그램이 `int 0x80` 또는 `syscall`이라는 특수 명령어를 실행함. 이는 **소프트웨어 인터럽트** 임.
3. 모드 전환: CPU는 즉시 Ring  -> Ring 0로 권한을 격상시키고, 미리 등록된 커널의 시스템 호출 핸들러로 점프함.
4. 검증 및 실행: 커널은 요청이 정당한지(권한 확인) 검사한 후, 하드웨어를 제어하여 작업을 수행함.
5. 복귀: 작업이 끝나면 `sysret` 명령어로 다시 Ring 0 -> Ring 3로 권한을 낮추고 유저 프로그램으로 돌아감.

	해킹 연결: 쉘코드가 하는 일이 바로 이 과정. 쉘코드는 레지스터에 `execve` 번호를 넣고 `syscall` 명령을 직접 때려서, 커널에게 "쉘(/bin/sh) 좀 실행해 줘"라고 정중하지만 강제적으로 요청하는 것.