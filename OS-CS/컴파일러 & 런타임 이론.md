#### 컴파일 과정의 4단계
프로그래밍 언어(C++, Java 등)로 작성된 소스 코드가 최종적으로 CPU가 이해할 수 있는 실행 가능한 기계어 파일이 되기까지는 복잡한 단계를 거침.

| 단계                     | 역할                                                          | 주요 산출물             | 연결고리                                          |
| ---------------------- | ----------------------------------------------------------- | ------------------ | --------------------------------------------- |
| 1. 전처리 (Preprocessing) | 매크로 확장, 헤더 파일 포함 (`#include` 처리)                            | 확장된 소스 코드. (.i)    |                                               |
| 2. 컴파일 (Compiling)     | 소스 코드를 구문 분석(Parsing)하고 **어셈블리어(Assembly Code)** 로 변환 및 최적화 | 어셈블리 코드 (.s)       | KMP/Tire와 같은 문자열 알고리즘이 파싱에 사용                 |
| 3. 어셈블 (Assembling)    | 어셈블리 코드를 기계어로 변환하여 오브젝트 파일 생성                               | 오브젝트 파일 (.o)       | 기계어는 CPU의 **ISA(명령어 집합)** 를 따름.               |
| 4. 링킹 (Linking)        | 여러 오브젝트 파일과 라이브러리를 묶어 하나의 실행 파일 생성                          | 실행 파일 (.exe, .out) | Memory Allocator의 `malloc` 함수가 라이브러리 형태로 링킹됨. |

#### 함수 호출 스택의 재해석: 런타임 환경
**프롤로그(Prologue)** 와 **에필로그(Epilogue)** 는 컴파일러가 생성하고, 런타임에 CPU가 실행하는 정확한 기계어 명령어의 집합임.
- 스택 프레임 (Stack Frame): 함수가 호출될 때마다 생성되는 메모리 단위.
	- 사용 주체: 스레드마다 독립적으로 가짐. (OS 이론과의 연결)
	- 저장 정보: 복귀 주소(`LR`), 지역 변수, 매개변수 등.
- 프롤로그 (Prologue): 함수 진입 시 실행.
	1. 이전 스택 프레임 정보 저장.
	2. `SP`를 이동시켜 새로운 스택 프레임 생성 (지역 번수 공간 확보).
- 에필로그 (Epilogue): 함수 복귀 시 실행.
	1. 리턴 값 레지스터(`R0`)에 저장.
	2. `SP`를 복원하여 스택 프레임 해제.
	3. `LR`에 저장된 복귀 주소로 점프.

통찰: 컴파일러는 이 프롤로그/에필로그 코드를 자동으로 삽입하며, 프로그램이 어떤 함수에서 어느 함수로 이동했는지에 대한 **순차적인 실행 흐름(Call Flow)** 를 엄격하게 관리함.


#### 정적 링킹 vs. 동적 링킹
링킹 단계는 라이브러리 코드를 실행 파일에 포함하는 방식에 따라 나뉨.
- 정적 링킹 (Static Linking)
	- 원리: 라이브러리 코드가 실행 파일(.exe) 안에 통째로 복사되어 포함됨.
	- 장점: 실행 파일이 독립적이며, 런타임에 라이브러리가 없어도 실행 가능.
	- 단점: 실행 파일 크기가 매우 커짐.
- 동적 링킹 (Dynamic Linking):
	- 원리: 라이브러리 코드를 실행 파일에 포함하지 않고, 실행 파일에는 **라이브러리르 찾을 주소(참조)** 만 기록함. (`.dll`, `.so` 파일)
	- 장점: 실행 파일 크기가 작고, 메모리를 공유하여 여러 프로그램이 같은 라이브러리를 사용할 때 RAM 절약.
	- 단점: 런타임에 라이브러리 파일이 없으면 실행 불가능.

#### 컴파일러 최적화와 ISA (명령어 집합)
- 최적화 (Optimization): 컴파일러는 생성된 어셈블리 코드를 재배치하거나 불필요한 연산을 제거하여 실행 속도를 높이는 작업을 수행함. (예: 반복문 재배치, 인라인 함수 등)
- ISA (Instruction Set Architecture): CPU가 이해할 수 있는 명령어 집합임. (x86, ARM 등)
	- 컴파일러는 특정 ISA에 맞게 기계어를 생성해야 함.
	- 연결고리: ADC와 같은 하드웨어 인터페이스나 스택 프레임의 레지스터(`R0`, `LR`, `SP`) 사용 규칙은 해당 CPU의 ISA 규격을 따름.
