"어떻게 무작위로 생성되는 엔티티 ID와, 빈틈없이 꽉 채워져야 하는 컴포넌트 배열을 연결할 것인가?"

## 데이터 매핑과 스파스 셋(Sparse Set)
해결해야 할 문제.
1. Entity ID: 1, 10, 5000번... (듬성듬성하고, 숫자가 매우 클 수 있음)
2. Component Array: 인데스 0, 1, 2... (빈틈없이 꽉 차있어야 캐시 효율이 좋음)
이 둘을 매핑하기 위해 가장 널리 쓰이는 기법이 **(Sparse Set)** 임.

### 구조: 두 개의 배열 (Sparse & Packed)
스파슷 셋은 내부적으로 두 개의 배열을 유지하여 이 문제를 해결함.

#### 스파스 배열 (Sparse Array) - "이정표"
- 인덱스(Index): 엔티티 ID (Entity ID)
- 값(Value): 실제 데이터가 저장된 '패킹 배열'의 인덱스
- 특징: 엔티티 ID의 최대 크기만큼 커야 함. 구멍(빈 공간)이 많음.

#### 패킹 배열 (Packed/Dense Array) - "실제 데이터 창고"
- 인덱스(Index): 0부터 1씩 순차적으로 증가 (빈틈 없음)
- 값(Value): 실제 컴포넌트 데이터 (또는 역참조를 위한 엔티티 ID)
- 특징: 데이터들이 메모리에 연속적으로 오밀조밀 모여 있음. (캐시 효율성)

## 작동 원리 시뮬레이션
이 구조가 어떻게 $O(1)$의 성능을 내며 데이터를 빽빼갛게 유지하는가?

#### 상황 1: 데이터 추가 (Add)
엔티티 ID: 3과 ID: 10에 컴포넌트를  추가한다고 가정.
1. Entity 3 추가;
	- `packed[0]`에 데이터 저장.
	- `Sparse[3]`에 `0` 기록. (3번 엔티티의 데이터는 0번째에 있다)
2. Entity 10 추가:
	- `packed[1]`에 데이터 저장.
	- `Sparse[10]`에 `1` 기록. (10번 엔티티의 데이터느 1번째에 있다)

| Sparse Index (EntityID) | Value (Packed Index) | Packed Index | Data (Component)   |
| ----------------------- | -------------------- | ------------ | ------------------ |
| ...                     |                      | 0            | [Entity 3's Data]  |
| 3                       | 0                    | 1            | [Entity 10's Data] |
| ...                     |                      |              |                    |
| 10                      | 1                    |              |                    |

#### 상황 2: 데이터 조회 (Get)
"엔티티 10의 데이터를 줘."
1. `Sparse[10]`을 확인 -> 값은 `1`.
2. `Packed[1]`에 접근 -> 데이터 반환.
3. 결과: 배열 인덱스 접근 2번이므로 **$O(1)** 임.

#### 상황 3: 데이터 삭제 (Remove) - 핵심 기술
"엔티티 3의 데이터를 지워줘."

보통 배열 중간의 데이터를 지우면 구멍이 생기거나, 뒤의 데이터를 다 당겨와야 해서 느림($O(N)$). 하지만 ECS는 **Swap and Pop (스왑 앤 팝)** 기법을 씀.
1. 삭제할 타겟 확인: 엔티티 3은 `Packed[0]`에 있음
2. 끝 요소 가져오기: `Packed`의 맨 마지막 요소(현재는 Entity 10, 인덱스 1)를 가져옴.
3. 덮어쓰기 (Swap): 맨 마지막 요소 (Entity 10)를 삭제할 자리(`Packed[0]`)로 옮김.
4. 이정표 갱신: 옮겨진 Entity 10의 위치가 바뀌었으니, `Sparse[10`의 값을 `1`에서 `0`으로 업데이트함.
5. 크기 줄이기 (Pop): `Packed` 배열의 크기를 1 줄임.

결과:
- `Packed` 배열은 여전히 빈틈없이 0번 인덱스부터 채워져 있음.
- 삭제 연산도 **$O(1)$** 에 끝났음.

## 하드웨어 관점에서의 이점

#### 시스템(System)의 순회 속도
`System`이 로직을 돌릴 때는 `Sparse` 배열을 보지 않음. 오직 `Packed` 배열만 처음부터 끝까지 순회함.

```c++
// 실제 메모리 접근 패턴
for (int i = 0; i < count; ++i) {
	// 메모리 주소가 i가 증가함에 따라 정확히 연속적임
	// 하드웨어 프리페처(Prefetcher)가 다음 데이터를 미리 캐시에 가져옴
	Update(Packed[i]);
}
```

이 과정에서 캐시 미스가 거의 0에 수렴함.

#### 엔티티 조회 비용
랜더맣게 특정 엔티티에 접근할 때(`Sparse` 배열 참조)는 캐시 미스가 발생할 수 있음. 하지만 게임 루프의 90% 이상은 "전체 순회(System Update)"이지 "개별 조회"가 아니므로 전체적인 성능 이득이 훨씬 큼.

# 요약
1. Sparse Set: 듬성듬성한 Entity ID와 빽빽한 Component 데이터를 연결하는 자료구조.
2. 구성: `Sparse Array`(ID -> Index)와 `Packed Array`(실제 데이터).
3. Swap and Pop: 삭제 시 맨 끝 데이터를 빈자리로 옮겨서, 배열의 연속성을 항상 유지함 ($O(1)$).
4. 효과: 시스템은 `Packed Array`만 순회하므로 최강의 캐시 효율을 달성함.
