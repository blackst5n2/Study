해시 테이블은 $O(\log n)$의 성능을 가진 트리 구조의 한계를 넘어, 평균적으로 **$O(1)$ (상수 시간)** 의 압도적인 탐색/삽입/삭제 성능을 제공하여, DB 인덱스, 캐싱 시스템, 서버 등 거의 모든 고성능 시스템에서 사용되는 핵심 자료구조.

# 해시 테이블 (Hash Table) 구현
#### 해시 테이블의 목표 및 원리
- 목표: 데이터를 저장할 때, 그 데이터의 키(Key)를 입력하면 **수학적인 함수(Hash Function)** 를 통해 데이터의 저장 위치(Index)를 바로 계산하여 $O(1)$의 속도를 달성함.
- 구조: 배열(테이블)과 이를 보조하는 연결 리스트(체이닝 방식)로 구성됨.

#### 핵심 수학: 해시 함수 (Hash Function)
해시 테이블의 성능은 해시 함수의 품질에 의해 결정됨.

##### 핵심 원리: 키(`K`)를 배열의 유효한 인덱스(`I`)로 매핑하는 함수임.
$$I = H(K)$$
가장 단순한 해시 함수는 **나머지 연산(Modulo)** 을 이용함.
$$I = \text{Key} \pmod{\text{TableSize}}$$
- 성능 조건: 해시 함수는 키를 테이블 전체에 고르게 분산시켜야 함. (이것이 확률론적 문제임.)

#### 시행착오: 해시 충돌 (Collision)
해시 테이블의 가장 큰 문제이자 시행착오임.
- 문제: 서로 다른 두 키 $K_1$과 $K_2$가 같은 인덱스 $I$를 반환하는 경우임. ($H(K_1) = H(K_2)$)
- 해결책 (Chaining): 같은 인덱스로 매핑된 데이터들을 연결 리스트로 엮어 저장하는 방법.

#### 충돌 해결: 체이닝(Chaining) 구현
해시 테이블은 결국 배열과 연결리스트의 복합 자료구조임.

##### 핵심 구현: 해시 테이블은 배열이고, 이 배열의 각 원소(버킷, Bucket)는 연결 리스트의 헤드 포인터를 가짐.

##### 삽입 연산 (`insert(key, value)`)
1. 인덱스 계산: $I = \text{Hash}(key)$를 계산함.
2. 버킷 접근: 배열의 $I$번째 버킷에 접근함.
3. 체인 삽입: 해당 버킷의 연결 리스트 맨 앞에 `(key, value)` 노드를 삽입함. (가장 빠르므로 $O(1)$)

##### 탐색 연산 (`search(key)`)
1. 인덱스 계산: $I = \text{Hash}(key)$를 계산함.
2. 체인 탐색: $I$번째 버킷의 연결 리스트를 순차적으로 탐색하며, 원하는 `key`를 찾을 때까지 내려감.

| 연산    | 평균 시간 복잡도 | 최악 시간 복잡도                 |
| ----- | --------- | ------------------------- |
| 삽입/탐색 | $O(1)$    | $O(n)$ (모든 키가 한 버킷에 몰릴 때) |

#### 또 다른 시행착오: 개방 주소법 (Open Addressing)
체이닝 방식은 연결 리스트 때문에 메모리 낭비가 있음. 이를 해결하기 위해 등장한 것이 개방 주소법.
- 원리: 충돌 발생 시, 연결 리스트를 쓰는 대신 배열 내의 빈 공간을 찾아 저장하는 방식.
- 종류:
	- 선형 조사 (Linear Probing): 충돌 시 바로 다음 칸, 그 다음 칸...을 순차적으로 탐색함.
	- 이차 조사 (Quadratic Probing): 충돌 시 $1^2, 2^2, 3^2,...$ 칸 떨어진 곳을 탐색함.

# 구현 체크포인트
1. 복합 구조: 배열, 연결 리스트, 그리고 해시 함수의 조합으로 $O(1)$을 달성하는 원리를 이해.
2. 충돌 처리: 충돌이 불가피하며, 이를 체이닝이나 개방 주소법으로 해결해야 함을 이해.
3. 실제 적용: Python의 `dict`, Java의 `HashMap`, C++의 `std::unordered_map`이 모두 해시 테이블을 기반으로 구현되어 있음.
