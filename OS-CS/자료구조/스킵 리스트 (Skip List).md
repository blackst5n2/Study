Skip-List는 Red-Black Tree나 AVL Tree 같은 균형 트리의 강력한 대안으로, 코딩 난이도가 훨씬 낮으면서도 유사한 성능을 제공하기 때문에 고성능 메모리 기반 데이터베이스에서 널리 사용됨.

# Skip List (스킵 리스트) 구현
#### Skip List의 필요성 (RBT의 한계 극복)
- 문제: Red-Black Tree나 AVL Tree는 삽입/삭제 시 트리의 균형을 잡기 위해 **복잡한 규칙(색상 변경, 회전)** 을 적용해야 함. 이 로직은 구현이 매우 어렵고, 병렬 처리(동시에 여러 명이 데이터에 접근) 시 복잡도가 더 증가함.
- Skip List의 목표: 균형 트리의 $O(\log n)$ 탐색 성능을 유지하면서도, 구현을 단순화하고 병렬 처리에 유리하도록 만듦.

#### Skip List의 핵심 구조: 다단계 연결 리스트
Skip List는 확률적 요소가 도입된 다단계 연결 리스트 구조임.

##### 핵심 원리:
1. 기본 원리 (Level 0): 모든 데이터를 저장하는 정렬된 단일 연결 리스트가 가장 아래 레벨(Level 0)에 존재함.
2. 고속도로 건설 (Higher Levels): Level 0 위의 레벨(Level 1, Level 2, ...)에는 Level 0에 있는 노드들 중 일부만을 선별하여 연결함.
3. 확률적 연결: 새로운 노드를 삽입할 때, 이 노드가 다음 레벨로 올라갈지 여부를 **동전 던지기(Coin Flip)** 와 같은 **확률(예: 50%)** 에 기반하여 결정함.

#### 탐색 연산 (Search) 로직
Skip List의 탐색은 균형 트리의 검색과 유사하게 작동함.
1. 최상단 레벨에서 탐색을 시작함.
2. 전방 탐색: 현재 레벨에서 노드의 다음 포인터를 따라 이동하면서, 찾는 값보다 작지만 가장 가까운 노드까지만 이동함.
3. 하강: 더 이상 전방 탐색이 불가능하면, 한 레벨 아래로 내려가서 다시 전방 탐색을 시작함.
4. 이 과정을 Level 0까지 반복하면, $O(\log n)$ 시간에 원하는 노드를 찾을 수 있음.

#### 삽입 연산 (Insertion) 로직
1. Level 0에 삽입: 먼저 일반 연결 리스트처럼 Level 0에 새 노드를 삽입함.
2. 레벨 결졍 (확률): 이후, 확률적 과정을 통해 노드가 몇 번째 레벨까지 포인터를 가질지 결정함.
	- 동전을 던져 앞면이 나오면 레벨 1에 포인터를 만들고, 다시 동전을 던짐.
	- 동전 던지기에서 뒷면이 나올 때까지 계속함.
3. 포인터 연결: 결정된 레벨까지 해당 노드의 포인터를 연결함.

결과: 삽입 시 복잡한 구조 변경(Rotation) 없이, 오직 포인터를 연결만으로 $O(\log n)$의 탐색 성능을 유지하는 무작위적인 균형을 달성함.

#### Skip List의 장점과 응용
- 구현 단순성: 균형 트리(RBT)보다 구현 코드가 훨씬 짧고 쉬움.
- 병렬 처리: 각 레벨이 다른 노드를 스킵하고 있기 때문에, 여러 스레드가 동시에 다른 레벨에서 탐색/삽입을 수행하기 용이하여 동시성 제어에 유리함.
- 응용: Redis (KV 스토어), Apache Cassandra (NoSQL DB), 메모리 기반 인덱스 등 고성능 병렬 시스템의 핵심 자료구조로 사용됨.
