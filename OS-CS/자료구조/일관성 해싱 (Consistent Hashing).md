Consistent Hashing 대규모 서버 클러스터에서 서버가 추가되거나 제거될 때, 데이터의 재분배 (Rehashing)를 최소화하여 시스템의 안정성과 효율성을 유지하는 데 필수적임.

# Consistent Hashing (일관성 해싱)
#### 일반 해싱 (Modulo Hashing)의 치명적인 문제
일반 해시 테이블의 단순한 나머지 연산(`Index = Key % TableSize`)은 분산 환경에서 치명적인 문제를 일으킴.
- 문제: 서버의 개수(TableSize)가 바뀔 때, 모든 키의 위치가 바뀜.
- 예시: 서버가 4대에서 5대로 늘어마녀, `Key % 4`였던 모든 키를 `Key % 5`로 다시 계산해야 함. 이는 클러스터 전체의 캐시나 데이터를 모두 무효화하고 재분배해야 함을 의미하며, 막대한 비용이 발생함.

#### Consistent Hashing의 원리: 해시 링(Hash Ring)
Consistent Hashing은 키와 서버 모드를 같은 해시 공간인 '해시 링(Hash Ring)' 위에 배치하여 이 문제를 해결함.

##### 핵심 구현:
1. 해시 링: 모든 가능한 해시 값(0부터 $2^{32} - 1$까지)을 가진 원형 공간을 가정함.
2. 서버 배치: 각 서버(S1, S2, S3...)의 이름을 해시 함수에 넣어 계산된 값에 따라 링 위에 배치함. (예: `Hash(S1)` = 100, `Hash(S2)` = 500)
3. 데이터 배치: 각 데이터 키(K1, K2...)를 해시 함수에 넣어 링 위에 배치함. (예: `Hash(K1)` = 250)
4. 매핑 규칙: 데이터 키가 위치한 지점에서 시계 방향으로 가장 가까운 서버에 할당됨.

#### Consistent Hashing의 장점 (재분배 최소화)
- 서버 추가 (S4 추가): S4가 링의 특정 위치에 추가되면, S4의 반시계 방향에 있는 서버가 담당하던 데이터의 일부만 S4로 이전됨.
- 서버 제거 (S2 제거): S2가 링에서 제거되면, S2가 담당하던 모든 데이터는 시계 방향으로 가장 가까운 서버(예: S3)로 이전됨.

	결과: 서버 개수의 변동이 있을 때, 전체 데이터에 영향을 미치는 것이 아니라, **변동된 서버 주변의 데이터만** 재분배됨.

| 일반 해싱                        | Consistent Hashing             |
| ---------------------------- | ------------------------------ |
| 서버 변동 시, $O(N)$의 데이터 이동 (전체) | 서버 변동 시, $O(1/N)$의 데이터 이동 (일부) |

#### 시행착오와 해결: 가상 노드 (Virtual Nodes)
해시 링에 서버를 하나씩만 배치하면 서버 간의 담당 영역 크기가 불균형해질 수 있음.
- 문제: 서버 S1과 S2의 해시 값이 매우 가까우면, S2가 대부분의 데이터를 담당하게 되오 부하가 불균형해짐.
- 해결: **가상 노드 (Virtual Nodes, VNodes)** 를 사용함. 하나의 실제 서버(S1)를 링 위에 여러 개의 가상 노드(S1-A, S1-B, S1-C)로 해시하여 배치함.
- 결과: 서버가 링 위에 고르게 분산 배치되어, 데이터와 부하가 균형 있게 분산됨.
