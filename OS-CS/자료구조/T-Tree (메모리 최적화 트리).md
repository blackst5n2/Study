T-Tree는 AVL Tree나 Red-Black Tree 같은 균형 잡힌 트리(Balanced Tree)의 원리를 계승하면서, 컴퓨터의 캐시 메모리(Cache) 구조에 최적화하여 설계된 자료구조임.

# T-Tree (메모리 최적화 트리)
#### T-Tree의 필요성 (메모리 성능의 병목 현상)
- 문제: 현대의 컴퓨터는 CPU의 속도에 비해 메인 메모리(RAM)의 접근 속도가 훨씬 느림. 이 속도 차이를 줄이기 위해 CPU 내부에 **캐시 메모리(L1, L2, L3 Cache)** 가 존재함.
- 균형 트리의 한계: Red-Black Tree나 AVL Tree는 노드가 작고 메모리에 분산되어 저장되는 경향이 있음. 데이터를 찾기 위해 다음 노드로 이동할 때마다 메모리의 먼 곳을 참조하게 되면, **캐시 미스(Cache MIss)** 가 자주 발생하여 성능이 급격히 저하됨.
- T-Tree의 목표: 노드 크기를 키워 더 많은 데이터를 한 번의 캐시 접근으로 처리하여 캐시 미스율을 최소화하고 탐색 속도를 높임.
#### T-Tree의 핵심 구조: 텐서럴 노드 (T-Node)
T-Tree는 노드 안에 하나의 데이터만 저장하는 일반적인 이진 트리와 달리, 여러 개의 데이터 레코드를 연속적으로 저장함.

##### 핵심 원리:
1. T-Node: 각 노드는 여러 개의 키/값 쌍을 저장할 수 있는 배열 구조를 가짐. 노드의 크기는 보통 CPU의 캐시 라인(Cache LIne) 크기(예: 64바이트)의 배수로 설정되어 캐시 효율을 극대화함.
2. Left/Right Pointers: 각 T-Node는 두 개의 포인터(`left`, `right`)만을 가짐. 이는 이진 탐색 트리(BST)의 특징을 유지함.
3. 데이터 저장:
	- 노드 내부에 저장된 데이터는 항상 정렬된 상태로 유지됨.
	- 노드의 최소 키보다 작은 키는 왼쪽 자식으로, 최대 키보다 큰 키는 오른쪽 자식으로 분기됨.

#### T-Tree의 탐색 및 관리 로직
##### 탐색 연산 (Search)
1. 트리 탐색: 일반 BST처럼 `left` 또는 `right` 포인터를 따라 탐색함.
2. 노드 내 탐색: 원하는 T-Node에 도달하면, 노드 내부에 있는 정렬된 키/값 배열에서 **이진 탐색(Binary Search)** 을 통해 최종 데이터를 찾음.
	 성능 이득: 트리를 따라 포인터를 이동하는 횟수($O(\log n)$)를 줄이는 대신, 한 노드 내부에서 매우 빠른 이진 탐색을 수행하여 캐시 효율을 높임.

##### 삽입/삭제 및 균형 유지
- 노드 오버플로우/언더플로우: 삽입/삭제 시 노드 내부의 배열이 가득 차거나 비게 되면, B-Tree처럼 인접 노드로부터 데이터를 빌려오거나(Rebalancing), **노드를 분할(Split)** 하거나 **병합(Merge)** 하여 균형을 유지함.
- 균형 속성: T-Tree는 일반적으로 AVL Tree의 높이 균형 조건을 따르도록 설계되어, 항상 $O(\log n)$의 탐색 성능을 보장함.

#### T-Tree의 응용
- 메인 메로리 데이터베이스: T-Tree는 디스크 I/O가 아닌 메모리 접근 속도를 최적화하는 데 특화되어 있음. 대표적으로 SAP HAVA, Oracle TimesTen과 같은 고성능 인메모리 데이터베이스의 핵심 인덱스 구조로 사용됨.

