트라이는 해시 테이블이 키를 $O(1)$로 찾는 데 중점을 둔 것과 달리, 문자열이나 IP 주소처럼 긴 데이터를 접두사(Prefix) 단위로 묶어 저장함으로써 탐색 성능을 최적화한 자료구조임. 이는 자동 완성, 맞춤법 검사기, 그리고 네트워크 라우팅 테이블에서 핵심적인 역할을 함.

# 트라이 (Trie, Prefix Tree) 구현
#### 트라이의 정의 및 목표
- 정의: 키(Key)가 문자열이며, 트리의 노드들이 문자의 접두사를 공유하는 트리임. (접두사 = Prefix)
- 목표: 
	1. 탐색 가속화: 문자열의 길이에 비례하는 시간($O(L)$)만으로 탐색함, (데이터 개수 $N$에는 무관)
	2. 메모리 효율: 접두가사 같은 문자열들은 노드를 공유하므로 저장 공간을 절약함.

#### 구조 및 포인터 배열
트라이의 노드는 자식 노드를 가리키기 위해 연결 리스트나 해시 테이블 대신 고정 크기의 배열을 사용함.

##### 핵심 구현: 자식 노드를 위한 포인터 배열을 사용함. (예: 소문자 알파벳 26개에 대한 배열)
```cpp
// 트라이 노드 구조체 (알파벳 소문자 기준)
struct TrieNode {
	// 자식 노드 포인터 배열. [0]은 'a', [1]은 'b', ... [25]는 'z'
	TrieNode* children[26];
	bool isEndOfWord; // 이 노드에서 단어가 끝나는지 여부
	
	TrieNode() : isEndOfWord(false) {
		for (int i = 0; i < 25; ++i) {
			children[i] = nullptr;
		}
	}
	// 소멸자에서 자식 노드 메모리 해제 로직 (메모리 관리 필요)
};
```

#### 삽입 및 탐색 연산
트라이의 모든 연산은 문자열의 각 문자를 따라 노드 배열을 순차적으로 이동하는 방식으로 이루어짐.

##### 삽입 연산 (`insert(word)`)
1. 루트 노드에서 시작함.
2. 입력된 단어의 각 문자에 대해 반복함.
3. 현재 노드의 `children` 배열에서 해당 문자 인덱스(예: 'a'는 0)를 확인함.
4. 노드가 없으면: 새 노드를 생성하여 연결하고 현재 노드를 새 노드로 이동시킴.
5. 노드가 있으면: 현재 노드를 기준 노드로 이동시킴.
6. 단어의 마지막 문자에서 `isEndOfword` 플래그를 `true`로 설정함.

##### 탐색 연산 (`search(word)`)
1. 삽입과 동일하게 루트 노드에서 시작하여 문자를 따라 이동함.
2. 단어의 끝에 도달했을 때, 마지막 노드가 존재하고 **`isEndOfWord`가 `true`** 인지 확인함.
	- 노드가 없으면: 단어가 존재하지 않음 (False)
	- 노드가 있지만 `isEndOfWord`가 False이면: 해당 접두사는 있지만 단어는 아님 (False)

#### 트라이의 응용: Radix Tree와 네트워크 라우팅
- Radix Tree (기수 트리): 트라이에 메모리 낭비를 주링기 위해 등장한 개선된 형태. 문자들이 한 방향으로만 길계 연결된 가지(예:c-a-r-d)를 하나의 노드로 합쳐서 관리함.
- 네트워크 라우팅: IP 주소는 32비트 또는 128비트의 이진 문자열로 볼 수 있음. 라우터는 들어온 IP 패킷의 주소를 트라이(혹인 Radix Tree)에 검색하여 가장 긴 접두사가 일치하는 경로로 패킷을 전송함.

# 구현 체크포인트
1. 문자-인덱스 변환: 문자를 배열 인덱스로 정확히 변환하는 로직(`char c`를 `c - 'a'`로 변환)을 이해함.
2. 탐색 시간 복잡도: $O(L)$ (문자열 길이)의 속도가 데이터의 총 개수 $N$에 관계없이 빠름을 이해함.
3. 메모리 관리: 트라이 구조는 노드가 많아질수록 메모리 소모가 크기 때문에, 소멸 시 재귀적으로 모든 자식 노드의 메모리를 해제해야 함.
