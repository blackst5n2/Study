대규모 공간이나 복잡한 문자열 데이터를 다루는 **그래픽스(게임 맵)**  와 **네트워크(라우팅)** 분야의 성능을 최적화하는 데 특화된 기술.

# 쿼드 트리 (Quadtree) 구현
쿼드 트리(Quadtree)는 2D 공간을 효율적으로 분할하고 검색하기 위해 사용하는 트리 구조. 그래픽스, 물리 엔진, 지리정보시스템(GIS)에서 충돌 감지, 시야 절단(Culling), 범위 검색 등을 가속하는 데 핵심적인 역할을 함.

#### 쿼드 트리의 정의 및 목표
- 목표: 넓은 2차원 공간에 흩어져 있는 수많은 객체들 중에서 특정 영역 내의 객체만을 빠르게 찾기 위함.
- 원리: 각 노드가 나타내는 2차원 영역을 정확히 4개의 같은 크기 자식 영역(북서, 북동, 남서, 남동)으로 재귀적으로 분할함.

#### 구조 및 재귀적 분할 (Spatial Partitioning)
쿼드 트리의 노드는 트리의 기본 노드 정의에 더해, 영역 정보를 추가로 가짐.

##### 핵심 구현: 노드는 `Boundary` (사각형 영역의 위치와 크기)와 4개의 `Child` 포인터를 가짐.
```cpp
struct Boundary {
	float x, y; // 영역의 중심 좌표
	float width, height; // 영역의 크기
};

struct QuadNode {
	Boundary boundary;
	// 이 노드가 담당하는 영역에 포함된 객체 리스트 (또는 포인터)
	std::vector<Object*> objects;
	
	// 4개의 자식 노드: 0: NW, 1: NE, 2: SW, 3: SE
	QuadNode* children[4];
	
	QuadNode(Boundary b) : boundary(b) {
		for (int i = 0; i < 4; ++i) children[i] = nullptr;
	}
};
```

#### 삽입 및 검색 로직 (재귀)
##### 삽입 연산 (`insert(object)`)
1. 재귀 조건: 현재 노드에 들어온 객체 수가 **임계치(Threshold)** 를 넘고, 노드가 아직 분할되지 않았다면, **현재 노드를 4개의 자식 노드로 분할(Subdivide)** 함.
2. 객체 분산: 현재 노드의 객체들과 새로 들어온 객체를 4개의 자식 노드 중 해당하는 영역으로 재귀적으로 이동/삽입시킴.
3. 기저 조건: 노드에 들어온 객체 수가 임계치 이하가 되거나, 더 이상 분할할 수 없을 때, 객체를 현재 노드의 `objects` 리스트에 저장함.

##### 범위 검색 (`queryRange(range)`)
1. 영역 확인: 검색 범위 (`range`)가 현재 노드의 영역과 겹치는지(Intersects) 확인함. 겹치지 않으면 탐색 중단 (가지치기, Culling).
2. 재귀: 겹친다면, 현재 노드의 `objects` 리스트를 확인하고, 4개의 자식 노드에 대해 재귀적으로 탐색을 이어감.

#### 쿼드 트리의 진화: Octree와 k-d Tree
- Octree (옥트리): 쿼드 트리의 3차원 버전. 공간을 4등분이 아닌 8등분하여 3D 그래픽스 엔진에서 사용됨.
- k-d Tree: 쿼드 트리가 항상 공간을 4등분하는 것과 달리, 데이터 분포에 따라 축(Axis)을 번갈아 가며(X축 분할 -> Y축 분할) 공간을 2등분하며 분할 효율을 높인 트리.

# 구현 체크포인트
1. 경계 계산: 영역(`Boundary`)을 4개의 서브 영역으로 정확히 나누는 수학적 계산 로직이 필수임.
2. 겹침 판정: 객체/검색 범위와 노드 경계 간의 충돌(Intersection) 판정 공식을 이해해야 함.
3. 재귀 활용: 분할(`Subdivide`)과 검색(`queryRange`) 연산 모두 재귀를 통해 효율적으로 구현됨.
