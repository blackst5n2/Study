트리나 연결 리스트를 모두 포함하는 가장 일반적인 자료구조.
노드 간의 관계가 계층적이지 않고 복잡한 네트워크 형태일 때 사용되며, 지도 경로, 소셜 네트워크, 물리 엔진의 연결 구조 등 복잡한 시스템을 모델링하는 데 필수적.

# 그래프 (Graph) 구조 구현
#### 그래프의 정의 및 구성 요소
- 정의: 노드(정점)와 이들을 연결하는 간선(Edge)의 집합
$$G = (V, E)$$
- 여기서 V는 정점(Vertex, Node)의 집합, E는 간선(Edge)의 집함.
- 간선의 속성:
	- 방향성 (Directed vs. Undirected): 간선에 방향이 있는지 여부 (예: 일방통행 vs. 양방통행).
	- 가중치 (Weighted vs. Unweighted): 간선에 비용(Cost, 거리, 시간 등)이 부여되었는지 여부.

#### 구현 방식: 인접 리스트 (Adjacency List)
그래프를 메모리에 구현하는 방식은 크게 **인접 행렬 (Adjacency Matrix)** 과 **인접 리스트 (Adjacency List)** 가 있음. 현대의 대규모 그래프(Sparse Graph, 간선이 적은 그래프)에서는 인접 리스트가 훨씬 효율적임.

| 구현 방식  | 구조               | 공간 복잡도     | 장점                        |
| ------ | ---------------- | ---------- | ------------------------- |
| 인접 행렬  | 2차원 배열 $A[V][V]$ | $O(V^2)$   | 두 노드 연결 여부 $O(1)$에 확인 가능. |
| 인접 리스트 | 배열 + 연결 리스트      | $O(V + E)$ | 메모리 효율적 (특히 간선이 적을 때).    |

##### 핵심 구현 (인접 리스트): 노드의 개수(V)만큼의 배열(또는 벡터)을 만들고, 각 배열 요소에 해당 노드와 연결된 다른 노드들을 연결 리스트로 저장함.
```cpp
// C++ 인접 리스트 구조 (가중치가 없는 방향 그래프 예시)
// V: 정점의 개수 (예: 5)
std::vector<int> adj[V];

// 노드 0에서 1로 가는 간선 추가
adj[0].push_back(1);
// 노드 0에서 2로 가는 간선 추가
adj[0].push_back(2);

// 노드 0과 연결된 모든 노드를 순회: 0(차수)
for (int neighbor : adj[0]) {
	// ...
}
```

#### 그래프 탐색 알고리즘 (Traversal)
복잡한 그래프 구조 내에서 원하는 노드를 찾거나 모든 노드를 방문하기 위한 기본 연산임.
- BFS (Breadth-First Search, 너비 우선 탐색): 큐(Queue) 자료구조를 사용하여 루트에서 가까운 노드들을 먼저 탐색함. (최단 거리 탐색에 유용)
- DFS (Depth-First Search, 깊이 우선 탐색): 스택(Stack) 자료구조 또는 재귀를 사용하여 한 방향으로 끝까지 탐색한 후 되돌아옴. (경로 확인에 유용)

# 구현 체크포인트
1. 그래프 모델링: 지도, 네트워크, 게임 맵 등을 인접 리스트로 모델링할 수 있는지 확인.
2. 탐색 기반: BFS와 DFS를 큐/스택을 황용하여 구현할 수 있는지 확인.
3. A* 통합: **힙 (Priority Queue)** 과 **해시 테이블 (Map)** 을 결합하여 최적 경로 탐색 알고리즘을 구현.
