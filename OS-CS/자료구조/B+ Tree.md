#### B+Tree의 필요성 (B-Tree의 한계 극복)
- B-Tree의 한계: B-Tree는 내부 노드에 키와 데이터를 모두 저장함. 이 때문에 노드 하나에 저장할 수 있는 키의 개수가 줄어들고, 트리의 높이가 높아져 **디스크 I/O 횟수가 증가** 하는 문제가 있었음.
- B+ Tree의 목표: 디스크 I/O를 최소화하고, **범위 검색(Range Query)** 의 속도를 극대화함.

#### B+ Tree의 핵심 구조
B+Tree는 B-Tree의 규칙을 따르지만, 구조적으로 두 가지 중요한 특징을 가짐.
1. 데이터는 리프 노드에만 저장: 내부 노드(Internal Node)에는 단순히 **다음 경로를 안내하는 키 (Index Key)** 만 저장함. 실제 데이터(Value)는 오직 **리프 노드(Leaf Node)** 에만 저장됨.
2. 리프 노드의 연결: 모든 리프 노드들이 **연결 리스트(Linked List)** 로 순서대로 연결되어 있음.

#### B+ Tree 연산의 특징

##### 탐색 연산 (Search)
- 원리: 내부 노드는 경로 안내 역할만 하므로, 탐색은 반드시 리프 노드까지 내려가서 끝남.
- 성능: 키만 저장하여 내부 노드의 밀도를 높였기 때문에, 트리의 높이가 낮아져 **디스크에서 데이터를 읽는 횟수(I/O)** 가 최소화됨.

##### 범위 검색 연산 (Range Query)
- 원리: 예를 들어, "ID 100부터 ID 200까지의 모든 사용자"를 찾을 때,
	1. 먼저 트리를 따라 ID 100이 있는 리프 노드를 찾음.
	2. 리프 노드에 도달하면, 옆으로 연결된 연결 리스트를 따라 ID 200에 도달할 때까지 순차저긍로 이동하여 데이터를 읽음.
- 장점: 루트부터 매번 검색할 필요 없이, 한 번의 검색 후 디스크에서 **연속적인 순차 읽기 (Sequential Read)** 만 수행하므로 압도적으로 빠름.

#### 구현 난이도 및 요구 지식
- 요구 지식: B-Tree의 규칙(노드가 가질 수 있는 키의 최소/최대 게수) 이해, 노드 분할(Splitting) 및 노드 병합(Merging) 로직 구현.
