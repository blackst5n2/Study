BST (이진 탐색 트리)의 치명적인 한계($O(n)$ 성능 저하)를 극복하기 위해 수학적이고 논리적인 규칙을 강제한 결과물. 현대 데이터베이스, 파일 시스템, 그리고 OS 스케줄러(리눅스의 CFS)에서 필수적으로 사용되는 핵심 구조.

# 균형 잡힌 트리 (Red-Black Tree, RBT) 구현
#### RBT의 필요성 및 목표 (진화 배경)
- 문제: 일반 BST는 데이터 삽입 순서에 따라 트리가 한쪽으로 편향되어 성능이 $O(\log n)$에서 $O(n)$으로 떨어지는 최악의 경우가 발생함.
- 해결: RBT는 삽입/삭제 연산 시 노드의 색깔(Red 또는 Black)과 몇 가지 규칙을 사용하여 트리의 높이를 항상 $\log n$ 수준으로 강제함.
- 결과: 삽입, 삭제, 탐색 연산이 최악의 경우에도 $O(\log n)$ 성능을 보장함.

#### RBT의 규칙 및 구조
RBT는 다섯 가지 핵심 규칙을 따름. 이 규칙들이 트리의 균형을 유지하는 원리임.
1. 모든 노드는 Red 또는 Black 중 하나의 색을 가진다.
2. 루트 노드는 Black이다.
3. 모든 잎 노드 (Leaf Node, NIL 노드)는 Black이다.
4. Red 노드의 자식은 항상 Black이다. (Red가 연속될 수 없다.)
5. 루트에서 잎까지의 모든 경로에서 Black 노드의 수는 같다. (이것이 트리의 균형을 유지하는 핵심 규칙.)

#### 핵심 연산: 트리 회전 (Rotation)
RBT가 균형을 잡는 유일한 물리적 동작. 삽입/삭제 후 규칙이 위반되면, **노드의 색을 바꾸거나 (Recoloring) 트리 회전 (Rotation)** 을 통해 구조를 변경함.
- 회전(Rotation): 두 노드의 부모-자식 관계를 바꾸어 높이 균형을 잡는 연산임. (예: 왼쪽 회전, 오른쪽 회전)

##### RBT 삽입 및 균형 잡기 로직 (핵심)
1. 일반 BST처럼 삽입함. 새 노드는 항상 Red로 칠함.
2. 규칙 위반 검사: 만약 부모 노드가 Red라면 (규칙 4 위반: Red 노드의 자식은 Black이어야 함), 문제가 발생함.
3. 균형 복구 (재조정):
	- Recoloring: 삼촌 노드(Uncle, 부모의 형제)가 Red일 경우, 부모, 삼촌, 할아버지의 색을 변경함.
	- Rotation: 삼촌 노드가 Black이고 특정 불균형 패턴일 경우, 왼쪽/오른쪽 회전(Rotation)을 수행하여 구조를 바꿈.

#### RBT의 실제 적용
- Linux 커널: **CFS(Completely Fair Scheduler)** 는 Red-Black Tree를 사용하여 프로세스의 실행 시간(vruntime)을 키로 관리하며, 가장 공정한 프로세스를 $O(\log n)$으로 찾아냄.
- 표준 라이브러리: C++의 `std::map`, `std::set`과 Java의 `TreeMap`, `TreeSet`은 RBT를 기반으로 구현되어 있음.

# 구현 체크포인트
RBT 구현은 BST보다 난이도가 훨씬 높지만, 완성하면 자료구조에 대한 이해도가 비약적으로 상승함.
1. BST 마스터리: BST의 재귀적 삽입/탐색 연산을 확실하게 이해하고 있어야 함.
2. 회전 로직: `RotateLeft`와 `RotateRight` 함수를 오류 없이 구현하는 것이 가장 큰 도전.
3. 규칙 기반 사고: 삽입 후 5가지 규칙 중 어떤 것이 위반되었는지 판단하고, 이에 맞는 정확한 복구 (Recoloring 또는 Rotation) 동작을 적용하는 논리력을 키움.
