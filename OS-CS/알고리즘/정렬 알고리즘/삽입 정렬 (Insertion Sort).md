# 삽입 정렬 (Insertion Sort)의 원리
1. 정렬된 부분 설정: 배열의 첫 번째 원소는 이미 정렬된 것으로 간주하고 시작함. (크기 1의 정렬된 부분 배열)
2. 새 원소 선택: 두 번째 원소(`i = 1`)부터 시작하여 배열 끝까지 순회하며 '새로 삽입할 원소(Key)'로 선택함.
3. 위치 탐색 및 이동: Key가 정렬된 부분 배열에 들어갈 올바른 위치를 찾음. Key보다 **큰 원소들** 은 Key가 들어갈 자리를 만들기 위해 한 칸씩 **뒤로** 밀려남.
4. 삽입: 자리를 찾으면 Key를 삽입함.
5. 반복: 다음 원소를 Key로 선택하고 2~4단계를 반복함.

# 삽입 정렬의 특징과 효율성

| 구분              | 특징                                                            |
| --------------- | ------------------------------------------------------------- |
| 시간 복잡도 (최선)     | $O(N)$ (이미 정렬된 경우)                                            |
| 시간 복잡도 (평균/최악)  | $O(N^2)$ (역순 정렬된 경우)                                          |
| 공간 복잡도          | $O(1)$ (추가 메모리 거의 없음)                                         |
| 안정성 (Stability) | 안정 정렬 (Stable Sort: O)                                        |
| 장점              | 데이터가 **거의 정렬되어 있을 때** 매우 빠름. 정렬 알고리즘 중 가장 저은 수의 비교를 수행할 수 있음. |
| 단점              | 대규모 무작위 데이터에서는 $O(N^2)$로 느림.                                  |

#### 시간 복잡도 분석
- 최악의 경우 ($O(N^2)$): 배열이 완전히 역순으로 정렬되어 있을 때, 각 원소를 삽입할 때마다 정렬된 부분 전체(i-1개)를 비교하고 이동시켜 하므로 총 $O(N^2)$가 됨.
- 최선의 경우 ($O(N)$): 배열이 이미 정렬되어 있을 때, $i$번째 우너소(`key`)를 첫 번째 원소(`arr[j]`)와 비교하자마자 `key`보다 크다는 조건(`arr[j] > key`)이 거짓이 되므로 `while` 루프가 즉시 종료됨. 이경우 비교 횟수가 $N$에 비례하여 $O(N)$이 됨.
