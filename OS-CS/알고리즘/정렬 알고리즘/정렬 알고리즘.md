# 느린 정렬 (Slow Sorts) - $O(N^2)$
데이터 개수 $N$이 적을 때나, 알고리즘의 개념을 이해하는 데 유용하지만, $N$이 커지면 성능이 급격히 저하됨.

| 알고리즘                   | 설명                                                        | 최악 시간 복잡도 | 공간 복잡도 | 특징                                        |
| ---------------------- | --------------------------------------------------------- | --------- | ------ | ----------------------------------------- |
| 선택 정렬 (Selection Sort) | 배열 전체를 훑어 가장 작은 값을 찾아 맨 아 원소와 교환하는 과정을 반복함.               | $O(N^2)$  | $O(1)$ | 비교 횟수는 많지만, 교환횟수가 가장 적음.                  |
| 버블 정렬 (Bubble Sort)    | 인접한 두 원소를 비교하여 정렬 순서가 아니면 교환함. 큰 원소가 마치 거품처럼 배열의 끝으로 이동함. | $O(N^2)$  | $O(1)$ | 구현이 매우 쉽고, **이미 정렬된 경우 $O(N)$ 으로 빠를 수 있음. |
| 삽입 정렬 (Insertion Sort) | 두 번째 왼소부터 시작하여 그 앞에 있는 '정렬된' 부분 배열의 적절한 위치에 삽입함.          | $O(N^2)$  | $O(1)$ | 거의 정렬된 데이터에 대해 **$O(N)$** 으로 매우 빠름.       |

# 빠른 정렬 (Fast Sorts) - $O(N\log N)$
대부분의 실무 환경에서 가장 많이 사용되며, 대규모 데이터를 효율적으로 정렬할 수 있음

| 알고리즘               | 설명                                                                            | 최악 시간 복잡도     | 공간 복잡도      | 특징                                                       |
| ------------------ | ----------------------------------------------------------------------------- | ------------- | ----------- | -------------------------------------------------------- |
| 병합 정렬 (Merge Sort) | 분할 정복 방식. 배열을 절반으로 계속 나누고, 정렬된 부분 배열들을 **결합(Merge)** 하면서 정렬함.                 | $O(N\log N)$  | $O(N)$      | 항상 $O(N \log N)$을 보장하며, 안정 정렬(Stable Sort)임. (추가 메모리 필요) |
| 퀵 정렬 (Quick Sort)  | 분할 정복 방식. 배열에서 **피벗(Pivot)** 을 선택하고, 피벗을 기준으로 작은 값과 큰 값으로 나누어(Partition) 정렬함. | $O(N^2)$      | $O(\log N)$ | 평균적으로 가장 빠릅니다. (하지만 최악의 경우 $O(N^2)$이 될 수 있음.             |
| 힙 정렬 (Heap Sort)   | 힙(Heap) 자료구조를 이용하여 정렬함. 가장 큰/작은 원소를 먼저 추출하여 정렬함.                              | $O(N \log N)$ | $O(1)$      | 추가 메모리 없이 $O(N \log N)$을 보장하는 제자리 정렬(In-place Sort)임.    |

# 특수 정렬 (Special Sorts) - 비교 기반이 아닌 정렬
데이터의 특정 조건을 만족할 경우, 비교 기반 정렬($O(N \log N)$이 한계)보다 더 빠르게 동작할 수 있음.

| 알고리즘                  | 설명                                                | 시간 복잡도               | 공간 복잡도     | 특징                                                  |
| --------------------- | ------------------------------------------------- | -------------------- | ---------- | --------------------------------------------------- |
| 계수 정렬 (Counting Sort) | 데이터의 최대/최소 범위를 알 때, 각 숫자의 **개수(Count)** 를 세어 정렬함. | $O(N + K)$           | $O(N + K)$ | $K$는 데이터의 최댓값. 정수 데이터에 한정되며, **범위 $K$가 작을 때** 효율적임. |
| 기수 정렬 (Radix Sort)    | 자릿수(Radix)별로 낮은 자리부터 정렬을 반복하여 최종적으로 전체를 정렬함.      | $O(d \cdot (N + b))$ | $O(N + b)$ | d는 자릿수, b는 기수(보통 10). 정수 데이터에 적합하며, 자릿수가 작을 때 효율적임. |

# C++에서의 정렬 (std::sort)
C++에서 가장 추천되는 방법은 **표준 라이브러리** 를 사용하는 것임.

`std::sort`는 내부적으로 **인트로소트(Introsort)** 라는 알고리즘을 사용함. 인트로소트는 **퀵 정렬** 을 기반으로 하지만, 퀵 정렬이 최악의 경우 $O(N^2)$로 성능이 저하되는 것을 방지하기 위해 재귀 깊이가 일정 수준 이상 깊어지면 **힙 정렬** 로 전환하는 하이브리드(Hybrid) 방식임.
- 시간 복잡도: 평군 $O(N \log N)$. 최악 $O(N \log N)$
- 사용 예시 (C++):

	```c
	#include <algorithm> // std::sort를 위해 필요
	#include <vector>
	
	// 오름차순 정렬 (기본)
	std::vector<int> data = {5, 2, 8, 1, 9};
	std::sort(data.begin(), data.end());
	
	// 내림차순 정렬
	std::sort(data.begin(), data.end(), std::gerater<int>());
	```

