1. 인접 원소 비교: 배열의 첫 번째 원소부터 시작하여 인접한 두 원소를 비교함.
2. 교환(Swap): 정렬 순서에 맞지 않으면 두 원소의 위치를 서로 교환함.
3. 최댓값 이동: 이 과정을 배열 끝까지 반복하면, **가장 큰 원소** 가 마치 거품이 떠오르듯 배열의 **가장 오른쪽(끝)** 으로 이동하여 자리를 잡음.
4. 반복: 다음 순회에서는 이미 정렬된 마지막 원소를 제외하고, 남은 배열에 대해 1~3단계를 반복함.

# 버블 정렬의 특징과 효율성
| 구분              | 특징                                   |
| --------------- | ------------------------------------ |
| 시간 복잡도 (최선)     | $O(N)$ (이미 정렬된 경우, 최적화 적용 시)         |
| 시간 복잡도 (평균/최악)  | $O(N^2)$                             |
| 공간 복잡도          | $O(1)$ (추가 메모리 거의 없음)                |
| 안정성 (Stability) | 안정 정렬 (Stable Sort: O)               |
| 장점              | 구현이 가장 간단함. 안정 정렬이므로 동일한 값의 순서를 보존함. |
| 단점              | 대규모 무작위 데이터에서 가장 비효율적인 정렬 중 하나임.     |

#### 시간 복잡도($O(N^2)$) 분석
- 평균/최악의 경우: 삽입 정렬, 선택 정렬과 마찬가지로 총 $\approx O(N^2)$ 번의 비교 연산이 필요함.
- 최선의 경우($O(N)$): 배열이 이미 정렬되어 있다면, 바깥쪽 루피(`i`)가 한 번만 실행되는 동안 안쪽 루프(`j`)가 $N - 1$번 비교를 수행한 후 `swapped` 플래그가 `false`여서 `break`로 종료됨. 따라서 $O(N)$의 효율을 가짐.
