평균적으로 가장 빠른 정렬 알고리즘.
# 퀵 정렬 (Quick Sort)의 원리
퀵 정렬 역시 **분할 정복(Divide and Conquer)** 방식을 사용하지만, 병합 정렬과 달리 **분할(Partition)** 단계에서 정렬을 수행하는 것이 특징임.

#### 핵심: 피벗(Pivot)과 분할(Partition)
1. 피벗 선택: 배열 내에서 기주이 될 원소인 **피벗(Pivot)** 을 하나 선택함. (보통 배열의 첫 원소, 중앙 원소, 또는 마지막 원소를 선택)
2. 분할 (Partitioning): 배열 전체를 순회하며 피벗보다 **작은 원소** 는 피벗의 **왼쪽** 으로, **큰 원소** 는 피벗의 **오른쪽** 으로 재배치함.
3. 피벗 확정: 이 과정을 거치면 피벗은 자신의 최종 정렬 위치를 찾게 되며, 더 이상 이동하지 않음.
4. 재귀: 피벗의 왼쪽 부분 배열과 오른쪽 부분 배열에 대해 다시 1~3단계를 재귀적으로 반복하여 정렬함.

# 퀵 정렬의 특징과 효율성

| 구분              | 특징                                                                                    |
| --------------- | ------------------------------------------------------------------------------------- |
| 시간 복잡도(평균)      | $O(N \log N)$ (대부분의 상황)                                                               |
| 시간 복잡도 (최악)     | $O(N^2)$ (피벗이 항상 최솟값/최댓값으로 선택될 때)                                                     |
| 공간 복잡도          | $O(\log N)$ (재귀 호출 스택의 깊이)                                                            |
| 안정성 (Stability) | 불안정 정렬 (Stable Sort: X)                                                               |
| 장점              | **$O(N \log N)$** 알고리즘 중 **가장 빠른 상수 시간** 을 가짐. 제자리 정렬(In-place Sort) 방식으로 추가 메모리가 적음. |
| 단점              | 최악의 경우 $O(N^2)$로 성능이 급격히 저하됨. 피벗 선택 전력이 중요함.                                          |

#### 최악의 경우($O(N^2)$) 발생 조건
만약 배열이 이미 정렬되어 있거나 역순으로 정렬되어 있는데, 매번 피벗을 배열의 **가장 작은 원소** 또는 **가장 큰 원소** 로 선택하면 퀵 정렬의 효율은 $O(N^2)$가 됨.

이를 방지하기 위해 **랜덤 피벗 선택** 이나, **중앙값 피벗 선택(Median-of-three)** 같은 전력을 사용하여 최악의 경우를 회피하는 것이 실전에서는 중요함.

# 중앙 값 피벗 선택 (Median-of-Three) 원리
퀵 정렬의 최악의 경우($O(N^2)$)는 피벗이 항상 정렬된 배열의 최솟값 또는 최댓값으로 선택될 때 발생함. 중앙값 피벗 선택은 이 최악의 상황을 피하고 피벗이 중앙값에 가까워지도록 유도하는 간단하지만 효과적인 휴리스틱(Heuristic)임.

이 방법은 다음과 같은 세 가지 원소 중에서 **중앙값(Median)** 을 피벗으로 선택함.
1. 배열의 시작(First) 원소
2. 배열의 중간(Middle) 원소
3. 배열의 끝(Last) 원소

#### 핵심 아이디어
세 원소의 중앙값은 해당 세 원소 중 두 번째로 큰 값(혹은 두 번째로 작은 값)을 의미함. 이 값을 피벗으로 사용하면, 피벗이 극단적인 값(최소 또는 최대)이 될 확률이 줄어들어 배열이 비교적 균등하게 분할될 가능성이 높아짐.

#### 단계 1: 세 원소의 정렬 (Swap & Sort)
`partition` 함수를 호춣하기 전에, 배열의 시작(`start`), 중간(`mid`), 끝(`end`) 세 인덱스에 있는 원소를 비교하여 **중앙값** 을 찾고, 그 중앙값을 **피벗의 위치(보통 `end` 인덱스)** 로 옮겨 놓음.

# 중앙값 피벗 선택의 효과
- 최악의 경우 회피: 배열이 정렬되어 있거나 역순으로 되어 있을 때도, 세 원소 중 중앙값을 선택하므로 피벗이 극단적인 최솟값/최댓값으로 선택될 확률이 크게 줄어듦.
- 성능 향상: 실제 데이터에서는 랜덤 피벗만큼 좋은 성능을 보이면서도, 랜덤 피벗처럼 난수 생성에 필요한 오버헤드가 없음.
