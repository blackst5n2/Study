# 안정 정렬(Stable Sorting)
> 정렬을 수행하기 전, **같은 키 값(key value)을 가진 두 원소** 가 배열 내에 있었다면, **정렬 후에도 그 두 원소의 상대적인 순서가 바뀌지 않고 그대로 유지** 되는 정렬임.

#### 예시를 통한 이해
키(Key)와 추가 정보(Sub-key)를 가진 데이터가 있다고 가정.

| 순서  | 키 값 | Sub-key    |
| --- | --- | ---------- |
| 1   | 5   | (파랑) $5_B$ |
| 2   | 5   | (빨강) $5_R$ |
| 3   | 3   | (녹색) $3_G$ |

##### 안정 정렬 (Stable Sort):
정렬 후 $5_B$가 $5_A$보다 먼저 나타남 (원래 순서 유지).

| 순서  | 키 값 | Sub-key    |
| --- | --- | ---------- |
| 1   | 3   | (녹색) $3_G$ |
| 2   | 5   | (파랑) $5_B$ |
| 3   | 5   | (빨강) $5_R$ |
##### 불안정 정렬 (Unstable Sort):
정렬 후 $5_R$와 $5_B$의 순서가 바뀔 수 있음.

| 순서  | 키 값 | Sub-key    |
| --- | --- | ---------- |
| 1   | 3   | (녹색) $3_G$ |
| 2   | 5   | (파랑) $5_R$ |
| 3   | 5   | (빨강) $5_B$ |

##### 힙 정렬이 블안정한 이유
힙 정렬은 대표적인 **불안정 정렬** 알고리즘임. 그 이유는 **heapify(재힙 구성)** 과정과 **최대값 추출(스왑)** 과정에서 발생함.

힙 정렬은 가장 큰 값(루트 노드)을 배열의 맨 끝으로 보내기 위해 **배열 내에서 멀리 떨어진 두 원소** 를 무작위로 스왑함. ($\text{A}[0]$과 $\text{A}[i]$). 이 과정에서 중간에 위치한 같은 값들의 상대적인 순서를 고려하지 않기 때문에 안정성이 깨지게 됨.

##### 안정 정렬의 대표적인 예
- 병합 정렬(Merge Sort): 새로운 보조 배열을 사용하여 합병(Merge) 시 순서를 보장함.
- 삽입 정렬(Insertion Sort): 원소를 삽입할 때 같은 값을 만나면 항상 뒤쪽에 배치하여 순서를 보장함.

##### 불안정 정렬의 대표적인 예
- 퀵 정렬(Quick Sort)
- 힙 정렬(Heap Sort)
- 선택 정렬(Selection Sort)
