힙 정렬은 병합 정렬(Merge Sort)과 마찬가지로 **최악의 경우에도 $O(n \log n)$의 시간 복잡도를 보장** 하는 안정적인 비교 정렬 알고리즘임.

힙 정렬은 크게 두 단계로 구성됨

#### 1. 최대 힙 구성 (Heapify)
주어진 배열을 **최대 힙 (Max Heap)** 구조로 만듦. 최대 힙이란, 부모 노드의 값이 항상 자식 노드의 값보다 크거나 같은 완전 이진 트리 구조임.
- 이 단계의 목표는 배열의 가장 큰 값이 항상 **루트 노드(배열의 첫 번째 원소, $\text{A}[0]$)** 에 위치하도록 만드는 것.
- 이는 배열의 **중간 지점부터 시작** 하여(마지막 부모 노드부터 시작) 아래에서 위로, 오른쪽에서 왼쪽으로 올라가면서 `heapify()` 함수를 호출하여 수행됨.
- 시간 복잡도: $O(n)$
	- (이진 트리의 높이 합은 $O(n)$이기 때문에 힙을 처음 구성하는 과정은 $O(n \log n)$이 아닌 $O(n)$임.)

#### 정렬 및 재힙 구성 (Sorting)
루트 노드에 있는 가장 큰 원소를 배열의 맨 끝으로 보내고, 남은 원소들을 다시 힙 구조로 재구성하는 과정을 반복함.
1. 최대값 추출: 루트 노드($\text{A}[0]$, 현재 가장 큰 값)와 배열의 **마지막 원소($\text{A}[i]$)를 스왑함.
2. 힙 크기 감소: 스왑된 최대값($\text{A}[i]$)는 이미 정렬이 완료된 상태이므로, 힙의 크기를 1 감소시킴.
3. 재힙 구성: 새로운 루트($\text{A}[0]$)를 대상으로 다시 `heapify`를 호출하여 힙 속성을 복구함.
4. 이 과정을 힙의 크기가 1이 될 때까지 반복함.
- 시간 복잡도: $O(n \log n)$
	- (힙에서 원소를 하나를 추출할 때마다 $\log n$의 시간이 걸리고, 이 과정을 $n - 1$번 반복하기 때문임.)

# 힙 정렬의 핵심: `heapify` 함수
힙 정렬의 핵심 로직은 트리의 특정 노드를 기준으로 힙 속성을 복구하는 `heapify` 함수에 있음.

#### `heapify` 로직
노드의 인덱스 $i$를 기준으로 할 때:
1. 자식 노드 인덱스 계산:
	- 왼쪽 자식: $2i + 1$
	- 오른쪽 자식: $2i + 2$
2. 최대값 찾기: 현재 노드($i$), 왼쪽 자식($2i + 1$), 오른쪽 자식($2i + 2$) 중 가장 큰 값의 인덱스를 찾음.
3. 스왑 및 재귀:
	- 가장 큰 값이 현재 노드 $i$가 아니라 자식 노드(예: $k$)에 있다면, $A[i]$와 $A[k$를 스왑함.
	- 스왑 후, 최대값이 내려간 자식 노드($k$)를 새로운 루트로 간주하고 $\text{heapify}$를 재귀적으로 호출하여 아래쪽 서브 트리에서도 힙 속성이 유지되도록 함.

# 추가 정보
#### 힙의 1차원 배열 표현: 이진 트리의 인덱스 규칙
힙은 논리적으로는 **완전 이진 트리(Complete Binary Tree)** 구조임. 하지만 메모리 효율성을 위해 **별도의 포인터나 연결 리스트를 사용하지 않고** 1차원 배열로 구현하며, 이는 **완전 이진 트리** 의 특성 덕분에 가능함.

##### 1차원 배열과 트리의 인덱스 관계 (0-based Indexing 기준)
힙을 0번 인덱스부터 시작하는 배열 $\text{A}$로 저장할 경우, 임으의 노드 $i$의 위치는 다음 규칙을 따름.
1. 부모 노드 (Parent): $Parent(i) = \lfloor(i - 1)/2\rfloor$
	- (예: 노드 5의 부모는 $\lfloor(5 - 1)/2\rfloor = 2$번 인덱스)
2. 왼쪽 자식 노드 (Left Child): $Left(i) = 2i + 1$
3. 오른쪽 자식 노드 (Right Child): $Right(i) = 2i + 2$

이러한 인덱스 규칙을 사용하면, 트리 구조를 탐색하는 데 필요한 $O(1)$ 시간의 간단한 산술 연산만으로 부모/자식 노드를 찾을 수 있음.

##### 추가로 알면 좋은 점: 최대 힙 vs 최소 힙
- 최대 힙 (Max Heap): 부모 노드가 자식 노드보다 항상 크거나 같음. (힙 정렬에 사용됨, 가장 큰 값이 루트에 옴)
- 최소 힙 (Min Heap): 부모 노드가 자식 노드보다 항상 작거나 같음. (우선순위 큐 구현에 주로 사용됨, 가장 작은 값이 루트에 옴)

힙 정렬은 오름차순 정렬을 위해 최대 힙을 사용함. 최대 힙의 루트(배열의 $\text{A}[0]$)를 배열의 끝부터 차례로 채워 넣으면 자연스럽게 오름차순으로 정렬됨.

#### 특정 상황에서의 힙 정렬의 장단점
힙 정렬은 퀵 정렬이나 병합 정렬과 비교했을 때 뚜렷한 장단점을 가짐.

##### 장점 (Advantages)
| 장점                        | 설명                                                                                                                          |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| 최악의 시간 복잡도 보장             | $O(n \log n)$을 최악의 경우에도 보장함. 퀵 정렬이 최악의 경우 $O(n^2)$이 될 수 있는 것과 달리, 힙 정렬은 입력 데이터의 형태(이미 정렬되었든, 역순 정렬되었든)에 관계없이 성능이 안정적임.      |
| 제자리 정렬 (In-Place Sorting) | 추가적인 메모리 공간(보조 배열)을 거의 사용하지 않음. 배열 내에서 모든 스왑과 구조 재구성이 이루어지므로, 메모리가 제한적인 환경(임베디드 시스템 등)에 유리함. (병합 정렬은 보통 $O(n)$의 추가 공간이 필요함) |
| 우선순위 큐로의 활용               | 정렬 알고리즘 외에도, 힙 구조 자체는 데이터 구조인 **우선순위 큐(Priority Queue)** 를 구현하는 데 가장 효율적인 방법임.                                              |

##### 단점 (Disadvantages)
| 단점                              | 설명                                                                                                                                                   |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| 느린 상수 계수 (Slow Constant Factor) | 퀵 정렬이나 잘 구현된 병합 정렬에 비해 **실제 실행 속도(Constant Factor)** 가 느림. 힙 정렬은 많은 스왑과 인덱스 계산을 포함하며, 이는 **CPU 캐시 활용도** 를 떨어뜨림.                                      |
| 불안정 정렬 (Unstable Sorting)       | 안정성을 보장하지 않음. 즉, 값이 같은 두 원소의 정렬 전후의 상대적인 순서가 유지되지 않을 수 있음. (예: $\text{A} = 5_a, \text{B} = 5_b$ 일 때 , 정렬 후 $\text{B} = 5_b, \text{A} = 5_a$가 될 수 있음) |
| 지역성(Locality) 부족                | 힙의 구조는 트리의 레벨을 오가며 메모리에 불규칙하게 접근함, 이는 **캐시 메모리 지역성(Cache Locality)** 을 떨어뜨려 퀵 정렬처럼 순차적으로 메모리에 접근하는 알고리즘보다 불리함.                                       |

# 요약 및 선택 가이드
- 힙 정렬을 선택할 때:
	- **"최악의 경우 성능"** 을 반드시 보장해야 할 때 (안전성이 중요할 때).
	- "추가 메모리 공간" 사용을 극도로 줄여야 할 때.
- 힙 정렬을 피해야 할 때:
	- 대부분의 입력에서 **"가장 빠른 평균 속도"** 를 원할 때 (퀵 정렬이 더 빠름).
	- **"정렬의 안정성"** 이 필수적일 떄 (병합 정렬이 더 적합함).
