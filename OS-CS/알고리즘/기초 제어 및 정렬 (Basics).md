고급 알고리즘의 뼈대가 되는 핵심 논리들.

세 가지 핵심 무기는 **재귀(Recursion), 정렬(Sorting), 이진 탐색(Binary Search)** 임.

#### 재귀 (Recursion): "자기 자신을 호출하는 용기"
자료구조에서 **트리(Tree)** 를 순회하거나 **그래프(Graph)** 를 탐색할 때 코드가 의외로 짧았던 것이 재귀의 마법임.
- 정의: 함수가 작업을 수행하다가 자기 자신을 다시 호출하여 문제르 더 작게 쪼개 해결하는 방식.
- 핵심 구성요소 (필수):
	1. 기저 조건 (Base Case): 재귀를 멈추는 조건임. 이게 없으면 무한 루프에 빠져 **스택 오버플로우(Stack Overflow)** 가 발생함. (마치 브레이크 없는 자동차)
	2. 재귀 호출 (Recursion Case): 문제를 더 작은 단위로 쪼개서 자기 자신을 부르는 부분임.
- 시스템 관점: 재귀는 컴퓨터의 스택(Stack) 메모리를 사용함. 깊이가 너무 깊어지면 스택이 터짐. 그래서 엔지니어는 때때로 재귀를 **반복문(Loop)** 으로 바꿔 최적화하기도 함.

#### 정렬 (Sorting): "질서가 있어야 검색이 빠르다"
데이터를 순서대로 나열하는 것은 단순히 보기 좋게 하려는 것이 아님. 검색 속도를 비약적으로 높이기 위한 전처리(Pre-processing) 과정임.

수십 가지 정렬 알고리즘이 있지만, 엔지니어는 크게 두 그룹으로 나눔.

##### 직관적이지만 느린 정렬 ($O(n^2)$)
- 종류: 버블 정렬(Bubble), 선택 정렬(Selection), 삽입 정렬(Insertion).
- 특징: 구현이 매우 쉽지만 데이터가 많으면 느림.
- 왜 배우나? 데이터가 매우 적거나(예: 50개 미만), 이미 거의 정렬된 상태일 때는 오히려 복잡한 알고리즘보다 빠를 수 있음. (실제로 고성능 라이브러리들은 데이터가 작으면 삽입 정렬로 전환함.)

##### 효율적인 정렬 ($O(n \log n)) - 업계 표준
- 합병 정렬 (Merge Sort): 데이터를 반으로 쪼개고 ($\log n$) 다시 합치면서($n$) 정렬함. 항상 일정한 성능을 보장함.
- 퀵 정렬 (Quick Sort): 기준점(Pivot)을 잡고 작으면 왼쪽, 크면 오른쪽으로 던짐.
	- 엔지니어의 Pick: 이론상 최악의 경우 $O(n^2)$이지만, 실제로는 **캐시 지역성(Cache Locality)** 이 좋아서 합병 정렬보다 저 자주 쓰임.

#### 이진 탐색 (Binary Search): "반으로 쪼개서 찾기"
업다운(Up-Down) 게임을 생각하면 됨. 1~100 사이 숫자를 맞출 때 "50!"을 외치고 "Down"이면 1~49만 봄.
- 전제 조건: 데이터가 반드시 **정렬(Sorted)** 되어 있어야 함.
- 성능: $O(\log n). 데이터가 40억 개라도 단 32번이면 찾음.
- 연결: B+ Tree의 내부 노드나 T-Tree의 노드 내부에서 키를 찾을 때 바로 이 알고리즘을 사용.

### 엔지니어의 통찰 (Insight)
이 단계에서 가장 중요한 통찰은 **"Divide and Conquer (분할 정복)"** 임.
- 재귀: 큰 문제를 작은 문제로 쪼갠다.
- 합병/퀵 정렬: 큰 리스트를 작은 리스트로 쪼개서 정렬한다.
- 이진 탐색: 탐색 범위를 계속 반으로 쪼갠다.
- 
>**"거대한 문제를 만났을 때, 겁먹지 말고 반으로 쪼개라."** 이것이 알고리즘이 우레게 주는 첫 번째 교훈임.
