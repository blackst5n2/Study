#### 목표: 텍스트 내 패턴 탐색을 $O(N + M)$ 시간에 해결
일반적인 문자열 탐색(Naive Search)은 최악의 경우 $O(N \times M)$의 시간이 걸림 (전체 텍스트 N, 패턴 M). KMP는 이 문제를 해결하고 선형 시간인 $O(N + M)$ 복잡도를 달성함.

#### 핵심 원리: '불일치'를 최소화하는 전처리
KMP의 마법은 텍스트 탐색이 시작되기 전에 패턴 자체를 분석하여 **'어디까지 건너뛸지'** 를 미리 파악하는 전처리 과정에 있음.
1. 실패 함수 / LPS 배열 (Longest Proper Prefix which is also a Suffix):
	- 패턴 $M$을 분석하여, 각 위치에서 불일치가 발생했을 때 패턴의 어느 위치로 돌아가야 가장 효율적으로 탐색을 재개할 수 있는지에 대한 정보를 담은 배열을 만듦.
	- 이는 패턴의 '접두사'와 '접미사'가 일치하는 최대 길이를 저장하여, 중복된 비교를 완전히 생략하게 해줌.
2. 탐색 과정의 최적화:
	- 탐색 중 불일치가 발생하면, 일반적인 탐색은 텍스트의 처음부터 다시 비교를 시작하지만,
	- KMP는 LPS 배열을 참조하여, **"패턴의 이 부분이 텍스트의 이전 부분과 일치했으니, 이만큼은 건너뛰고 패턴의 그 위치에서부터 다시 비교를 시작하자** 고 결정함.
- 시스템 연결: 텍스트 편집기(Ctrl+F), 유전자 염기 서열 탐색, 컴파일러의 토큰 탐지 등 문자열 검색이 필요한 모든 고성능 시스템에서 사용됨.

# 구현 전략
#### 목표: 문자열 $N$ 내에서 패턴 $M$을 $O(N + M)$ 선형 시간에 탐색
일반적인 탐색(Naive Search)에서 발생하는 **불필요한 '후퇴(Backtracking)'** 를 완전히 제거하여, 텍스트와 패턴의 문자를 각각 한 번씩만 검사하는 것을 목표로 함.

#### 1. 전처리 과정: 실패 함수 (Failure Function) / LPS 배열 구축
KMP의 마법은 탐색을 시작하기 전에 패턴 자체를 분석하는 데 있음. 이 전처리를 통해 $\pi$ 함수(LPS 배열)를 만듦.
- LPS (Longest Proper Prefix which is also a Suffix): 패턴의 특정 위치까지의 문자열에서 "가장 길면서" 동시에 **"접두사"** 이면서 **"접미사"** 인 부분 문자열의 길이.
- 논리: 이 길이는 불일치가 발생했을 때, 이전에 이미 일치했던 정보를 활용하여 패턴을 몇 칸 이동시켜야 할지를 알려주는 '점프 테이블' 역할을 함.

##### LPS 배열 구축 과정의 논리
1. 초기화: 배열의 첫 번째 값(길이 1)은 항상 0임.
2. 포인터: 두 개의 포인터(길이 포인터 `len`, 현재 위치 `i`)를 사용하여 패턴을 탐색함.
3. 일치하는 경우: `Pattern[i]`와 `Pattern[len]`이 일치하면, `LPS[i]`를 `len + 1`로 설정하고 두 포인터를 모두 증가시킴. (이전까지의 접두사/접미사 길이 + 1)
4. 불일치하는 경우:
	- `len > 0`일 때: `len`을 0으로 초기화하는 대신, `len = LPS[len - 1]`로 설정함. 즉, 이전에 이미 일치했던 더 짧은 접두사/접미사 정보로 패턴을 이동시켜 다시 일치하는지 확인함. (이전의 지식 활용)
	- `len == 0`일 때: 일치하는 부분이 없으므로 `LPS[i]`는 0이 되고, `i`만 증가시킴.

#### 2. 탐색 과정: 텍스트와 패턴 매칭
LPS 배열을 사용하여 텍스트($N$) 내에서 패턴($M$)을 탐색함.
- 포인터: 텍스트 포인터 `i`, 패턴 포인터 `j`를 사용함.
- 일치하는 경우: `Text[i]`와 `Pattern[j]`가 일치하면 두 포인터 `i`와 `j`를 모두 증가시킴.
- 패턴을 찾은 경우: `j`가 패턴의 길이 $M$에 도달하면, 매칭에 성공한 것임. 이 경우, `j`를 `LPS[j-1]`로 설정하여 패턴의 다음 잠재적 매핑 시작 위치로 빠르게 이동함.
- 불일치하는 경우 (핵심 논리):
	- `j > 0`일 때: 텍스트 포인터 $i$는 그대로 두고, 패턴 포인터 `j`만 `LPS[j-1]`로 설정하여 이동시킴.
	- 가장 중요한 점: 텍스트 포인터 `i`를 뒤로 돌리지 않음! 이전에 일치했던 정보는 버리지 않고, 패턴만 최소한으로 이동하여 탐색을 재개함.

#### 3. $O(N + M)$ 복잡도의 원천
- 전처리 ($O(M)$): LPS 배열을 만들 때 패턴의 모든 문자를 단 한 번씩만 비교함.
- 탐색 ($O(N)$): 텍스트의 모든 문자는 $i$ 포인터에 의해 최대 한 번만 검사됨.
최종 복잡도는 $O(N+M)$이며, 이는 텍스트 크기에 비례하는 선형 시간($O(N)$)으로 간주될 정도로 매우 효율적임.
