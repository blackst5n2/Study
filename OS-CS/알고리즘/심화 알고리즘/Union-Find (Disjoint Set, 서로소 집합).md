#### 목표: 연결 관계를 $O(1)$에 가깝게 관리
Union-Find는 여러 개의 원소들을 **'서로소 집합(겹치지 않는 집합)'** 으로 나눈 후, 다음 두 가지 연산을 극도로 효율적으로 처리하기 위해 설계됨.
1. Find (찾기): 특정 원소가 어떤 집합에 속하는지, 즉 **대표자(Representative)** 가 누구인지 찾음.
2. Union (합치기): 두 집합을 하나의 집합으로 합침.

##### 핵심 원리: 트리를 이용한 집합 표현
각 집합을 트리의 형태로 표현함. 트리의 **루트 노드(Root Node)** 가 그 집합 전체의 대표자가 됨.

##### 효율성 극대화 기술 (엔지니어링의 정수)
Union-Find가 단순한 트리가 아닌 '고성능' 자료구조가 되는 비결은 다음 두 가지 최적화(Optimization) 기술에 있음. 이 기술들 덕분에 평균적인 복잡도는 **거의 상수 시간($O(\alpha(N)$), 아커만 함수의 역함수)** 에 수렴함.

| 최적화 기술                   | 목표                       | 작동 원리                                                                                                                           |
| ------------------------ | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| 경로 압축 (Path Compression) | Find 연산의 깊이를 줄여 탐색 속도 향상 | `Find` 연산 시, 루트(대표자)를 찾아낸 후, 해당 경로에 있던 모든 노드들이 직접 루트를 가리키도록 연결을 '압축'함. 다음 `Find` 연산 시에는 즉시 루트에 도달함.                             |
| 랭크 또는 크기 기반 Union        | 트리의 불필요한 높이 증가 방지        | 두 집합을 합칠 때(Union), **무조건 큰 집합(노드가 많은 집합)** 이나 **트리 높이(Rank)가 높은 집합** 의 루트가 새로운 루트가 되도록 만듦. 이는 트리가 한쪽으로 기울어지는 것을 방지하여 전체 높이를 낮춤. |

- 시스템 연결: 크루스칼 알고리즘 `MST`에서 두 노드가 사이클을 형성하는지 여부를 판단하는 데 $O(1)$에 가까운 속도로 사용됨.

# 구현 전략
### 목표: 거의 $O(1)$의 속도로 집합 관계 관리
Union-Find를 구현할 때의 핵심 논리는 **배열(Array)** 을 사용하여 트리 구조를 표현하는 것.

#### 1. 자료구조 선택 및 배열 초기화
- 핵심 자료구조: 단 하나의 배열 (Parent Array)
- 배열의 의미: `parent[i]`는 노드 $i$의 부모 노드를 저장함.
- 초기 상태: 처음에는 모든 원소가 자기 자신이 속한 집합의 유일한 멤버이므로, `parent[i] = i`로 초기화함. 즉, 모든 노드가 자기 자신이 집합의 **대표자(루트)** 인 상태로 시작함.

#### 2. Find 연산 전략: 대표자 찾기
논리: 노드 $i$가 속한 집합의 대표자를 찾는 과정.
1. 반복문/재귀 시작: 현재 노드 $i$가 자신의 부모를 가리키고 있는지 확인함.
2. 중료 조건 (대표자 확인): 만약 `parent[i] == i`라면, $i$는 자기 자신을 부모로 가리키는 **루트 노드(대표자)** 이므로 탐색을 종료하고 $i$를 반환함.
3. 다음 탐색: 아니라면, `parent[i]`를 새로운 노드로 삼아 이 과정을 반복함.

##### 핵심 구현 논리: 경로 압축 (Path Compression)
`Find` 연산을 마친 후, 재귀의 역순을 이용하거나 반복문을 이용하여 경로를 압축함.
- 전략: $i$에서부터 대표자(루트)까지 가는 경로에 있떤 모든 노드들의 부모를 방금 찾은 루트로 직접 변경함.
- 효과: 이 노드들은 다음 `Find` 연산부터는 단 한 번의 접근($O(1)$)으로 대표자를 찾을 수 있음. 이는 시스템의 장기적인 효율성을 보장함.

#### 3. Union 연산 전략: 두 집합 합치기
논리: 두 원소 $a$와 $b$가 속한 집합을 하나로 합치는 과정임.
1. 대표자 찾기: 먼저 `Find(a)`와 `Find(b)`를 호출하여 각 집합의 대표자 $R_a$와 $R_b$를 찾음.
2. 합치기 정렬: $R_a$와 $R_b$가 이미 같다면(한 집합이라면) 아무것도 할 필요가 없음.
3. 합치기 실행: $R_a$와 $R_b$가 다르다면, 두 대표자 중 하나를 다른 하나의 자식으로 만듦.

##### 핵심 구현 논리: 랭크/크기 기반 합치기 (Union by Rank/Size)
- 전략: 두 집합을 합칠 때, 작은 집합의 대표자가 큰 집합의 대표자에게 종속되도록 만듦. (높이가 낮은 트리를 높은 트리의 밑에 붙임.)
- 효과: 이로써 트리가 한쪽으로 편향되어 깊이가 불필요하게 깊어지는 것을 방지함. 트리의 깊이(높이)가 곧 `Find` 연산의 최악의 경우 성능을 결정하기 때문에, 이 논리는 **트리의 높이를 최소화($O(\log n) 이하)** 하는 데 결정적임.

