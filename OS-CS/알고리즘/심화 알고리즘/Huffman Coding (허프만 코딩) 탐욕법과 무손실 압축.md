#### 목표: 데이터 압축률 최대화 (가변 길이 부호화)
Huffman Coding은 무손실 압축(Lossless Compression) 알고리즘의 고전임. 파일을 압축할 때, 정보 손실 없이 파일 크기를 줄이는 것이 목표.

#### 핵심 원리: 빈도 기반의 탐욕적 부호화
이 알고리즘은 **탐욕법(Greedy Algorithm)** 을 사용하여 최적의 압축을 달성함.
1. 빈도 분석: 입력 데이터(텍스트 등)에서 각 문자가 얼마나 자주 출현하는지 빈도를 세어 확인함.
2. 탐욕적 선택: 가장 낮은 빈도를 가진 문자 쌍을 찾음. 이것이 현재 시점에서 가장 효율적인 선택 (Local Optimum).
3. 트리 생성 (Bottom-up): 가장 낮은 빈도 쌍을 **하나의 노드(집합)** 로 묶고, 이 새로운 노드의 빈도(두 문자의 빈도 합)로 대체함. 이 과정을 반복함.
4. 부호 할당: 최종적으로 완성된 허프만 트리에서 루트(Root)부터 리프(Leaf)까지 내려오면서 부호를 할당함.
	- 왼쪽 가지는 **'0'**, 오른쪽 가지는 **'1'** 을 할당함.
	- 빈도가 높은 문자는 루트에 가깝게 배치되어 짧은 비트열을 가짐.
	- 빈도가 낮은 문자는 리프 깊숙이 배치되어 긴 비트열을 가짐.
- 복잡도: 주로 빈도 계산 및 우선순위 큐(Heap)를 이용한 트리 생성 단계에서 $O(N \log N)$의 시간이 걸림.
- 성질: 이 방식은 **접두사 없는 코드(Prefix-free Code)** 를 생성함. 즉, 어떤 문자의 코드가 다른 문자의 코드의 접두사가 될 수 없으므로, 비트열을 읽을 때 모호성 없이 정확하게 해독할 수 있음.

# 구현 전략
#### 목표: 최적의 무손실 압축 코드 테이블 생성
문자열에서 자주 나오는 문자에는 짧은 비트 코드를 할당하고, 드믈게 나오는 문자에는 긴 비트 코드를 할당하여, 전체 파일 크기를 최소화하는 것이 목표.

#### 1. 핵심 자료구조 및 초기화 논리
- 핵심 자료구조 1: 빈도 테이블 (Frequency Table)
	- 입력 데이터 전체를 한 번 스캔하여 각 문자가 몇 번 출현했는지(빈도)를 기록함. (예: A: 5회, B: 2회, C: 1회)
- 핵심 자료구조 2: 우선순위 큐 (Priority Queue, Min-Heap)
	- 탐욕적 선택을 용이하게 하기 위해 사용됨.
	- 초기에 모든 문자를 노드 객체로 만들고, '빈도'를 우선순위 기준으로 삼아 큐에 넣음. (가장 빈도가 낮은 노드가 큐의 맨 위에 오도록 Min-Heap을 사용)
- 핵심 자료구조 3: 허프만 트리 노드 (Huffman Tree Node)
	- 각 노드는 문자(값), 빈도, 그리고 왼쪽 자식(Left Child), 오른쪽 자식(Right Child) 포인터(또는 인덱스)를 가짐.

#### 2. 트리 구축 단계: 탐욕적 병합 (Greedy Union)
이 단계에서 탐욕적 선택이 이루어지며, 트리가 아래에서 위로(Bottom-up) 생성됨.
1. 반복 시작: 우선순위 큐에 노드가 단 하나만 남을 때까지 반복함.
2. 탐욕적 선택: 큐에서 가장 빈도가 낮은 노드 두개를 꺼냄 (Min-Heap의 `pop` 연산). 이것이 현재 시점에서 가장 큰 이익(압축률)을 보장하는 최적의 지역적 선택임.
3. 새 노드 생성 및 결합:
	- 이 두 노드를 자식으로 가지는 **새로운 내부 노드(Internal Node)** 를 생성함.
	- 새 노드의 빈도는 두 자식 노드의 빈도를 합한 값으로 설정함.
4. 재삽입: 새로 생성된 내부 노드를 다시 우선순위 큐에 삽입함.
5. 종료: 반복이 끝나면 큐에 남은 하나의 노드가 바로 **허프만 트리의 루트(Root)** 가 됨.

#### 코드 생성 단계: 부호 할당 (Code Generation)
트리 구축이 완료되면, 루트에서 리프 노드까지 탐색하며 각 문자에 해당하는 비트 코드를 할당함.
1. DFS (깊이 우선 탐색): 루트 노드에서 시작하여 재귀적으로 트리를 순회함.
2. 부호 할당 논리:
	- 왼쪽 자식으로 이동할 때는 현재 코드에 **'0'** 을 추가함.
	- 오른쪽 자식으로 이동할 때는 현재 코드에 **'1'** 을 추가함.
3. 저장: 리프 노드(실제 문자가 담긴 노드)에 도달하면, 그때까지 누적된 비트열이 해당 문자의 최종 코드(예: $A \rightarrow$ "001")가 됨.
4. 결과: 이 과정을 통해 문자 -> 비트 코드의 매핑 테이블(Code Table)이 완성됨.

#### 4. 인코딩 및 디코딩 논리
- 인코딩 (압축): 원본 텍스트를 순회하면서, 생성된 코드 테이블을 참조하여 각문자를 해당하는 비트열로 치환하여 출력함. (예: "AABC" -> "00100110")
- 디코딩 (압축 해제): 압축된 비트열을 읽으면서 허프만 트리를 따라 탐색함. '0'이 나오면 왼쪽, '1'이 나오면 오른쪽으로 이동함. 리프 노드에 도달하는 순간, 해당 노드의 문자를 출력하고, 다시 루트 노드로 돌아가 탐색을 재개함. (Prefix-free 속성 덕분에 모호성 없이 정확한 분리 지점을 알 수 있음)

#### 5. 구현의 복잡도
- 시간 복잡도: $O(C \log C)$ 또는 $O(N \log C)$
	- $C$: 고유 문자의 개수 (일반적으로 상수, 예: 256)
	- $N$: 입력 텍스트의 총 길이
	- 대부분의 시간은 우선순위 큐에 $C$개의 노드를 삽입하고 $C - 1$번 추출/삽입하는 과정(Heap 연산)에서 발생함. Heap의 삽입/추출은 $O(\log C)$이므로, 전체 트리 구축은 $O(C \log C)$가 됨.
	- 이후 인코딩은 텍스트 길이 $N$에 비례($O(N)$)함.
