컴퓨터가 풀 수 있는 문제와 풀 수 없는 문제의 경계를 정의하며, 시스템의 궁극적인 성능 한계를 이해.

#### 계산 가능성 vs 복잡성 (Computability vs. Complexity)
- 계산 가능성 (Computability): "이 문제가 원천적으로 컴퓨터로 풀 수 있는가, 없는가?"를 다룸. (예: 튜링 머신)
- 복잡성 (Complexity): "문제가 풀 수 있다면, 얼마나 빨리 풀 수 있는가?"를 다룸. (Big-O 표기법의 확장)

#### P 클래스와 NP 클래스의 경계
알고리즘 복잡도 이론의 핵심은 문제의 난이도에 따라 문제를 두 가지 큰 클래스로 분류하는 것.

##### P (Polynomial Time) 클래스
- 정의: 다항 시간 내에 해답을 찾을 수 있는 문제들의 집합.
	- 다항 시간: 복잡도가 $O(n^k)$ 형태인 경우 (k는 상수). (예: $O(n), O(n^2), O(n^3), O(n \log n)$ 등).
	- 특징: 현실적으로 **'풀 수 있는 문제(Tractable)'** 로 간주됨.
	- 예시: 정렬, 최단 경로 (Dijkstra), 이진 탐색.

##### NP (Non-deterministic Polynomial Time) 클래스
- 정의: 해답을 찾는 데는 시간이 오래 걸릴 수 있지만, 주어진 해답이 올바른지 검증하는 것은 다항 시간 내($O(n^k)$)에 가능한 문제들의 집함.
	- **"Non-deterministic"** 은 '답을 추측'하는 과정이 무작위적일 수 있음을 의미함.
- 특징: 많은 최적화 문제들이 여기에 속함.
- 에시: 외판원 문제(Traveling Salesman Problem, TSP), 배낭 문제(Knapsack Problem), 해밀턴 경로 문제.

##### 궁극의 난제: NP-Complete (NP-C)
NP 클래스 중에서도 가장 어려운 문제들의 집합.
- 정의:
	1. NP 문제에 속하며 (해답 검증이 빠르며),
	2. NP에 속하는 다른 모든 문제를 이 문제로 **변환(Reduction)** 할 수 있는 문제.
- 의미: 만약 NP-C 문제 중 단 하나라도 $O(n^k)$의 다항 시간 알고리즘이 발견된다면, NP에 속하는 모든 문제도 다항 시간 내에 풀리게 됨. (즉, $\text{P} = \text{NP}$가 증명됨.)

#### $P \neq NP$ 가설 (밀레니엄 문제)
- 현재의 믿음: 대부분의 컴퓨터 과학자들은 $\text{P} \ne \text{NP}$일 것이라고 믿음. 즉, NP-C문제를 다항 시간 내에 풀 수 있는 방법은 없다고 가정함.
- 엔지니어링의 현실: NP-C 문제(예: TSP)에 직면했을 때, 우리는 '최적의 정답'을 찾는 대신 다음 세 가지 전략 중 하나를 택해야 함.

#### NP 난제에 대한 엔지니어링 전략
| 전략                         | 설명                                                                                             | 응용 시나리오                                            |
| -------------------------- | ---------------------------------------------------------------------------------------------- | -------------------------------------------------- |
| A. 근사 알고리즘 (Approximation) | "최적의 해답이 아니어도 좋다." 해답이 최적 해답의 $1 + \epsilon$ 배 이내임을 보장하는, 충분히 좋은 해답(Good Enough)을 다항 시간 내에 찾음. | 최적의 물류 경로를 찾는 대신, '99% 최적인 경로'를 1초 만에 찾는 경우.       |
| B. 휴리스틱 (Heuristics)       | "직관에 의존한다." 최적 해답을 보장하지 않지만, 현실적인 문제에서는 잘 작동하는 경험적 규칙을 사용함.                                    | A* 알고리즘의 $h(n)$ (예상 비용), 유전 알고리즘.                  |
| C. 특수한 경우 활용               | 문제의 입력 크기($n$)를 제한하거나, 그래프의 특성 (예: 평면 그래프, 매우 희소한 그래프)을 이용해 다항 시간 내에 푸는 특화된 방법을 찾음.            | 입력 데이터의 크기($n$)가 작은 경우에만 $O(2^n)$의 Brute Force 허용. |
