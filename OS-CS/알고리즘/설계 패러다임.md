문제를 바라보는 관점과 최적의 해답을 설계하는 전략.

문제 해결을 위한 세 가지 강력한 전략, 즉 **분할 정(Divide and Conquer), 동적 계획법(Dynamic Programming), 탐욕법(Greedy)** 를 학습할 것.

#### 분할 정복 (Divide and Conquer, D&G)
가장 기본적인 접근법이자, Cache-Oblivious Algorithms와 같이 하드웨어 최적화에 사용되는 근본 원리.
- 원리:
	1. 분할 (Divide): 문제를 여러 개의 작은 하위 문제로 나눔.
	2. 정복 (Conquer): 나뉜 하위 문제를 재귀적으로 해결.
	3. 결합 (Combine): 하위 문제의 해답을 합쳐 최종 문제의 해답을 만듦.
- 대표 예시: Quick Sort, Merge Sort, 이진 탐색, 행렬 곱셈 (Strassen 알고리즘).

#### 탐욕법 (Greedy Algorithm)
탐욕법은 당장의 이익만을 보고 결정을 내리는 단순하지만 강력한 전략.
- 원리: 각 단계에서 전체 최적 해답을 고려하지 않고, 오직 **현재 시점에서 가장 최적(Best Local Choice)** 이라고 판단되는 선택을 함.
- 특징:
	- 빠름. 복잡한 계산 없이 한 번의 결정으로 끝남.
	- 위험함. 지역 최적 해(Local Optimum)가 전역 최적 해 (Global Optimum)가 되지 못하는 경우가 많음.
- 대표 예시:
	- 거스름돈 문제: 500원, 100원, 50원, 10원 동전이 있을때, 620원을 거슬러 줘야 한다면 **가장 큰 동전(500원)** 부터 주는 것이 현재 시점의 최적 선택이며, 이것이 전체에서도 최적.
	- 최소 신장 트리 (MST)의 프림/크루스칼 알고리즘: 당장 가장 가중치가 낮은 간선만 선택하는 방식.

#### 동적 계획법 (Dynamic Programming, DP)
알고리즘 설계의 꽃. **'복잡한 문제를 단순하게 만드는 마법'**. DP는 분할 정복과 유사하지만, **'중복된 계산을 메모리에 저장하여 피한다'** 는 결정적인 차이가 있음.
- 원리:
	1. 최적 부분 구조 (Optimal Substructure): 전체 문제의 최적 해답이 작은 부분 문제의 최적 해답들로 구성되어야 함.
	2. 중복되는 부분 문제 (Overlapping Subproblems): 작은 부분 문제가 계속해서 중복으로 계산되어야 함. (DP의 필요성)
- 접근 방법:
	- 메모이제이션 (Memoization): 재귀를 사용하여 문제를 해결하되, 계산한 결과를 **캐시(Cache)** 에 저장해 두고 필요할 때 재사용함. (Top-down 방식)
	- 테이블 채우기 (Tabulation): 반복문을 사용하여 가장 작은 부분 문제부터 차례대로 해답을 계산해 테이블(배열)에 채워나감. (Bottom-up 방식)
- 대표 예시: 피보나치 수열, 최장 공통 부분 수열 (LCS), 배낭 문제 (Knapsack Problem).

### 엔지니어의 통찰 (Insight)
이 세가지 패러다임의 선택은 엔지니어링의 핵심 결정.
1. D&C: 문제가 완전히 독립적인 하위 문제로 나뉘어지면 D&C를 고려함.
2. Greedy: 문제의 구조상 지역 최적 해가 전역 최적 해임을 논리적으로 증명할 수 있을 때만 Greedy를 사용함. (매우 까다로운 조건)
3. DP: 문제가 작은 단위로 나뉘어지지만, 같은 부분을 수없이 반복 계산해야 할 때 DP를 사용하여 $O(2^n)$의 지수 시간을 $O(n^2)$나 $O(n)$의 다하 시간으로 줄여줌.

> 이 세 가지 전략적 사고방식이 알고리즘 설계의 핵심.

