가장 밑바닥부터 시작하기 위해, CPU가 코드를 실행하는 방식, 즉 **명령어 집합 구조(Instruction Set Architecture, ISA)** 와 **마이크로아키텍처(Microarchitecture)** 의 두 가지 핵심 주제로 나누어 학습.

### 주제 1: 명령어 집합 구조 (ISA)
ISA는 CPU가 이해하는 언어의 문법이자 단어장임. 우리가 C/C++로 코딩하면, 결국 컴파일러는 이 ISA가 정의한 명령어로 변환.

#### 명령어 형식 (Instruction Format)
CPU가 명령어를 처리하기 쉽게, 모든 명령어는 고정된 형식(Format)을 가짐. (예: 32비트 또는 64비트) 명령어는 크게 세 부분으로 구성됨.
- Opcode (연산 코드): "무엇을 할 것인가?" (예: 덧셈, 뺄셈, 메모리 로드 등)
- Operand (피연산자): "누구를 대상으로 할 것인가?" (예: 사용할 레지스터 번호, 메모리 주소 등)

#### 명령어 유형 (Instruction Types)
ISA의 모든 명령어는 다음 세 가지 기본 유형 중 하나에 속함.

| 유형         | 설명                  | 예시                                           |
| ---------- | ------------------- | -------------------------------------------- |
| 산술/논리 명령어  | 레지스터 간의 계산 및 논리 연산  | `ADD R1, R2, R3` (R2+R3 결과를 R1에 저장)          |
| 데이터 전송 명령어 | 메모리와 레지스터 간의 데이터 이동 | `LOAD R1, address` (메모리 값을 레지스터 R1로 가져옴)     |
| 제어 명령어     | 프로그램 실행 흐름의 변경      | `JUMP address`, `BEQ` (분기, Subroutine 호출/리턴) |

#### 메모리 접근 방식 (Addressing Modes)
CPU가 데이터를 가져올 메모리 주소를 어떻게 계산할 것인지를 정의함.
- 레지스터 간접 주소 지정: 레지스터에 저장된 주소 값을 이용하여 메모리에 접근함. (임베디드에서 `*pointer`를 쓰는 방식과 같음.)
- 기준 주소 지정: 레지스터 값에 상수(Offset)를 더하여 최종 주소를 계산함. (배열 인덱싱 등에 사용)

### 주제 2: 마이크로아키텍처 (실행 파이프라인)
ISA가 '무엇을' 할지 정한다면, 마이크로아키텍처는 '어떻게' 그것을 빠르고 효율적으로 수행할지를 정의함. 핵심은 **파이프라인(Pipeline)** 임.

#### 파이프라인의 원리
명령어 하나를 실행하는 과정을 여러 단계로 쪼개어, 여러 개의 명령어를 동시에 처리하는 기술임. 마치 자동차 조립 라인처럼 명령어 처리를 병렬화함.
- 단계 예시 (5단계 파이프라인):
	1. IF (Instruction Fetch): 명령어를 메모리에서 가져옴.
	2. ID (Instruction Decode): 명령어 해석 및 레지스터를 읽음.
	3. EX (Execute): 연산(덧셈, 뺄셈 등)을 수행함.
	4. MEM (Memory Access): 메모리 로드/저장 작업을 수행함.
	5. WB (Write Back): 결과를 레지스터에 다시 기록함.

#### 파이프라인의 위험 (Hazards)
파이프라인이 동시에 명령어들을 처리하다 보면 충돌이 발생할 수 있음.
- 데이터 위험 (Data Hazard): 이전 명령어가 계산한 결과(데이터)를 다음 명령어가 필요로 하는데, 이전 명령어가 아직 결과를 내놓지 못했을 때 발생함.
- 제어 위험 (Control Hazard): `if/else`나 `JUMP` 명령(분기 명령어)이 실행될 때, CPU는 다음에 실행할 명령어를 예측해야 하는데, 이 예측이 틀렸을 때 발생함.

# 데이터 위험(Data Hazard) 해결책: 전방 전달 (Forwarding/Bypassing)
**데이터 위험(Data Hazard)** 은 파이프라인에서 이전 명령어가 계산한 결과를 다음 명령어가 필요로 하는데, 그 결과가 아직 레지스터에 기록(Write Back)되지 않아 발생하는 문제임. CPU눈 이 문제를 해결하기 위헤 **전방 전달(Forwarding)** 이라는 기법을 사용함.

#### 문제 상황 예시
1. ADD R1, R2, R3 (R2 + R3 결과를 R1에 저장)
2. SUB R4, R1, R5 (R1에서 R5를 뺀 결과를 R4에 저장)

`ADD` 명령의 결과(R1)는 5단계(WB)에서야 레지스터에 기록되는데, `SUB` 명령은 3단계 (EX)에서 이미 R1의 값을 필요로함. -> 지연(Stall) 발생 위험.

#### 해결책: 전방 전달 (Forwarding)의 원리
CPU는 레지스터에 결과가 기록될 때까지 기다리는 대신, 결과가 파이프라인 내부에서 이미 계산되는 즉시(아직 레지스터에 기록되기 전이라도) 이 값을 다음 명령어가 필요로 하는 곳으로 바로 넘겨주는(전달하는) 하드웨어 경로를 추가함.
- 동작: `ADD` 명령이 3단계(EX)를 마치는 순간(결과가 계산된 시점), 그 결과를 다음 명령인 `SUB`의 입력부(EX단계 직전)로 와이어(Wire)를 통해 즉시 전달함.
- 효과: `SUB` 명령은 딜레이 없이 바로 올바른 R1 값을 입력받아 실행을 계속할 수 있음. 파이프라인 지연(Stall)을 0으로 만듦.

	예외: `LOAD` 명령(메모리에서 데이터를 가져오는 명령)의 경우, 데이터가 파이프라인의 MEM 단계에서야 도착하므로, 다음 명령에게 전달해도 여전히 **최소 1 클럭의 지연 (Stall)** 이 필요할 수 있음.

# 캐시 주소 매핑 및 관리 방식
CPU가 캐시(Cache)에 데이터를 가져올 때, 메모리 주소(물리 주소)의 어느 위치(Line)에 저장할지 결정하는 방법을 **매핑(Mapping)** 이라고 함. 매핑 방식은 캐시의 속도, 비용, 효율을 결정함.

#### 직접 매핑 (Direct Mapped Cache)
- 원리: 메모리의 특정 주소는 캐시의 오직 한 위치에만 저장될 수 있음. (가장 단순한 규칙)
- 주소 분할: 주소는 세 부분으로 분할됨.
	1. 블록 오프셋 (Offset): 블록 내의 바이트 위치.
	2. 인덱스 (Index): 캐시의 어느 라인에 저장될지 결정하는 주소.
	3. 태그 (Tag): 데이터가 원하는 메모리 주소에서 온 것인지 확인하는 나머지 주소.
- 장점: 하드웨어 구현이 매우 간단하고 빠름.
- 단점: 충돌(Conflict) 미스가 자주 발생함. 서로 다른 메모리 주소(태그)가 같은 인덱스를 사용하면 계속 덮어쓰게 됨.

#### 완전 연관 매핑 (Fully Associative Cache)
- 원리: 메모리 블록이 캐시의 어느 곳이든 원하는 위치에 저장될 수 있음. (제약 없음)
- 장점: 충돌 미스가 거의 없어 미스율(Miss Rate)이 가장 낮음.
- 단점: 하드웨어 구현이 복잡하고 느림. (모든 캐시 라인을 동시에 비교해야 함)

#### 세트 연관 매핑 (Set Associative Cache)
- 원리: 직접 매핑과 완전 연관 매핑의 절충안임. 캐시를 여러 개의 **세트(Set)** 로 나누고, 메모리 블록은 정해진 세트 내의 아무 곳에나 저장될 수 있음. (예: 4-way Set Associative는 세트 내 4곳 중 아무 곳에나 저장 가능)
- 특징: 메모리 주소의 인덱스가 먼저 세트 번호를 결정하고, 세트 내에서는 연관 검색을 수행함.
- 장점: 복잡도를 적당히 유지하면서 미스율을 크게 낮출 수 있어 현대 CPU 캐시의 표준으로 사용됨.

# 분기 명령(Branch Instruction)의 악영향
**분기 명(Branch Instruction)** 은 파이프라인의 효율성에 가장 치명적인 **제어 위험(Control Hazard)** 을 유발함. 분기 명령은 `if`, `for`, `while` 문 등의 흐름 제어를 담당하며, 다음 명령어를 예측하기 어렵게 만듦.

#### 문제 발생 원리
1. CPU가 분기 명령 (`BEQ R1, R2, Target`)을 만났을 때, `R1`과 `R2`가 같은지(분기) 다른지(비분기)는 EX 단계까지 가야만 알 수 있음.
2. 하지만 파이프라인의 IF 단계는 매 클럭마다 다음 명령어를 가져와야 함.
3. 대기 (Stall) 문제: CPU가 분기 결과를 기다리느라 파이프라인을 멈추면(Stall) 수많은 클럭을 낭비하게 됨.

#### 해결책: 분기 예측 (Branch Prediction)
파이프라인이 멈추는 것을 피하기 위해, CPU는 가장 가능성이 높은 다음 명령어를 추측하여 미리 실행해 둠.
1. 정적 예측 (Static Prediction): 항상 분기하지 않을 것이라고 가정하거나, 프로그래머가 코드에 힌트(hint)를 주는 방식.
2. 동적 예측 (Dynamic Prediction): 과거의 실행 기록(분기 이력)을 기반으로 다음에 분기가 일어날지 확률적으로 예측함.
- 예측 실패 (Misprediction): 예측이 틀렸다면?
	- CPU는 파이프라인에 미리 넣어둔 모든 명령어를 **즉시 폐기(Flush)** 함. (수행했던 모든 작업 취소)
	- 정확한 주소로 돌아가 다시 IF 단계부터 시작함.
	- 이때 폐기로 인해 낭비되는 클럭이 파이프라인의 효율성을 크게 떨어뜨리는 주범이 됨.

	결론 : 분기 명령의 악영향을 최소화하는 것이 곧 CPU 성능 향상의 핵심 과제이며, 이것이 바로 **고도화된 분기 예측 하드웨어** 가 필요한 이유.
