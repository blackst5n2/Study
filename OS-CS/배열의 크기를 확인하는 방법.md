배열의 길이를 확인하는 방법은 배열이 선언된 방시과 C++의 버전에 따라 달라짐.

# 정적 배열 (Static Array)의 길이 확인 방법
함수로 전달되지 않고, 동일 스코프 내에서 선언된 일반적인 C-스타일 배열임. 이 방법dms **컴파일 타임에 크기가 결정** 되므로 가능함.

#### 방법 1: `sizeof` 연산자 사용 (가장 전통적인 방법)
`sizeof` 연산자를 사용하여 전체 배열의 크기를 원소 하나의 크기로 나누면 배열의 총 원소 개수를 얻을 수 있음.
$$\text{배열의 크기} = \frac{\text{배열 전체의 메모리 크기 (바이트)}}{\text{배열 원소 하나의 메모리 크기 (바이트)}}$$
```cpp
#include <iostream>
#include <cstddef>

int main() {
	int arr[] = {10, 20, 30, 40, 50}; // 크기가 5인 정수 배열
	
	// 1. 배열 전체 크기 (예: 5 * 4 = 20 바이트)
	size_t total_size = sizeof(arr);
	
	// 2. 원소 하나의 크기 (예: int는 4 바이트)
	size_t element_size = sizeof(arr[0]);
	
	// 3. 배열의 길이 계산
	size_t array_length = total_size / element_size;
	
	std::cout << "배열의 길이: " << array_length << std::endl; // 출력: 5
	
	return 0;
}
```

#### 방법 2: `std::size` (C++17 이상)
C++17부터는 배열의 길이를 더 깔끔하게 얻을 수 있는 표준 함수 `std::size`가 제공됨.

```c++
#include <iostream>
#include <iterator> // std::size를 포함하는 헤더 (또는 <array>)

int main() {
	int arr[] = {1, 2, 3, 4, 5, 6};
	
	size_t array_length = std::size(arr);
	
	std::cout << "배열의 길이: " << array_length << std::endl; // 출력: 6
	
	return 0;	
}
```

# 함수로 전달된 배열 (포인터)의 길이 확인 문제
가장 중요한 문제임. 배열을 함수에 인수로 전달하면, C++에서는 배열이 그 첫 번째 원소를 가리키는 **포인터(Pointer)** 로 **묵시적 변환(Decay)** 됨.

```cpp
void print_array(int arr[]) {
	// 여기서 arr는 더 이상 배열이 아닌, int* (int 포인터)임.
	// 따라서 sizeof(arr)는 포인터 자체의 크기(4 또는 8 바이트)를 반환함!
	// -> 배열의 길이를 알 수 없음.
	
	// cout << sizeof(arr) / sizeof(arr[0]); // **잘못된 계산**
}
```

#### 해결책: 길이 정보를 함께 전달
이 문제를 해결하는 유일한 방법은 함수를 호출할 때 배열의 길이 정보를 **별도의 인자** 로 함께 전달하는 것임.
```cpp
#include <iostream>

void print_array(int arr[], size_t length) {
	std::cout << "배열의 길이: " << length << std::endl;
	for (size_t i = 0; i < length; ++i) {
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
}

int main() {
	int data[] = {100, 200, 300};
	// main 함수 내에서 길이 계산
	size_t len = sizeof(data) / sizeof(data[0]);
	
	// 함수 호출 시 배열과 길이를 같이 전달
	print_array(data, len);
	
	return 0;
}
```

# C++ 표준 라이브러리 (STL) 컨테이너 사용 권장
C-스타일 배열의 단점(길이 추적의 어려움)을 해소하기 위해, C++에서는 **표준 템플릿 라이브러리(STL)** 의 컨테이너를 사용하는 것이 강력하게 권장됨. 이들은 모두 **길이 정보를 내부적으로 관리** 하며, `.size()` 멤버 함수를 제공함.

| 컨테이너          | 설명                           | 길이 확인 변수                 | 비고                |
| ------------- | ---------------------------- | ------------------------ | ----------------- |
| `std::vector` | 동적 크기 배열. 가장 많이 사용 됨.        | `.size()`                | 크기가 유연하게 변할 수 있음. |
| `std::array`  | 고정 크기 배열 (C-스타일 배열의 안전한 래퍼). | `.size()`                | 크기는 컴파일 타임에 결정됨.  |
| `std::string` | 문자열 컨테이너.                    | `.length()` 또는 `.size()` |                   |

#### 예시 (`std::vector`);
```cpp
#include <iostream>
#include <vector>

void process_vector(const std::vector<int>& vec) {
	// vector는 함수로 전달되어도 포인터로 변환되지 왆고,
	// 자신의 크기 정보를 유지함.
	size_t length = vec.size();
	std::cout << "Vector의 길이: " << length << std::endl;
}

int main() {
	std::vector<int> numbers = {1, 2, 3, 4, 5};
	
	process_vector(numbers);
	
	return 0;
}
```

결론적으로, 순수한 C-스타일 배열에서는 `sizeof` 연산자를 사용해야 하지만, 함수 경계를 넘어설 때는 길이 정보를 잃어버리므로, **STL 컨테이너를 사용** 하거나 **길이를 항상 함께 전달** 하는 것이 C++의 모범 사례임.