# 전처리 (Preprocessiong)
- 할 일: `#`으로 시작하는 지시어(`include`, `define`)을 처리.
- 소프트웨어: 단순히 텍스트를 치환하고 붙여넣는 작업.
- 하드웨어 연결점:
	- 레지스터 주소 정의: 임베디드 헤더 파일에는 `#define GPIOA_BASE 0x48000000` 같은 코드가 가득함. 전처리기가 이 매크로를 실제 주소 값으로 바꿔치기해 주기 때문에, 이후 단계에서 컴파일러가 "아, 이 주소에 값을 쓰라는 거구나"라고 알 수 있음.
	- 조건부 컴파일: `#ifdef STM32F4` 같은 코드를 통해, 하나의 소스 코드로 여러 하드웨어 칩을 지원하도록 코드를 껏다 켰다 할 수 있음.

# 컴파일 (Compilation)
- 할 일: C언어 소스를 **어셈블리어(Assembly)**로 번역. (`.c` -> `.s`)
- 소프트웨어: 문법 검사를 하고 최적화를 수행.
- 하드웨어 연걸점:
	- 아키텍쳐 결정: 여기서 컴파일러에게 **"타겟 CPU가 ARM Cortex-M4야"** 라고 알려줘야 함. 그래야 컴파일러가 x86(PC용) 명령어가 아닌, 해당 칩이 알아드는 전용 명령어 집합(Instruction Set)을 골라서 번역함.
	- 최적화와 `volatile`: 컴파일러는 똑똑해서 불필요해 보이는 메모리 접근을 삭제(최적화)하려 함. 앞서 배운 MMIO 변수에 `volatile`이 없다면, 컴파일러는 "이 변수는 아무도 안 쓰네?" 하고 하드웨오 제어 코드를 삭제해 버릴 수도 있음.

# 어셈블리 (Assembly)
- 할 일: 어셈블리어 코드를 기계어(Machine Code, 0과 1)로 바꿈. (`.s` -> `.o` 오브젝트 파일)
- 소프트웨어: 이제 사람이 읽을 수 없는 바이너리 파일이 됨.
- 하드웨어 연결점:
	- Opcode 매핑: `ADD R1, R2`라는 어셈블리 명령어가 `111000...` 같은 CPU 고유의 비트 패턴(Opcode)으로 1:1 변환됨. 이 비트들이 나중에 CPU의 명령어 디코더(Instruction Decoder)에 들어가 전시 신호를 만듬.

# 링킹 (Linking) - 임베디드의 핵심
- 할 일: 여러 개의 오브젝트 파일(`.o`)과 라이브러리를 합쳐 하나의 실핼 파일(`.elf`, `.hex`, `.bin`)을 만듬.
- 하드웨어 연결점: **"주소 할당(Address Binding)"** 이 여기서 일어남.
	- 링커 스크립트 (.ld 파일)의 마법: PC 프로그램은 운영체제가 알아서 빈 메모리에 프로그램을 올림. 하지만 임베디드는 **우리가 직접 "코드는 0x08000000(플래시 메모리)에 넣고, 변수는 0x20000000(SRAM)에 넣어라"라고 지정해줘야 함.** 이 역할을 하는 지도가 바로 **링커 스크립트**

---

# 프로그램이 실행되기까지 (Startup Code)
초보자가 가장 궁금해하는 것 중 하나는 **"전원을 켜면 어떻게 `main()` 함수가 실행되나요?"** 이다. 링킹 과정과 메모리 구조를 이해하면 답이 보임.

### "코드는 플래시에, 변수는 램에"
- Code (Text) & 상수 (ROData): **플래시 메모리(ROM))** 에 저장됨. 전원이 꺼져도 지워지면 안 되니까.
- 변수 (Data, BSS): **SRAM(RAM)** 에 이써야 함. 값을 읽고 써야 하니까.

### 딜레마와 해결 (Startup Code)
그런제 전역 변수 `int count = 10;`을 선언했다고 치자. 초기값 `10`은 프로그램이 꺼져 있을 때도 기억 되어야 하므로 플래시에 저장되어 있음. 하지만 `count` 변수 자체는 RAM에 있어야 값이 바뀔 수 있음.

누군가는 전원이 켜지자마자 **플래시에 있는 초기값 `10`을 RAM의 `count` 변수 위치로 복사** 해줘야 함.

이 일을 하는 비밀 요원이 바로 **스타트업 코드(Startup Code, 보통 assembly로 작성됨)**
1. Reset: 전원이 켜지면 CPU는 정해진 주소(Reset vector)로 가서 스타트업 코드를 실행.
2. Copy Data: 플래시에 저장된 초기화된 변수 값들(`.data` 영역)을 RAM으로 복사.
3. Zero BSS: 초기화되지 않은 변수 영역(`.bss`)을 RAM에서 모두 0으로 밈.
4. Call main(): 모든 준비가 끝나면 드디어 C언어의 `main()` 함수를 호출함.

> 결론: `main()` 함수 첫 줄이 실행되기 전에 이미 CPU는 수많은 메모리 복사 작업을 수행했음.

---

# 임베디드 C 프로그래머가 가져야 할 시각
이제 코드를 볼 때 다음처럼 보여야 함.
```c
#define SENSOR_REG (*(volatile int*)0x40001000) // 전처리: 0x40001000으로 치환

int g_data = 100; // .data 영역: 플래시에 저장되었다가 부팅 시 RAM으로 복사됨
int g_bss; // .bss 영역: 부팅 시 RAM에서 0으로 초기화됨

void main() { // .text 영역: 플래시 메모리에 기계어로 박제됨
	int local = 0; // Stack 영역: 함수 실행 시 RAM 스택 영역을 잠깐 씀
	
	SENSOR_REG = g_data + local;
	// 실행:
	// 1. RAM에서 g_data 값(100)을 레지스터로 Load
	// 2. Stack에서 local 값(0)을 레지스터로 Load
	// 3. ALU로 덧셈
	// 4. 결과를 0x40001000 주소(하드웨어)로 Store -> 센서 동작!
}
```

---

# 요약
지금까지 **하드웨어(CPU/메모리) -> 빌드 과정 -> 메모리 배치 -> 실행(Startup)** 까지의 흐름을 훑음.

다음 단계: **"임베디드 시스템의 제약 사항(적은 메모리, 실시간성)을 고려한 자료구조(배열, 연결 리스트, 큐, 스택)의 효율적인 구현과 선택 전략"**
