데이터는 어딘가에는 무조건 한 번은 생성이 되어야 한다.
"데이터의 소유권"과 "이동 경로"를 기준으로 정리.

#### 1. 값 전달(Pass-By-Value) vs 참조 전달(Pass-By-Reference)
가장 기본이 되는 구분. 데이터가 어떻게 '전달'되는지에 대한 방식.
- 값 전달 (Copy):
	- `memcpy`와 같은 원리. 원본 데이터와 똑 같은 데이터를 **다른 메모리 공간에 하나 더** 만듦.
	- 특징: 원본을 건드리지 않아 안전하지만, 데이터가 클수록 복사 비용(시간, 메모리)이 커짐.
- 참조 전달 (Reference):
	- 새로운 메모리를 할당하지 않음. 기존에 존재하던 데이터의 **주소(Address)** 만 알려줌.
	- 특징: 복사 비용이 거의 없지만, 함수 내부에서 원본 데이터를 수정할 수 있음.

#### 2. 복사(Copy) vs 이동(Move) vs 제로 카피(Zero-copy)
데이터가 이동할 때 "기존 데이터를 어떻게 처리하느냐"의 차이.
##### 복사(Copy)
- 원본은 그대로 두고 똑같은 것을 새로 만듦. (LValue 복사)

##### 이동(Move - `&&`, RValue Reference)
- C++11에서 도입된 핵심 개념. "임시 객체(Literal이나 연산 결과 등)"는 곧 사라질 운명인데, 이걸 굳이 복사하는 건 낭비라는 생각에서 출발.
- 원리: 새로 메모리를 할당하는 대신, **기존 데이터의 포인터(주소값)만 뺏어옮.** (얕은 복사 후 원본 포인터는 null 처리)
- "임시 객체를 생성 후 복사 전달하느냐?" -> 현대 C++에서는 이동을 통해 메모리 재할당 없이 소유권만 넘기는 방식을 주로 사용함.

##### 제로 카피(Zero-copy)
- 데이터가 한 곳(예: 커널 버퍼, 네트워크 카드)에서 다른 곳(예: 사용자 어플리케이션)으로 이동할 때, CPU가 데이터를 복사하는 과정 자체를 생략하는 기술.
- C++ 관점의 제로 카피: 객체를 만들 때부터 사용할 곳의 메모리에 직접 생성(Copy Elision, RVO)하거나, 메모리 맵핑(`mmap`)을 통해 여러 프로세스가 같은 메모리를 공유하는 방식.

#### 3. 리터럴(Literal)과 임시 객체
리터럴(예: `10`, `Hello`)도 메모리 어딘가에 존재해야 함.
- 문자열 리터럴: 보통 실행 파일의 `Data` 영역(Read-only)에 딱 한 번 박힘. 이걸 쓸 때는 해당 주소만 가져오거나(참조), `std::string` 객체로 만들 때 메모리에 복사해서 사용함.
- 정수 리터럴: CPU 명령어 안에 즉시값(Immediate value)으로 포함되거나 스택에서 바로 할당됨.

#### 4. 용어 매핑 테이블
| 구분    | 방식              | 메모리 할당         | 성능    | 비유                       |
| ----- | --------------- | -------------- | ----- | ------------------------ |
| 값 전달  | 복사 (Copy)       | 새로 할당함         | 낮음    | 서류를 복사기로 복사해서 줌          |
| 참조 전달 | 참조 (Reference)  | 할당 안 함(주소 공유)  | 높음    | 서류가 있는 위치(주소)만 알려줌       |
| 이동 전달 | 이동 (Move, `&&`) | 할당 안 함(소유권 이전) | 매우 높음 | 서류 뭉치를 통째로 건내줌 (난 이제 없음) |
| 제로 카피 | 직접 접근           | 최초 1회만 할당      | 최상    | 서류를 옮기지 않고 둘이서 같이 봄      |

> 요약:
> 1. 값(value)이 존재하려면 메모리는 최소 1번 할당되어야 함.
> 2. 그 값을 다른 곳으로 보낼 때, 똑같은 걸 하나 더 만들면 'Copy'
> 3. 그 값을 가리키는 주소만 넘기면 Reference
> 4. 쓰던 물건을 통째로 넘겨주고 손을 떼면 Move
> 5. 처음부터 남의 자리에 가서 물건을 두거나, 물건을 아예 안 움직이면 Zero-copy

