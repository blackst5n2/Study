C 소스 파일들이 **링킹(Linking)** 과정을 거쳐 `.text`, `.data`, `.bss` 등의 조각으로 나뉘어 **플래시 메모리**와 **RAM**에 배치됨. 이 배치의 **"설계도"** 이자 **"최종 보고서"** 가 바로 **링커 스크립트 파일 (`.ld` 또는 `.map` 파일)** 임.

이 파일을 볼 줄 알면 다음과 같은 질문에 답할 수 있음.
- "내가 짠 코드가 플래시 메모리 몇 번지에 들어갔지?"
- "내가 만든 전역 변수들이 RAM을 총 몇 바이트나 쓰고 있지?"
- "스택 메모리의 크기가 정말로 8KB인지, 그리고 힙 영역을 침범할 위험은 없는지?"
# 링커 스크립트(.ld)의 역할: 메모리 건축 설계도
링커 스크립트는 컴파일된 코드 조각(섹션)들을 하드웨어의 물리적 메모리 주소에 할당하는 규칙을 정의함.

### MEMORY 명령어: 물리적 메모리 정의
시스템이 가진 실제 메모리 영역을 정의함.
```
{
	FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K /* 코드 저장용, 읽기/실행 가능 */
	SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 64K /* 변수 저장용, 읽기/쓰기/실행 가능
	
}
```

- `ORIGIN`: 해당 메모리 영역이 **하드웨어적으로 시작하는 주소** 임. (예: 플래시는 0x08000000부터)
- `LENGTH`: 해당 영역의 총 용량임. (예: RAM은 64KB)

### SECTIONS 명령어: 코드 및 데이터 배치
어떤 코드 조각(Section)을 어디에 배치할지 정의함.
```
SECTIONS
{
	.text : { /* 코드를 배치하는 영역 */
		*(.text)
	} > FLASH /* 플래시 메모리에 저장하라 */
	
	.data : { /* 초기화된 전역 변수를 배치하는 영역 */
		*(.data)
	} > SRAM AT > FLASH /* FLASH에 저장했다가, 부팅 시 SRAM으로 복사하라 */
	
	.bss : { /* 0으로 초기화되는 전역 변수 배치 영역 */
		*(.bss)
	} > SRAM /* SRAM에 공간만 잡아두고, 부팅 시 0으로 채워라 */
}
```

- `AT > FLASH`의 의미: `.data` 영역은 초기값을 플래시 메모리(ROM)에 저장했다가, 실행을 위해 변수 자체는 RAM(`> SRAM`)으로 옮기라는 중요한 명령임.

# 맵 파일(.map)의 분석: 메모리 사용량의 최종 보고서
`.map` 파일은 링커가 작업을 마친 후, **"그래서 누가 어디에 얼마나 들어갔는지"** 를 정리해 놓은 최종 결과물임.

### 메모리 섹션 요약 확인 (Section Summary)
파일의 상단에서 플래시와 RAM의 총 사용량을 한눈에 볼 수 있음.

| Section | VMA (Virtual Address) | LMA (Load Address) | Size  | 내용              |
| ------- | --------------------- | ------------------ | ----- | --------------- |
| .text   | 0x08000000            | 0x08000000         | 12345 | 모든 함수 코드 (Code) |
| .rodata | 0x08003000            | 0x08003000         | 500   | 상수 (`const`)    |
| .data   | 0x20000000            | 0x08003500         | 800   | 초기화된 전역 변수      |
| .bss    | 0x20000320            | 0x20000320         | 1500  | 0으로 초기화되는 전역 변수 |

- VMA (Virtual Memory Address): 실행 시 이 코드가 RAM의 어디에 놓이는가? (CPU가 보는 주소)
- LMA (Load Memory Address): 저장 시 이 코드가 플래시의 어디에 놓이는가? (다운로드 주소)
- `.data`의 경우 VMA(RAM)와 LMA(FLASH)가 다른 것을 볼 수 있음. (부팅 시 복사 대상)

### 함수 및 변수의 주소 확인 (Symbol Table)
`.map` 파일의 가장 아래쪽에는 모든 함수와 변수의 상세 주소가 나열됨.
```
.text
0x08000000    0x100 main.o
0x08000018    0x48 motor.o
0x08000018    .L0 (ABS)
0x08000020    0x10 Motor_Init
...
.bss
0x20000320    0x4 g_sensor_handle
0x20000324    0x20 g_rx_buffer
```

- `Motor_Init` 함수가 플래시 **0x08000020** 에 정확히 `0x10` (16바이트) 크기로 배치되었음을 확인할 수 있음.
- `g_rx_buffer` 전역 변수가 RAM의 `0x20000324` 주소부터 **`0x20` (32바이트)** 를 차지하고 있음을 알 수 있음.

# 실전 활용: 메모리 경계 감시
가장 중요한 활용법은 **스택(Stack)** 과 **힙(Heap)** 영역이 서로 충돌하지 않도록 감시하는 것.

대부분의 링커 스크립트는 RAM의 가장 낮은 주소에 힙을 배칳고, 가장 높은 주소에 스택을 배치하여 서로 마주 보며 자라게 함.
1. 스택 영역 확인: `.map` 파일에서 `_stack_top` 심볼과 `_stack_bottom` 심볼을 찾아 스택의 물리적 범위를 확인함.
2. 힙 영역 확인: `_heap_start` 심볼과 `_heap_end` 심볼을 찾아 동적 할당 영역을 확인함.
3. 충돌 감시: 힙이 위로 자라고, 스택이 아래로 자라면서 중간에 남은 여유 공간(Free Space)이 얼마나 되는지 계산할 수 있음.

	프로그래머의 역할: `.map` 파일에서 `g_rx_buffer` 같은 큰 전역 변수가 스택과 힙 영역의 경계에 붙어 있는지 확인하여, 스택 오버플로우가 힙으로 인한 것이 아닌지 미리 예측하고 설계할 수 있음.

# 최종 정리
1. CPU/버스: 속도와 대역폭의 한계 이해
2. 메모리/스택: 데이터 배치 및 함수 호출 비용 이해
3. 언어 원리: C/C++ 코드가 기계어로 변환되는 과정 이해
4. 링커 분석: 메모리 사용량과 배치를 최종적으로 검증
