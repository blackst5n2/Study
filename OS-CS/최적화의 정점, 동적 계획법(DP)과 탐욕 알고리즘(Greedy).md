**'최적의 해법 설계 방법론'** 인 **동적 계획법(Dynamic Programming, DP)** 과 **탐욕 알고리(Greedy Algorithm)** 을 심도 있게 다르겠음.

이 두 방법론은 복잡한 문제에 직면했을 때, 단순히 모든 경우의 수를 따지는 것이 아니라 **가장 효율적인 의사결정** 을 내리는 논리적 프레임워크를 제공함.

# 탐욕 알고리즘 (Greedy Algorithm)
**탐욕 알고리즘** 은 전체 문제에 대한 최종적인 최적 해를 찾기 위해, **각 단계마다 지금 당장 가장 최적인 선택** 을 하는 방식임.

#### 원리와 동작
- 특징: 미래를 고려하지 않고 **현재 시점** 에서 가장 유리한 선택만을 함.
- 적용 조건:
	1. 탐욕적 선택 속성 (Greedy Choice Property): 전체 문제의 최적 해가 국소적인 최적 선택을 포함해야 함.
	2. 최적 부분 구조 (Optimal Substructure): 문제의 최적 해가 부분 문제의 최적 해로 구성되어야 함.
- 주의점: 위의 두 가지 속성을 **만족할 때만** 탐욕 알고리즘이 **전역적인 최적 해(Global Optimum)** 를 보장함. 만족하지 못할 경우 잘못된 결과가 나올 수 있음.

#### 시스템 및 문제 해결 연결
- 예시 1: 거스름돈 문제: 가장 큰 단위의 화폐부터 먼저 거슬러 주는 방식 (이는 탐욕적 선택이 최적 해를 보장하는 대표적인 예).
- 예시 2: 최소 비용 신장 트리 (MST): Prim이나 Kruskal 알고리즘은 현재 연결 가능한 간선 중 가장 저렴한 비용을 가진 간선을 선택하는 탐욕적인 방식을 사용하며, 이는 최적 해를 보장함.

# 동적 계획법 (Dynamic Programming, DP)
**동적 계획법** 은 문제가 **부분 문제의 최적 해** 로 구성될 때, **중복되는 계산을 피하고** 체계적으로 전체 문제의 최적 해를 찾는 방법론.

#### 원리와 동작
- 핵심: '동적'이라는 말은 시간 경과에 따라 변한다는 의미가 아니라, **'표(Table)'** 에 결과를 저장해 **재활용** 한다는 의미에 가까움.
- 특징:
	1. 최적 부분 구조 (Optimal Substructure): 탐욕 알고리즘과 마찬가지로, 큰 문제의 최적 해가 작은 문제의 최적 해로 구성되어야 함.
	2. 중복되는 부분 문제 (Overlapping Subproblems): 작은 부분 문제가 반복적으로 나타나야 함. DP는 이 중복 계산을 표에 저장된 값을 참조하여 $O(1)$로 줄임.

#### DP의 구현 방식
1. Memoization (하향식, Top-Down): 재귀 함수를 사용하되, 한 번 계산한 결과를 **메모리(배열, 해시 테이블)** 에 저장(Memo)해 두고 필요할 때 재활용함. (자연스럽지만 함수 호출 오버헤드 존재)
2. Tabulation (상향식, Bottom-Up): 가장 작은 부분 문제에서 시작하여 그 결과를 표에 채워 넣고, 이 표를 이용하여 점진적으로 큰 문제를 해결함. (함수 호출 없이 효율적)

#### 시스템 및 문제 해결 연결
- 예시 1: 피보나치 수열: $F(5)$를 계산할 때 $F(3)$과 $F(4)$가 필요하고, $F(4)$를 계산할 때 $F(3)$이 다시 필요함. DP는 $F(3)$을 **한 번만 계산** 하고 저장함.
- 예시 2: **최장 공통 부분 수열 (LCS, Longest Common Subsequence):** 두 문자열의 유사도를 측정하는 데 사용되며, **파일 비교(Diff) 프로그램** 이나 **유전자 분석** 의 핵심 알고리즘임. DP 테이블을 사용하여 최적의 일치 경로를 찾음. 
- 시스템 최적화: 복잡한 자원 할당이나 경로 최적화 문제에서 **가장 효율적인 자원 배분** 을 결정하는 데 사용됨.

# 최종적인 지식 통합
유기적 연결성
- 알고리즘 선택: 문제가 '최단 경로'라면 -> Dijksta/A* 선택.
- 자료구조 선택: '빠른 검색'이 필요하면 -> 해시 테이블 또는 B-Tree(디스크) 선택.
- 성능 분석: 선택한 알고리즘의 복잡도는 -> $O(\log N)$ 인가?
- 시스템 통합: 이 코드는 OS의 커널 모드에서 실행되어야 하는가? -> 시스템 호출 설계 필요.
- 하드웨어 영향: 이 데이터 접근 패턴은 -> CPU 캐시의 효율을 높일 것인가?
