'파일' 아이콘 뒤에는 **정교한 데이터베이스 구조** 가 숨어 있음. 이 구조를 이해하면 "파일을 삭제해도  왜 복구가 가능한?" (디지털 포렌슥의 원리)를 명확히 알게 됨.

# 저장 장치의 물리적 단위: 섹터와 블록
하드디스크나 SSD는 데이터르 바이트 단위로 읽지 않음. 덩어리 단위로 다룸.
- 섹터 (Sector): 하드디스크의 물리적인 최소 단위 (보통 512B).
- 블록 (Block): OS(파일 시스템)가 관리하는 논리적인 최소 단위 (보통 4KB).
	- 원리: 파일에 글자 `A` 하나만 써도(1바이트), 디스크에서는 4KB(4096바이트) 블록 하나를 통째로 차지함. (이때 남는 공간을 Slack Space라고 하며, 여기에 범죄 데이터가 숨겨지기도 함..)

# 리눅스 파일 시스템의 핵심: Inode (Index Node)
리눅스(유닉스) 계열 파일 시스템(EXT4 등)에서 **"파일의 정체"** 는 이름이 아니라 Inode 번호임.

#### Inode가 담고 있는 것 (메타데이터)
Inode는 파일의 신분증이자 설계도임. 파일 하나당 Inode 하나가 배정됨.
- 정보: 파일 소유자, 권한(rwx), 파일 크기, 생성/수정 시간.
- 위치 정보 (중요): 실제 데이터가 저장된 데이터 블록의 주소들을 가리키는 포인터.

#### Inode에 없는 것: "파일 이름"
놀랍게도 Inode에는 **파일 이름** 이 없음. 그렇다면 이름은 어디에 있을까?

#### 디렉토리(Directory)의 진실
디렉토리도 사실은 **특수한 파일** 임. 이 파일 안에는 **"파일 이름 : Inode 번호"** 로 이루어진 명단(Table)이 들어있음.
	과정: 우리가 `/home/user/hello.txt`를 읽으려 하면?
	1. `/` (루트) 디렉터리 파일을 뒤져서 `home`이라는 이름의 Inode 번호를 찾음.
	2. 그 Inode로 가서 `home` 디렉터리 내용을 읽음
	3. 거기서 `user`의 Inode 번호를 찾음... (반복)
	4. 최종적으로 `hello.txt`의 Inode를 찾고, 그 안의 **데이터 블록 포인터** 를 따라가 실제 내용을 읽음.

#### 삭제의 진실: 포렌식 복구의 원리
우리가 `rm file.txt` 명령을 내리거나 휴지통을 비울 떄, OS는 무슨 짓을 할까?

#### OS가 하는 일 (빠른 삭제)
OS는 1GB짜리 영화 파일을 지울 때 데이터를 전부 0으로 덮어쓰지 않음. (그랬다간 삭제에 몇 초가 걸릴 것.)
1. 링크 해제: 디렉터리 파일에서 `file.txt : Inode#1234` 라는 **연결 고리(Link)** 만 지움.
2. Bitmap 갱신: Inode 테이블과 블록 비트맵(Free List)에서 "Inode#1234와 관련 데이터 블록들은 이제 **사용 가능(Free)** 함"이라고 표시만 바꿈.

#### 결과 (데이터 잔존)
실제 디스크 섹터에는 **데이터가 그대로 남아 있음.
- 포렌식의 원리: 복구 프로그램은 파일 시스템의 정상적인 경로(디렉터리)를 통하지 않고, **디스크의 모든 섹터를 직접 읽음(Raw Read).** 그러다가 "이건 JPG 파일 헤더네?" 같은 패턴을 발견하면 그 뒤의 데이터를 긁어모아 파일을 살려냄. (이를 **File Carving** 이라고 함.)

	완전 삭제(Wiping): 복구를 막으려면 데이터를 지우는 게 아니라, 무작위 데이터로 **덮어쓰기(Overwrite)** 를 여러 번 수행해야 함.

# 임베디드 파일 시스템의 차이
임베디드에서는 PC용 파일 시스템(EXT4, NTFS)이 너무 무거워서 전용 파일 시스템을 씀.

| 파일 시스템           | 특징                                                                                  | 사용처                      |
| ---------------- | ----------------------------------------------------------------------------------- | ------------------------ |
| FAT32 / exFAT    | 구조가 단순하고 호환성이 좋음. 하지만 전원이 갑자기 꺼지면 데이터가 잘 깨짐.                                        | SD 카드, USB 메모리           |
| LittleFS / JFF32 | Flash Memory 전용. 데이터를 덮어쓸 때 한 곳만 닳지 않도록 골고루 분산(Wear Leveling)해 줌. 전원이 나가도 데이터가 안전함. | IoT 기기 내장 Flash, 공유기 펌웨어 |
