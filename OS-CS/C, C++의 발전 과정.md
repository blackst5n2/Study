임베디드 엔지니어의 시작에서 C와 C++의 발전 과정과 그 작동 원리를 심층 분석

# C언어의 탄생 (1972): "이식성 있는 어셈블리어"
데니스 리치(Dennis Ritchie)가 유닉스(Unix) 운영체제를 만들기 위해 개발.
- 이전의 문제: 당시엔 컴퓨터마다 어셈블리어가 달랐음. 하드웨어가 바뀌면 코드를 전부 다시 짜야 했음.
- C의 해결책: "하드웨어를 제어할수 있으면서도, 사람 말에 가까운 언어를 만들자."
- 작동 원리 (임베디드 관점):
	- C언어는 '추상화(Abstraction)'가 거의 없음.
	- C코드 한 줄은 거의 정확하게 어셈블리 명령어 몇 줄로 변환됨.
	- 메모리 직접 접근: 포인터(`*`)라는 강력한 도구를 줘서, 프로그래머가 메모리 주소를 직접 주무를 수 있게 했음 .(어셈블리어의 간접 주소 지정 방식을 그대로 가져옴.)

		핵심: C언어는 컴파일러가 "너 알아서 해, 난 말리지 않을게"라는 태도를 취함. 그래서 임베디드에서 하드웨어를 극한으로 제어하기에 가장 적함함.
# C++의 등장 (1983): "복잡도를 관리하라"
C언어로 짠 코드가 수만 줄이 넘어가자, 소스 코드가 너무 복잡해져서 유지보수가 불가능해짐. (스파게티 코드). 비야네 스트롭스트룹(Bjarne Stroustrup)은 C언어에 **"체계(Class)"** 를 도입했음. 초기 이름이 **"C with Classes"** 였던 이유임.
- 철학: Zero Overhead Principle (무비용 추상화 원칙)
	- "네가 쓰지 않는 기능에는 비용(메모리, 속도)을 청구하지 않는다."
	- "네가 쓰는 기능이라도, 네가 손으로 짠 어셈블리어보다 느려서는 안 된다."
- 임베디드에서의 오해: "C++은 무섭고 느리다?" -> 반은 맞고 반은 틀림.
	- 잘못 쓰면(무분별한 `virtual`, `exception`, `RTTI`) 느려짐.
	- 잘 쓰면 C와 속도는 똑같은데 코드는 훨씬 깔끔함.

# 작동 원리 심층 해부: C vs C++
임베디드 프로그래머는 C++의 문법이 하드웨어적으로 어떻게 변환되는지 **'번역기'** 를 눈에 달고 있어야 함.

## 클래스(Class)는 사실 구조체(Struct)다
C++의 `class`를 컴파일하면, 메모리 상에서는 C언어의 `struct`와 똑같이 변수들만 나란히 저장됨. 함수는 어디로?

## 멤버 함수와 `this` 포인터의 비밀
C++ 코드:
```c
class Motor {
	int speed;
	void setSpeed(int s) { speed = s; }
};
Motor m;
m.setSpeed(100);
```
실제 컴파일러가 변환한 C 스타일 코드 (하드웨어 동작):
```c
struct Motor { int speed; }; // 데이터만 있음

// 함수는 사실 전역 함수로 빠져나와 있음
// 첫 번째 인자로 '객체의 주소(this'를 몰래 받음
void Motor_setSpeed(Motor* this, int s) {
	this->speed = s;
} 

Motor m;
Motor_setSpeed(&m, 100); // 호출할 때 주소를 넘김
```

>	결론: 멤버 함수 호출은 마법이 아니라, **"구조체 포인터를 인자로 받는 일반 함수 호출"** 일 뿐임. 오버헤드가 0임.

# 가상 함수(Virtual Function)의 비용
임베디드에서 주의해야 할 부분임. `virtual` 키워드를 쓰면 **다형성(Polymorpism)** 이 생기지만, 하드웨어 비용이 발생함.
1. 공간 비용: 객체마다 `vptr`이라는 4바이트(32bit 시스템) 포인터 변수가 몰래 추가됨.
2. 시간 비용: 함수를 호출할 때 "주소를 찾아서 -> 점프"하는 두 단계를 거침. (일반 함수보다 아주 조금 느림).
- C 스타일 (런타임 계산):
	```c
	#define FACTORIAL(n) ... // 매크로는 디버깅이 힘듦
	int val = factorial(5); // CPU가 런타임에 곱셈 연산 수행 (전력 소모)
	```
- Modern C++ (컴파일 타임):
```cpp
constexpr int factorial(int n ) { ... }
constexpr int val - factorial(5);
// 컴파일러가 계산해서 '120'이라는 숫자만 바이너리에 넣음.
// CPU는 아무 연산도 안 함. -> 속도 무한대, 전력 소모 0.
```

# 로드맵
하드웨어 지식 위에 언어의 원리를 얹는 순서
1. C언어의 하드웨어적 본질:
	- 포인터와 배열의 메모리 레이아웃 완벽 분해.
	- `volatile`, `const`, `static` 키워드가 메모리(Data/BSS/Stack)와 최적화에 미치는 영향.
	- 함수 호출 규약 (Calling Convention): 인자가 레지스터(R0~R3)와 스택을 통해 어떻게 전달되는지.
2. 임베디드 C++의 핵심 패턴:
	- 생성자/.소멸자를 이용한 RAII 패턴 (자원 관리 자동화 - `mutex` 잠금/해제 실수 방지).
	- `template`을 이용한 하드웨어 레지스터 제어 (코드 크기를 늘리지 않으면서 타입 안전성 확보).
	- C++에서 C 코드 호출하기 (`extern "C"`).

## 요약
"C와 C++의 발전 과정과 작동 원리"
- C: 하드웨어 그 자체를 기술하는 언어
- C++: 하드웨어 제어 코드를 안전하고 깔끔하게 구조화하는 도구.
- Modern C++: 런타임 성능 저하 없이 컴파일러에게 일을 시키는 기술.
