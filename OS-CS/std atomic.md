#### Atomic 연산의 본질: "단일성"과 "가시성"
`std::atomic`은 단순히 커널 명령어를 쓰는 것을 넘어, CPU 하드웨어의 캐시 일관성 프로토콜을 직접 제어함.
- Atomicity (단일성): `a = a + 1`을 할 때, 읽고-더하고-쓰는 과정 중간에 다른 스레드가 끼어들지 못 하게 한 번에 처리함.
- Visibility (가시성): CPU가 1번 코어에서 바꾼 값이 즉시 다른 코어의 캐시에도 반영되도록 보장함.

#### Memory Order (메모리 주문)
현대의 CPU와 컴파일러는 성능을 위해 코드의 실행 순서를 바꿈(Reordering). `memory order`는 그 "제멋대로 순서 바꾸기"를 어디까지 허용할지 정하는 가이드.

##### 1. `memory_order_relaxed` (가장 빠름)
- 의미: "순서 상관없이, 그냥 이 연산만 원자적으로 처리해줘."
- 특징: 주변 코드들의 순서가 뒤섞일 수 있음.
- 용도: 다른 데이터와 상관없이 단순한 숫자만 올리는 통계용 카운터 등에 씀.

###### 2. `memory_order_release` & `acquire`
이 둘은 언제나 짝꿍으로 움직이며, 스레드 간에 **데이터의 완성** 을 알리는 신호등 역할을 함.
- `release` (생산자): "내가 방금 쓴 데이터 위쪽의 모든 메모리 쓰기 작업이 완료되었음을 보장해라. 이 atomic 연산이 실행되기 전에 이전 코드들이 밑으로 내려가지 못하게 막아!"
- `acquire` (소비자): "방금 읽은 이 atomic 변수 이후의 모든 메모리 읽기 작업은, 반드시 이 변수를 읽은 후에 실행되어야 해. 밑에 있는 이 코드를 위로 올라가지 못하게 막아."
- 결과: Producer가 `release`로 밀어넣고 Consumer가 `acquire`로 읽으면, 그 atomic 변수 주위에 있던 일반 데이터들도 완벽하게 동기화됨.

##### 3. `memory_order_seq_set` (기본값, 가장 느림)
- 모든 스레드에서 모든 연산이 동일한 순서로 일어나는 것을 보장함. 가장 안전하지만 가장 느림.

#### `compare_exchange_weak` (CAS) 연산
락프리 구조의 심장. **"만약 값이 내가 예상한 것과 같다면 새로운 값으로 바꿔라"** 라는 명령.
```cpp
bool success = atomic_var.compare_exchange_weak(expected, desired);
```
1. `atomic_var`의 현재 값이 `expcted`와 같은지 확인함.
2. 같다면: `desired`로 값을 바꾸고 `true`를 반환함.
3. 다르다면: 누군가 그새 값을 바꾼 것이므로, `expected`를 현재의 `atomic_var` 값으로 업데이트하고 `false`를 반환함.
- 왜 `weak`인가? 하드웨어 사정상(특히 ARM/Apple Silicon) 실제로 값이 같은데도 가끔 실패할 수 있음. 그래서 보통 `while` 루프 안에서 성공할 때까지 반복해서 씀. 성능상 `strong`보다 유리할 때까 많음.

# 요약
- `relaxed`: "나만 건드려, 순서는 몰라" (단순 카운터)
- `release`: "내가 다 준비해놨어, 이제 문 열게!" (데이터 밀어넣기 끝)
- `acquire`: "문 열렸네? 이제 들어가서 데이터 가져올게!" (데이터 가져오기 시작)
- `CAS`: "내가 본 값이 그 값이면 내가 찜한 값으로 바꿔줘!" (순서 뺏기 방지)

> 이 메모리 오더를 정확히 쓰면 CPU가 불필요하게 캐시를 비우지 않아도 되기 때문에, 락을 쓰는 것보다 수십 배 빠른 성능을 낼 수 있음.