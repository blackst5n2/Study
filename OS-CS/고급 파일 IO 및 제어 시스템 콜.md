이 시스템 콜들은 파일의 **메타데이터 관리, 데이터 무결서(Integrity) 보장, 그리고 **파일디스크립터 제어** 에 중점을 둠.

#### 파일 상태 및 메타데이터 확인: `stat`, `fstat`
보안 관리의 첫걸음은 접근하려는 대상 파일의 **상태(Metadata)** 를 정확히 아는 것.

| 함수      | 기능                                            | 시그니처                                                |
| ------- | --------------------------------------------- | --------------------------------------------------- |
| `stat`  | 파일 **경로(Pathname)** 를 기준으로 파일의 상태 정보를 읽어옴.    | `int stat(const char *pathname, struct stat *buf);` |
| `fstat` | 열여 있는 **파일 디스크립터(fd)** 를 기준으로 파일의 상태 정보를 읽어옴. | `int fstat(int fd, struct stat *buf);`              |

#### `struct stat`의 주요 정보 (보안 및 구현 관련)
`struct stat` 구조체에는 파일의 상세 정보가 포함되어 있음.
- `st_mode`: 파일 타입(일반 파일, 디렉토리, 심볼릭 링크 등)과 **파일 접근 권한(Permission)** 정보. (구현 시 사용자가 파일에 적절한 권한을 가지고 있는지 확인하는 데 필수적)
- `st_uid`, `st_gid`: 파일 소유자의 사용자 ID와 그룹 ID.
- `st_size`: 파일의 크기(바이트 단위).
- `st_atime`, `st_mtime`, `st_ctime`: 파일 접근 시간, 수정 시간, 상태 변경 시간.

##### 구현 관점: `open()`을 하기 전에 `stat()`을 호출하여 권한을 미리 확인하거나, 파일이 예상된 타입인지 (예: 디렉토리나 장치 파일이 아닌지) 검사하는데 유용함.

#### 데이터 무결성 보장: `fsync`, `fdatasync`, `sync`
`write()` 시스템 콜이 성공하더라도 ㄷ데이터는 커널의 페이지 캐시(Page Cache)에만 기록되고 디스크에는 즉시 저장되지 않을 수 있음. **(지연된 쓰기)**. 시스템 충돌 시 데이터 손실을 방지하려면 캐시에 데이터를 디스크로 강제 동기화해야 함.

| 함수          | 기능                                                                                                          | 시그니처                     |
| ----------- | ----------------------------------------------------------------------------------------------------------- | ------------------------ |
| `sync`      | 모든 파일 시스템의 버퍼링된 데이터를 디스크에 기록하도록 예약함. (전역 동기화)                                                               | `void sync(void);`       |
| `fsync`     | 특정 **파일 디스크립터(fd)** 에 연결된 데이터와 **메타데이터** 를 디스크에 강제로 기록할 때까지 호출자를 블로킹(Blocking)함.                            | `int fsync(int fd);`     |
| `fdatasync` | `fsync`와 유사하지만, 파일의 내용(데이터)만 동기화하고, 파일 크기 변경 등 **필수적인 메타데이터** 만 동기화함. 불필요한 메타데이터 동기화를 건너뛰어 성능상 이점을 얻을 수 있음. | `int fdatasync(int fd);` |

##### 구현 관점: 트랜잭션 시스템이나 데이터베이스처럼 **데이터의 영속성(Durability)** 이 절대적으로 중요한 경우, `write()` 호출 후 반드시 `fsync()`나 `fdatasync()`를 호출해야 함.

#### 파일 디스크립터 복제 및 제어: `dup`, `dup2`, `fcntl`

##### `dup` 및 `dup2` (복제)
이 시스템 콜은 기존의 파일 디스크립터를 복제함. 이는 I/O 리다이렉션(Redirection)을 구현하는 핵심 메커니즘임.

| 함수     | 기능                                                                                | 시그니처                             |
| ------ | --------------------------------------------------------------------------------- | -------------------------------- |
| `dup`  | `oldfd`와 동일한 파일을 참조하는 새로운 `fd`를 반환함. 이 새로운 `fd`는 가장 낮은 사용 가능한 숫자로 할당됨.            | `int dup(int oldfd);`            |
| `dup2` | `oldfd`와 동일한 파일을 참조하는 새로운 `fd`를 `newfd`라는 특정 번호로 할당함. 만약 `newfd`가 이미 열려있다면 먼저 닫음. | `int dup2(int oldfd, int newfd)` |

##### 구현 관점: 쉘(Shell)의 `ls > output.txt`와 같은 리다이렉션을 구현할 때, 파일(output.txt)을 연 후 `dup2(file_fd, 1)`을 호출하여 표준 출력(fd 1)을 해당 파일로 연결하는 방식으로 사용됨.
- `int fcntl(int fd, int cmd, ... /* arg */);`
#### 주요 기능 (cmd)

| `cmd`                            | 기능                                                                               |
| -------------------------------- | -------------------------------------------------------------------------------- |
| `F_GETFL`                        | `fd`의 파일 상태 플래그(예: `O_APPEND`, `O_NONBLOCK` 등)를 가져옴.                             |
| `F_SETFL`                        | `fd`의 파일 상태 플래그를 변경함. (예: 실행 중 `O_NONBLOCK`을 추가하여 논블로킹 I/O로 전환)                  |
| `F_GETLK`, `F_SETLK`, `F_SETLKW` | 파일 잠금(File Locking)을 설정하거나 해제하는 데 사용됨. (다중 프로세스 환경에서 데이터 동시 접근을 제어하는 핵심 보안 메커니즘) |

##### 구현 관점: 멀티스레드/멀티프로세스 환경에서 특정 파일 영역을 안전하게 일고 쓰기 위해 파일 잠금 (`F_SETLKW` 등)은 필수적인 보안 기능임. 또한, `read`/`write`의 동작 방식을 동적으로 변경할 때 사용됨.

# 고려해야 할 보안 사항
저수준 I/O를 직접 구현할 때 가장 위험한 두 가지 요소는 **메모리 오버플로우** 와 **경쟁 상태(Race Condition)** 임.
1. 경쟁 상태(Time-of-Check-to-Time-of-Use, TOCTTOU);
	- `stat()`을 통해 파일의 권한을 확인하고(Check), 그 후에 `open()`을 호출하는 (Use) 사이에, 다른 프로스세가 파일의 속성을 변경할 수 있음.
	- 대응: 가능하면 `open()` 시스템 콜의 플래그(예: `0_EXCL`)를 활용하여 원자적인(Atomic) 동작을 유도하고, 권한 확인과 파일 열기를 분리하지 않고 한 번에 처리하는 것이 가장 안전함.
2. 버퍼 관리 (Memory Safety):
	- `read()`나 `write()`를 사용할 때, 사용자 버퍼(`buf`)의 크기(`count`)를 벗어나는 데이터 접근을 시도하면 **버퍼 오버플로우** 가 발생하여 보안 취약점(예: 임의 코드 실행)이 될 수 있음.
	- 대응: `count` 인자가 버퍼의 실제 할당 크기를 초과하지 않도록 **포인터 연산과 크기 검증** 을 철저히 해야 함.
