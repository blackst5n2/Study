**디버거 없이도 머릿속을 메모리 덤프(Memory Dump)를 그릴 수 있는 경지로 가기 위한 필수 과정.

1. C언어의 메모리 모델과 포인터의 진실
2. 키워드(`static`, `volatile`, `const`)의 하드웨어적 의미
3. C++ 객체지향의 물리적 비용과 구조

# C언어: 포인터는 '수학'이다
초보자는 포인터를 "화살표"라고 생각하지만, 임베디드 프로그래머는 포인터를 **"데이터 타입의 크기를 곱하는 덧셈 연산"** 으로 이해해야 함.

## 포인터 연산의 물리적 의미
C언어에서 `int *p`가 있고 `p + 1`을 했을 때, 실제 주소값이 `1`이 증가하는 게 아니라는 것.
$$Physical Address = Base Address + (Index \times sizeof(Type)$$
- 하드웨어 관점: CPU는 메모리 주소를 바이트 단위로 셈.
- 컴파일러 관점: `int *p` (32비트 CPU 기준 4바이트)에서 `p+1`은 **"다음 int가 있는 곳으로 가라"** 는 뜻이므로, 실제 주소는 **4가 증가**

```c
int *p = (int*)0x1000; // p는 0x1000 번지를 가리킴
p++; // p는 이제 0x1004 번지를 가리킴 (0x1001이 아님!)
char *c = (char*)0x1000;
c++; // c는 이제 0x1001 번지를 가리킴
```

임베디드 주의점: `void *` 포인터는 크기 정보가 없어서 산술 연산(`+`, `-`)이 불가능하거나 컴파일러마다 동작이 다름(보통 1바이트 취급). 따라서 주소 계산을 할 떄는 반드시 `uint8_t *` 등으로 캐스팅해서 **"나는 1바이트 단위로 움직이겠다"** 고 명시해야 안전함.

## 배열과 포인터의 미묘한 차이 (Decay)
`int arr[10];`을 선언하면 컴파일러는 **"심볼 테이블(Symbol Table)"** 에 `arr`라는 이름을 등록하고, 이것을 메모리 주소(상수)로 매핑함.
- `arr` (배열 이름): 그 자체로 메모리의 시작 주소를 나타내는 **상수(Constant)** 임. 바꿀 수 없음 (`arr++` 불가능)
- `int *p = arr;` (포인터 변수): 주소 값을 저장하는 **변수(Variable)** 임. 바꿀 수 있음.(`p++` 가능)

# 키워드: 컴파일러에게 내리는 지시서
C언어의 핵심 키워드들은 하드웨어 배치와 최적화에 직접적인 영향을 줌.

### `static`: 수명(Lifetime)과 범위(Scope)의 마법
임베디드 C 코드에서 `static`은 두 가지 전혀 다른 의미로 쓰임. 이걸 혼동하면 안 됨.
- 함수 내부의 static (`static int count;`):
	- 의미: "함수가 끝나도 죽지 마라."
	- 메모리: 스택(Stack)이 아닌 **데이터 영역(.data 또는 .bss)** 에 저장됨. 전역 변수처럼 프로그램 시작부터 끝까지 살아있찌만, 이름만 함수 내부에 갇혀 있음.
- 함수 외부의 static (`static void helper();`):
	- 의미: "이 파일(.c) 밖에서는 나를 부르지 마라." (캡슐화)
	- 링킹: 심볼 테이블에서 이 함수의 이름을 지워버림(혹은 로컬로 표시). 다른 파일에서 `extern`으로 아무리 찾아도 못 찾음. 이를 **내부 연결(Internal Linkage)** 라고 함.
	- Tip: 임베디드 라이브러리를 짤 때, 외부에서 건드리면 안 되는 내부 함수는 무조건 `static`을 붙여야 충돌을 방지할 수 있음.

### `const`: Flash냐 RAM이냐? 
- `const int a = 10;`
- PC: 그냥 "읽기 전용" 이라고 표시하고 RAM에 둠.
- 임베디드: 컴파일러와 링커 설정에 따라 **플래시 메모리(ROData)** 에 박제될 수 있음.
	- 장점: RAM을 아낄 수 있음.
	- 주의: 포인터로 강제 형변환해서 값을 바꾸려 하면, 플래시는 하드웨어적으로 쓰기가 막혀있거나 별도의 시퀀스가 필요하므로 **하드웨어 오류(Hard Fault)** 가 발생해 시스템이 뻗을 수 있음.

### `volatile`: "최적화 금지" (가장 중요)
컴파일러는 매우 똑똑해서 "쓸데없는 짓"을 안 하려고 함.
```c
// [상황] 0x4000 번지가 버튼 상태 레지스터라고 가정
int *button = (int *)0x4000;

while (*button == 0) {
	// 버튼이 눌릴 때까지 대기
}
```
- 컴파일러의 생각: "어? `*button` 값은 루프 안에서 아무도 안 바꾸네? 그럼 처음에 한 번만 읽고 계속 0이라고 생각해야지." (무한 루프에 빠짐)
- 해결: `volatile int *button`으로 선언.
	- 의미: "야 컴파일러야, 이 값은 네가 모르는 사이(하드웨어적)에 바뀔 수 있으니까, 캐시 쓰지 말고 매번 실제 메모리 주소 가서 다시 읽어와!"

# 함수 호출 규약 (Calling Convention): AAPCS
"함수를 호출한다"는 것은 CPU 입장에서 엄청난 중노동임. ARM 아키텍쳐(AAPCS) 기준으로 설명.

1. 인자 전달 (R0 ~ R3): 함수 인자가 4개 이하일 때는 스택 메모리를 안 쓰고 CPU 레지스터 R0, R1, R2, R3에 값을 넣어서 보냄. (엄청 빠름)
2. 인자가 많으면 (Stack): 5번째 인자부터는 스택 메모리에 쌓음. (느려짐, 메모리 접근 발생)
3. 복귀 주소 (LR): 함수가 끝나고 돌아갈 주소를 **(Link Register)** 에 저장하고 점프함. 
4. 리턴 값 (R0): 함수의 실행 결과(`return val;`)는 R0 레지스터에 담아옴.

	 임베디드 최적화 팁: 함수의 인자 개수는 **4개 이하** 로 유지하는 것이 성능상 유리함. 구조체 포인터를 넘기는 이유가 바로 이것.

# C++의 하드웨어적 실체
까보면 C와 다를 게 없음.

### 클래스(Class) = 구조체(Struct) + `this`
```cpp
class Sensor {
	int id;
	void read(int mode);
};
```
이 코드는 컴파일러에 의해 아래와 같이 변신함.
```c
struct Sensor { int id; }; // 1. 데이터만 남음

// 2. 함수는 이름이 바뀌고 (Name Mangling), 첫 인자로 'this'가 추가됨
void Sensor_read(Sensor* const this, int mode) {
	// this->od 로 접근
}
```
- 비용: 클래스를 쓴다고 해서 메모리가 더 들거나 속도가 느려지지 않음. **완벽하게 C와 동일**

### 생성자와 소멸자 (Constructor & Destructor)
- 객체를 선언하는 순간(`Sensor s;`), 컴파일러는 그 자리에 자동으로 `Sensor_init(&s)` 같은 초기화 함수를 끼워 넣음.
- 변수 범위를 벗어날 때(`}`), 자동으로 `Sensor_deinit(&s)`를 호출함.
- 주의: 전역 객체(Global Object)의 생성자는 `main()` 함수가 시작되기도 전에 스타트업 코드에서 호출됨. 이때 하드웨어 초기화가 안 되어 있다면 시스템이 멈출 수 있음.

### 가상 함수(Virtual Function)의 비용: vtable
`virtual` 키워드는 **"실행 중에 어떤 함수를 부를지 결정(Dynamic Dispatch)"** 하게 만듦.
- 구조: 클래스 내부에 `vptr`이라는 숨겨진 포인터가 생김. 이 포인터는 함수들의 주소 목록이 적힌 **가상 함수 테이블(vtable)** 을 가리킴.
- 비용:
	- 메모리: 객체마다 4바이트(`vptr`) 추가 + 클래스마다 테이블 용량 추가.
	- 속도: 함수 호출 시 `vptr` -> `vtable` -> `진짜 함수 주소` 순으로 **두 번 참조(Indirection)** 가 일어남.
- 결론: 아주 빡빡한 리얼타임 루프가 아니라면 써도 무방함. 수백만 번 반복되는 루프 안에서는 피하기.

# 템플릿(Template) vs 매크로(Macro)
임베디드에서 C++을 쓰는 가장 큰 이유 중 하나는 **템플릿** 임.
- C 매크로: `#define MAX(a, b) ((a)>(b)?(a):(b))`
	- 단순 텍스트 치환. 타입 체크를 안 해서 버그가 잘 생김. 디버깅 어려움.
- C++ 템플릿: `template <typename T> T max(T a, T b) { ... }`
	- 컴파일 타임에 타입을 분석해서,필요한 타입(int 버전, float 버전 등)에 맞는 함수 코드를 자동으로 찍어냄.
	- 비용: 런타임 오버헤드 0. (함수 호출 비용은 인라인으로 업앨 수 있음)
	- 단점: 코드를 너무 많이 찍어내면 **Code Size(플래시 메모리 용량)** 가 커질 수 있음. (Code Bloat).

# 요약
1. 포인터 연산: 데이터 타입의 크기(`sizeof`)만큼 주소가 점프하는 것을 잊지 말기.
2. `volatile`: 하드웨어 레지스터 제어 변수에는 필수.
3. 함수 인자: 4개까지가 가장 빠름. (R0~R3)
4. C++ 클래스: 기본적으로 C 구조체와 비용이 같음.
5. 가상 함수: 약간의 메모리와 속도 비용이 있으므로 알고 써야 함.

이 내용들 중 **"심볼 테이블", "스택 프레임", "vtable"** 같은 용어들이 머릿속에 그림으로 그려져야 함.