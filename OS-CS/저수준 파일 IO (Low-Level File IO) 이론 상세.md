#### 표준 C 라이브러리(Standard C Library, libc)와 시스템 콜(System Call)
대부분의 프로그래머가 사용하는 `fopen()`, `fprintf()`, `fread()`, `fwrite()`, `fclose()` 등의 함수는 **표준 C 라이브러리(libc)** 에서 제공하는 **고수준(High-Level)** I/O 함수임.
- 고수준 I/O의 역할: 이러한 libc 함수들은 사용자 공간(User Space)에서 자체적인 **버퍼Buffer)** 를 사용하여 I/O 작업을 효율적으로 처리함. 예를 들어, `fprintf()`로 한 글자씩 써도, 실제 디스크 쓰기(쓰기 시스템 콜)는 버퍼가 가득 찼거나 `fflush()`가 호출될 때까지 지연될 수 있음.
- 저수준 I/O (시스템 콜): 고수준 함수들은 결국 실제 데이터를 파일이나 장치에 쓰고 읽기 위해 운영체제 커널이 제공하는 **시스템 콜** 을 호출함. 저수준 파일 I/O는 바로 이 시스템 콜 API를 직접 사용하는 것을 의미함.

| 분류  | 함수 (API)                                                  | 사용 공간            | 특징                                            |
| --- | --------------------------------------------------------- | ---------------- | --------------------------------------------- |
| 고수준 | `fopen()`, `fprintf()`, `fread()`, `fwrite()`, `fclose()` | 사용자 공간           | 버퍼링을 자체적으로 관리하여 효율적이며, 사용하기 편리함.              |
| 저수준 | `open()`, `read()`, `write()`, `lseek()`, `close()`       | 커널 공간 진입 (시스템 콜) | 커널에 직접 요청을 보내며, 버퍼링을 최소화하고 파일 접근을 **직접** 제어함. |

#### 시스템 콜을 통한 권한 상승 및 커널 접근
1. 사용자 공간 (User Space): 일반 애플리케이션이 살행되는 공간임. 보안을 위해 제한된 권한만 가짐.
2. 커널 공간 (Kernel Space): 운영체제의 핵심 기능(파일 시스템, 메모리 관리, 장치 드라이버 등)이 실행되는 공간임. 모든 하드웨어에 접근 권한을 가짐.
3. 시스템 콜 메커니즘:
	- 응용 프로그램이 `write()` 같은 저수준 I/O 함수를 호출하면, CPU는 **소프트웨어 인터럽트** 나 **특정 명령어(예: `SYSCALL` 또는 `INT 0x80`)** 를 통해 실행 모드를 **사용자 모드(User Mode)** 에서 **커널 모드(Kernel Mode)** 로 전환함.
	- 이를 통해 커널 함수(예: `sys_write`)가 실행되며, 이 과정이 바로 **권한 상승(Privilege Escalation)** 이 일어나는 지점.
	- 커널은 파일 시스템을 통해 실제 디스크 I/O를 수행하고, 작업이 완료되면 다시 사용자 모드로 복귀함.
#### 파일 디스크립터 (File Descriptor, fd)의 역할
파일 디스크립터는 저수준 파일 I/O에서 **가장 핵심적인 개념** 임.
- 정의: `open()` 시스템 콜이 성공적으로 파일을 열었을 때, 커널이 프로세스에게 부여하는 **음이 아닌 정수(Non-negative integer)** 임.
- 핵심 역할: 프로세스가 특정 파일(또는 소켓, 파이프 등 I/O 장치)에 접근할 때, 파일명 대신 이 `fd` 값을 사용함. 커널 내부에서 이 `fd`는 **"프로세스별 파일 디스크립터 테이블"** 의 인덱스 역할을 하며, 이 테이블의 항목은 다시 **"시스템 전체 파일 테이블"** 을 가리킴.
- 표준 fd: 모든 유닉스/리눅스 기반 시스템에서 프로세스가 시작될 때 기본으로 할당되는 3개의 `fd`가 있음.
	- `fd 0`: 표준 입력 (Standard Input, Stdin)
	- `fd 1`: 표준 출력 (Standard Output, Stdout)
	- `fd 2`: 표준 에러 (Standard Error, Stderr)

#### 보완해야 할 주요 개념
TDD 구현 시 반드시 이해해야 할 저수준 I/O의 핵심 함수들을 보완

| 함수      | 기능                        | 매개변수 (리눅스 기준)                                      | 반환 값                               |
| ------- | ------------------------- | -------------------------------------------------- | ---------------------------------- |
| `open`  | 파일을 열거나 생성하고 fd를 반환함.     | `const char *pathname`, `int flags`, `mode_t mode` | 성공 시 `fd` (정수), 실패 시 `-1`          |
| `read`  | fd가 가리키는 파일에서 데이터를 읽음.    | `int fd`, `void *buf`, `size_t count`              | 성공 시 읽은 바이트 수, EOF 시 `0`, 실패 시`-1` |
| `write` | fd가 가리키는 파일에 데이터를 씀.      | `int fd`, `const void *buf`, `size_t count`        | 성공 시 쓴 바이트 수, 실패시 `-1`             |
| `lseek` | 파일 포인터(읽기/쓰기 위치)를 이동시킵니다. | `int fd`, `off_t offset`, `int whence`             | 성공 시 새로운 파일 포인터 위치, 실패 시 `-1`      |
| `close` | fd를 닫고, 커널의 자원을 해제함.      | `int fd`                                           | 성공 시 `0`, 실패 시 `-1`                |

# 사용자 화면 출력 과정의 내부  버퍼링 (Buffer)
사용자가 `printf()`나 `write()`를 통해 데이터를 출력할 때, 화면에 즉시 보이지 않고 내부 버퍼를 거치는 과정은 I/O 효율성을 위해 필수적임. 이 과정에는 최소 2~3단계의 버퍼가 관여함.

#### 사용자 공간 버퍼 (User Space Buffer)
이 버퍼는 libc에서 관리함. 앞서 언급한 고수준 I/O 함수들이 사용함.
- 관리 주제: `libc`
- 목적: 작은 I/O 요청들을 모아서 하나의 큰 `write()` 시스템 콜로 묶어 호출 횟수를 줄여 **시스템 콜 오버헤드** 를 최소화함.
- 버퍼링 방식 (주요 3가지):
	- 완전 버퍼링 (Full Buffering): 버퍼가 가득 찰 때만 커널로 전송됨. (일반 파일 I/O의 기본값)
	- 줄 단위 버퍼링 (Line Buffering): 줄바꿈 문자(`\n`)가 발생하거나 버퍼가 가득 찰 때 커널로 전송됨. (터미널(Stdout) 출력의 기본값)
	- 버퍼링 없음 (Unbuffered): 요청 즉시 커널로 전송됨. (Stderr의 기본값)
#### 커널 공간 버퍼/캐시 (Kernel Space Buffer/Cache)
이 버퍼는 운영체제 커널이 관리하며, 사용자 요청과 실제 하드웨어 I/O 사이에 위치함.
- 관리 주체: 커널의 **페이지 캐시(Page Cache)** 및 **블록 버퍼(Block Buffer)** 시스템
- 목적: 디스크 I/O는 CPU/메모리 작업에 비해 매우 느림. 커널은 자주 접근하는 데이터를 메모리에 캐시하여 I/O 요청을 처리 속도를 높임.
	- 쓰기(Write)의 경우: `write()` 시스템 콜이 반환된 후에도, 데이터는 디스크로 즉시 기록되지 않고 커널 캐시에 남아있을 수 있음. 이것이 **지연된 쓰기(Deferred Write)** 임. 실제 디스크에 기록되는 시점은 `sync()`, `fsync()` 시스템 콜이 호출되거나, 캐시 공간이 부족하거나, 주기적인 커널 프로세스에 의해서임.
	- 읽기(Read)의 경우: `read()` 시스템 콜 요청 시, 커널은 요청된 데이터뿐만 아니라 그 주변 데이터까지 **미리 읽어(Read-ahead)** 캐시에 넣어둠.

#### 하드웨어 버퍼 (Hardware Buffer)
- 관리 주체: 디스크 컨트롤러/SSD 자체
- 목적: 디스크/SSD 내부에도 자체적인 소량의 캐시 메모리가 있어, 작은 I/O단위를 모아 처리하거나, 순서가 다른 요청을 최적화하여 처리함.

# TDD 개발을 위한 접근 순서
TDD로 구현을 시작하신다면, 다음 순서로 시스템 콜을 래핑(Wrapping)하는 라이브러리를 개발하는 것을 추천.
1. 테스트 1: 파일 열기/닫기
	- `int my_open(const char *path, int flags)`와 `int my_close(int fd)`를 구현하고 테스트함. fd가 제대로 할당되고 해제되는지 확인함.
2. 테스트 2: 파일 쓰기
	- `ssize_t my_write(int fd, const void *buf, size_t count)`를 구현함. 더미 파일에 데이터를 쓰고, 그 파일의 크기가 정확한지 확인하는 테스트를 작성함.
3. 테스트 3: 파일 읽기
	- `ssize_t my_write(int fd, const void *buf, size_t count)`를 구현함. 이전에 작성한 더미 파일에서 데이터를 읽고, 읽은 내용이 정확히 일치하는지 확인함.
4. 테스트 4: 파일 위치 이동
	- `off_t my_lseek(int fd, off_t offset, int whence)`를 구현하여 특정 위치에서 읽기/쓰기가 가능한지 테스트함.

