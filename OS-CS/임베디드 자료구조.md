임베디드(특히 MCU 환경)는 **"제한된 RAM, 결정적인 실행 시간(Deterministic), 그리고 안전성"** 이 최우선입니다.

### 동적 할당(malloc/free)을 버려라: 정적 할당(Static Allocation)의 미학
CS 자료구조 수업에서는 `malloc`으로 노드를 생성하는 연결 리스트를 배움. 임베디드, 특히 미션 크리티컬한 환경(자동차, 의료기기)에서는 `malloc` 사용을 엄격히 금지하거나 초기화 단계에서만 허용함.

왜 `malloc`이 위험한가?
1. 메모리 파편화(Fragmentation): 썼다 지웠다를 반복하면 메모리 중간에 구멍이 숭숭 뚫려, 나중에는 큰 덩어리를 할당받지 못해 시스템이 멈춤.
2. 시간 예측 불가능: 빈 공간을 찾는 데 걸리는 시간이 상황에 따라 다름. 실시간 시스템(Real-time)에서는 치명적.
3. 메모리 누수(Leak): `free`를 깜빡하면 장비가 며칠 뒤에 죽음.

임베디드식 해결책: "Pool" 방식
미리 최대 크기만큼 배열(Array)을 선언해두고 가져다 씀.
```c
// 나쁜 예 (동적 할당)
// Node* newNode = (Node*)malloc(sizeof(Node));

// 좋은 예 (정적 할당, Object Pool)
#define MAX_NODES 100
Node nodePool[MAX_NODES]; // BSS 영역(RAM)에 미리 찜해둠
bool nodeUsed[MAX_NODES]; // 사용 여부 플래그

Node* allocate_node() {
	for(int i=0; i < MAX_NODES; i++) {
		if(!nodeUsed[i]) {
			nodeUsed[i] = true;
			return &nodePool[i]	
		}
	}
	return NULL; // 풀이 꽉 참 (에러 처리 명확함)
}
```

### 배열(Array) vs 연결 리스트(Linked List)
앞서 배운 캐시 메모리와 프리페처(Prefetch) 개념과 연결.
- 연결 리스트: 데이터가 메모리 여기저기에 흩어져 있고 포인터로 연결 -> CPU가 다음 데이터를 가져올 때마다 캐시 미스(Cache Miss)가 발생할 확률이 높음 -> 4바이트 (32bit CPU 기준) 포인터 주소를 데이터마다 달고 다녀야 하므로 메모리 낭비가 심함.
- 배열: 데이터가 일렬로 착 붙어 있음 -> CPU가 한 번에 긁어오기 좋고, 캐시 적중률이 높아 속도가 압도적으로 빠름.

> 결론: 임베디드에서는 웬먼하면 배열을 사용. 데이터 삽입/삭제가 빈번하다면, 일반 연결리스트보다는 배열 기반의 리스트나 링 버퍼를 사용.

### 원형 버퍼 (Circular Buffer / Ring Buffer): 임베디드의 심장
가장 중요한 자료구조 하나만 꼽으라면 단연코 **원형 버퍼**. 통신(UART, SPI) 데이터를 받아 처리할 때 필수.
- 개념: 배열의 끝과 시작이 연결된 형태.
- 상황: 센서 데이터가 막 쏟아지는데(Producer), CPU가 처리하는 속도(Consumer)가 잠깐 느려질 때 데이터를 임시로 쌓아두는 큐(Queue) 역할을 함.
- 장점: 
	- 데이터를 밀어내기 위해 배열 전체를 `shift` 할 필요가 없음. (O(1) 속도)
	- `Head`와 `Tail` 인덱스만 관리하면 되므로 매우 가벼움.
```c
#define BUFFER_SIZE 64
uint8_t rxBuffer[BUFFER_SIZE];
volatile int head = 0; // 데이터를 넣는 위치 (Write)
volatile int tail = 0; // 데이터를 빼는 위치 (Read)

void put_data(uint8_t data) {
	int next = (head + 1) % BUFFER_SIZE;
	if (next != tail) { // 버퍼가 꽉 차지 않았으면
		rxBuffer[head] = data;
		head = next;
	}
	// 꽉 찼으면? 보통 가장 오래된 데이터를 덮어쓰거나 버림.
}
```

### 구조체와 공용체 (Struct & Union): 하드웨어 매핑의 도구
C++의 클래스보다 C언어의 `struct`와 `union`을 자유자재로 다뤄야 함. 특히 **비트 필드(Bit Field)** 와 **공용체(Union)** 는 하드웨어 레지스터를 다루거나 통신 프로토콜을 파싱할 때 강력함.

**공용체(Union)의 마법**
서로 다른 자료형이 같은 메모리 공간을 공유.
```c
typedef union {
	float fValue;
	uint8_t bytes[4]
} FloatPacket;

void send_float(float val) {
	FloatPacket packet;
	packet.fValue = val;
	
	// float를 별도의 변환 연산 없이 바로 바이트 배열로 전송 가능!
	// 엔디안(Endian) 문제만 주의하면 최강의 효율.
	uart_send(packet.bytes, 4);
}
```

### 룩업 테이블 (Lookup Table): 시간과 공간의 등가교환
임베디드 CPU(특히 저가형)는 나눗셈이나 삼각함수(`sin`, `cos`) 연산이  매우 느립니다. FPU(Floating Point Unit)가 없는 칩도 많음.

이때 **계산을 미리 다 해놓고 배열에 저장해 두는 방식** 을 씀.
- 메모리(공간)를 희생해서 연산 속도(시간)를 얻는 전략.
```c
// sin() 함수를 호출하는 대신 미리 계산된 값을 사용
const float sin_table[91] = { 0.0, 0.0174, ... , 1.0 }; // 0도 ~ 90도

float fast_sin(int degree) {
	return sin_table[degree]; // 연산 없음. 그냥 메모리 읽기 (초고속)
}
```

# 정리
1. 배열 위주로 사고. 동적 할당은 피하고, 최대 크기를 미리 지정.
2. 링 버퍼를 직접 구현. UART 통신 예제를 짤 때 반드시 필요.
3. 메모리 맵을 그릴 줄 알아야 함. 내 자료구조가 RAM의 어디에, 얼만큼 차지하는지 계산할 수 있어야 함.

**알고리즘** 으로 넘어갈 차례. 일반적인 정렬/탐색보다는 임베디드 실전 기술이 더 급함.

**"비트 연산(Bitwise Operation)을 통한 알고리즘 테크닉에 깊게 들어가기"**

임베디드에서는 변수 값의 덧셈/뺄셈보다, **특정 비트를 켜고 끄고 돌리는(Shift) 조작** 이 알고리즘의 80%를 차지함. 이것이 진정한 하드웨어 제어 기술.
