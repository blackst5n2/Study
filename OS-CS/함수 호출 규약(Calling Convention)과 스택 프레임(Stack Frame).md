어려지만, 한번 이해하면 **"스택 오버플로우(Stack Overflow)** 나 **데이터 손상(Data Corruption)** 문제를 쉽게 해결할 수 있는 능력이 생김.

# 함수 호출의 5단계 과정
우리가 `funcA(1, 2);`라고 코드를 작성하면, CPU는 이를 단순한 점프(Jump)가 아닌, 다음 5단계의 복작합고 정밀한 계약을 수행함.

### 1단계: 인자 전달 (The Argument Pass)
- C 코드: `result = calculate(arg1, arg2)`;
- 하드웨어 동작: 호출하는 함수(`calculate()를 부르는 쪽)가 인자들을 레지스터에 준비함.
- ARM 아키텍처(대부분의 임베디드)의 AAPCS 규약에 따라, 첫 4개의 인자(`arg1`~`arg4`)는 R0, R1, R2, R3 레지스터에 넣어서 전달됨.
- 5번째 인자부터는 스택에 쌓음.

### 2단계: 복귀 주소 저장 (Link Register - LR)
- C 코드: 함수 호출 위치 (`calculate();`)
- 하드웨어 동직: CPU는 `BL` (Branch with Link) 명령어를 사용하여 함수(`calculate`)가 끝난 후 돌아와야 할 주소를 **LR (Link Register)** 에 저장함. 이것이 없으면 함수는 길을 읽음.

### 3단계: 함수 진입 (Prologue) - 스택 프레임 구축
호출된 함수(`calculate`)가 시작되자마자 가장 먼저 하는 일은 **"내가 쓸 공간 마련"** 임. 이를 **프롤로그(Prologue)** 라고 함.
- A. 레지스터 저장: 함수 내부에서 R0, R1, R2, R3를 제외한 다른 레지스터들(R4~R11 등)을 사용해야 한다면 ,그 값들이 복귀 시 깨지지 않도록 스택에 먼저 저장함.
- B. LR 저장: 다른 함수를 또 호출할 가능성이 있다면, 현재 `LR`에 저장된 복귀 주소를 스택에 저장함.
- C. 스택 포인터 조정: `SP (Stack Pointer)`를 아래로 내림. 이 공간에 함수 내 지역 변수들을 저장함.
이 공간 전체를 **스택 프레임(Stack Frame)** 이라고 함.

### 4단계: 함수 본체 실행 (The Core Work)
- 함수 내 코드가 실행됨. 지역 변수는 `SP`가 가리키는 주소로부터의 오프셋을 이용해 접근함. (예: `SP+4`에 첫 번째 지역 변수 저장)

### 5단계: 함수 종료 (Epilogue) - 뒷정리
함수가 끝나면 **에필로그(Epilogue)** 를 실행하여 깨끗하게 메모리를 정리함.
- A. 리턴 값: 결과 값은 R0 레지스터에 담아둠.
- B. 스택 정리: `SP`를 다시 위로 올림(지역 변수 공간 해제).
- C. 레지스터 복원: 프롤로그에서 스택에 저장했떤 모든 레지스터(R4~R11, LR)를 원래 레지스터로 복원함.
- D. 복귀: CPU는 저장했던 `LR` 레지스터 값을 이용해 `BX LR` 명령어로 원래 `2단계`에서 저장해준 복귀 주소로 점프함.

# 스택 메모리의 물리적 의미
메모리 구조에서 **스택(Stack)** 은 RAM의 한쪽 끝(보통 높은 주소)부터 아래(낮은 주소)로 자라남.

| 메모리 영역               | 역할                     | 하드웨어 레지스터          |
| -------------------- | ---------------------- | ------------------ |
| 스택(Stack)            | 지역 변수, 함수 인자, 복귀 주소 저장 | SP (Stack Pointer) |
| LR (Link Register)   | 복귀 주소 임시 저장            |                    |
| PC (Program Counter) | 다음에 실행할 명령어 주소         |                    |

#### 스택 오버플로우 (Stack Overflow)의 원인
임베디드 시스템에서 스택 영역은 보통 4KB, 8KB 등으로 고정된 크기를 가짐.
- 발생 이유: 재귀 호출이 너무 깊어지거나(무한 루프), 함수 내에서 너무 큰 지역 배열을 선언하면, `SP`가 계속 아래로 내려가다가 정해진 스택 영역의 경계를 벗어나 **힙(Heap)이나 데이터 영역** 을 침범함.
- 결과: 다른 태스크의 메모리나 중요한 전역 변수를 덮어쓰게 되어 시스템이 **하드 폴트(Hard Fault)** 를 일으키며 멈춤.
- 프로그래머의 역할: 함수 내에서 대용량 데이터를 다룰 때는 지역 변수 대신 **힙(Heap)** 이나 **정적 변수(`static`)** 를 사용하도록 설계해야 함.

