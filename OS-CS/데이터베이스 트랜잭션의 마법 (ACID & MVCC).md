데이터베이스의 존재 이유는 단순히 데이터를 저장하는 것이 아니라, **트랜잭션(Transaction)** 이라는 논리적 작업 단위를 보장하는 데 있음. 이를 위해 DB는 ACID라는 4가지 철칙을 지킴.

#### ACID: 무결성을 위한 4가지 기둥
- Atomicity (원자성): 트랜잭션 내의 모든 작업은 모두 성공하거나, 아니면 아예 없던 일이 되어야 함(All or Nothing).
	- 구현 원리 (Undo Log): DB는 변경 사항을 적용하기 전, 이전 값을 어딘가 (Undo Log)에 적어둠. 중간에 에러가 나면 이 로그를 보고 시간을 되돌림(Rollback).
- Consistency (일관성): 트랜잭션 전후로 데이터베이스는 항상 유효한 상태여야 함(잔고가 마이너스가 되지 않음 등).
- Isolation (고립성): 여러 트랜잭션이 동시에 실행되어도, 각자는 서로의 존재를 모르는 것처럼(독립적으로) 실행되어야 함. 이것이 동시성 제어의 핵심.
- Durability (지속성): 커밋된 데이터는 전원이 뽑혀도 영구적으로 저장되어야 함.

#### 가장 어려운 문제: 고립성(Isolation)과 성능의 딜레마
**OS의 뮤텍스(Lock)** 를 DB 전체에 걸면 완벽한 고립성이 보장되지만, 한 번에 한 명만 쓸 수 있으니 성능이 바닥을 칠 것.
- 전통적 해결책 (2PL - Tow Phase Locking): 테이블을 읽서나 쓸 때 해당 행(Row)에 **락(Lock)** 을 걺.
	- 문제: 읽기 작업(Reader)조차 락을 걸어야 하므로, 누군가 쓰고 있으면(Writer) 읽을 수 없음. (Blocking).

이 딜레마를 해결하기 위해 등장한 현대 DB 아키테츼 정점이 바로 MVCC임.

#### MVCC (Multi-Version Concurrency Control): 시간을 쪼개는 마법
"읽는 자는 쓰는 자리 막지 않고, 쓰는 자는 읽는 자를 막지 않는다."

MVCC는 데이터에 덮어쓰기(Overwrite)를 하지 않고, **새로운 버전(Version)** 을 만드는 방식으로 동시성을 극대화함.

##### 작동 메커니즘
1. 데이터 버전 관리: 어떤 행을 업데이트하면, DB는 기존 데이터를 지우지 않고 새로운 버전의 행을 추가함. 즉, 물리적으로는 하나의 행에 대해 여러 버전(V1, V2, V3...)이 동시에 존재함.
2. 스냅샷 (Snapshot): 각 트랜잭션은 시작 시점에 자신만의 **논리적 시점(Snapshot)** 을 가짐.
3. 가시성 판단 (Visibility Check): 트랜잭션이 데이터를 읽으려 할 때, DB는 현재 존재하는 여러 버전 중 내 시점(Transaction ID)보다 이전에 커밋된 최신 버전만을 보여줌.
- 결과: Writer가 V3를 열심히 만들고 있어도, Reader는 아무런 락 대기 없이 V2를 평온하게 읽을 수 있음.

#### WAL (Write-Ahead Logging): 성능과 안정성의 타협
파일 I/O에서 랜덤 I/O가 느리고 순차 I/O가 빠르다는 것을 알고 있음. DB는 트랜잭션이 커밋될 때마다 B+ Tree의 여기저기(랜덤 위치)를 찾아가서 데이터를 쓰는 대신, **로그(Log)** 를 활용함.
1. 로그 선행 기입: 데이터를 실제 데이터 파일(B+ Tree)에 반영하기 전에, 변경 내용을 **로그 파일(WAL)** 의 맨 끝에 순차적으로(Append-only) 기록함.
2. 동기화 (fsync): `fsync` 시스템 콜을 호출하여 로그 파일만큼은 확실하게 디스크에 내림. 순차쓰기이므로 매우 빠름.
3. 지연된 쓰기: 실제 데이터 파일 변경은 메모리(Buffer Pool)에서만 해두고, 나중에 천천히 드스크에 반영함(Checkpoint).
4. 복구: 전원이 꺼지면? 재부팅 시 WAL을 처음부터 다시 읽어서(Replay) 메모리에 반영되지 못했던 데이터들을 복구함.

# 핵심 요약
1. ACID: 트랜잭션의 4가지 원칙이며, 이를 위해 DB는 복잡한 내부 메커니즘을 돌림.
2. MVCC: **"데이터의 역사(Version)"** 를 저장함으로써, 락(Lock) 없이도 읽기와 쓰기를 동시에 수행하는 고성능 동시성 제어 기술임.
3. WAL: 랜덤 I/O의 느린 속도를 극복하기 위해 ,순차 I/O로 로그를 먼저 남기고 데이터 반영을 미루는 테크닉임.
