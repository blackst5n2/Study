**"개발하는 PC(HDD/SDD)에는 파일/폴더 자체의 크기가 존재하지만, 임베디드 장치(MCU)의 플래시 메모리로 들어갈 때는 0바이트로 사라진다.**"

# 개발용 PC 환경 (Windows/Linux)에서의 크기
PC에서는 파일 하나, 폴더 하나를 만들 때마다 **"껍데기 비용"** 이 듦.

## 파일의 오버헤드 (Metadata)
`mator.c`라는 파일을 만들면, 그 안에 코드가 단 한 줄도 없어도(0바이트여도) 하드디스크의 일정 공간을 차지함.
- 메타데이터: 파일 이름, 생성 날짜, 권한, 소유자 등의 정보가 저장되어야 함.
- 클러스터(Cluster) 단위: 윈도우 파일 시스템은 보통 4KB 단위로 방을 씀. 코드 1바이트만 적어도 실제로는 4KB 방 하나를 통째로 차지.

## 폴더의 정체
폴더(디렉토리)도 사실은 특수한 파일임.
- 폴더는 "내 안에 어떤 파일들이 있는지" 적어놓은 명단(List) 데이터를 담고 있는 파일임. 따라서 폴더를 많이 만들면 그 명단을 저장할 용량이 PC 하드디스크에서는 아주 미세하게 늘어남.

	결론 (PC): 파일을 잘게 쪼개고 폴더를 많이 만들면 PC의 저장 공간은 아주 조금 더 차지함. 하지만, 이건 임베디드 장치의 성능과는 아무 상관이 없음.


# 컴파일 & 링킹후 (임베디드 장치로 갈 때)
"내가 파일을 100개로 쪼개면, MCU 메모리도 낭비되는 거 아냐?"

정답은 "아니오, 전혀 낭비되지 않습니다."

그 이유는 컴파일러와 링커가 파일을 다루는 방식 때문임.

## 컴파일러의 시선: "종이는 태워버리고 내용만 남긴다"
컴파일러는 `motor.c`, `sensor.c`, `main.c`를 각각 기예어(Object file, `.o`)로 번역함. 이때 파일 이름이나 폴더 구조는 중요하지 않음. 오직 그안에 있는 **함수와 변수(내용물)** 만 기계어로 바뀜.

## 링커의 마법: "경계를 허문다"
가장 중요한 링킹(Linking) 단계에서 모든 파일의 내용물이 하나로 합쳐짐.
- 상황: `main.c`에서 `motor.c`에 있는 `RunMotor()` 함수를 호출함.
- 링커의 동작:
	1. `motor.c` 파일 껍데기는 버림.
	2. `RunMotor()` 함수의 기계어 코드만 쏙 뽑아냄.
	3. 플래시 메모리의 특정 주소(예: `0x08001000`)에 그 코드를 배치함.
	4. `main.c`가 있던 자리에는 "0x08001000으로 점프해!"라는 명령만 남김.

결국, 최종적으로 만들어진 바이너리 파일(`.bin` 또는 `.hex`)에는 **파일 이름도, 폴더 구조도, 줄 바꿈도 존재하지 않음.** 오직 수수한 명령어(Instruction)들의 거대한 덩어리만 남음.
	비유: 책을 쓸 때 원고지 100장에 나눠서 쓰든(파일 분리), 큰 전지 한장에 몰아서 쓰든(단일 파일), 결국 인쇄된 책(실행 파일)에 들어가는 글자의 수는 똑같음. 원고지(파일)는 버려지니까.

# 예외: 크기가 늘어나는 경우가 있긴 할까?
파일을 분리한다고 해서 메모리가 늘어나지는 않지만, 코딩 방식에 따라 미세한 차이는 발생할 수 있음.

## 인라인(Inline) 최적화 불가 (과거의 이야기)
과거의 멍청한 컴파일러는 파일이 다르면 최적화를 잘 못했음.
- 한 파일에 있으면: 함수 내용을 복사해서 붙여넣기(Inlining)를 통해 호출 비용을 줄임.
- 다른 파일에 있으면: 무조건 `CALL` 명령어로 점프함 (미세한 오버헤드 발생).

하지만 요즘 GCC나 Clang 같은 현대 컴파일러는 **LTO (Link Time Optimization)** 라는 기술을 씀.
파일이 달라도 링커가 알아서 다 뜯어보고 "어? 이거 합치는 게 빠르겠는데?" 하고 최적화해버림.

### 디버깅 정보 (Debug Symbol)
만약 디버깅 모드(Debug Mode)로 빌드하면 `.elf` 파일 안에 "이 코드는 원래 `src/motor/motor.c`의 15번째 줄이었다."라는 정보가 기록됨.
- 이 때문에 PC에 저장되는 실행 파일 용량은 커짐.
- 하지만! 실제 장비에 다운로드할 때 (Flash Writing)는 이 디버깅 정보를 싹 걷어내고 순수 기계어만 넣기 때문에 장비 메모리에는 영향이 없음.

# 정리: 훌량한 프로그래머의 자세
"파일 분리를 두려워하지 말라."

임베디드에서 `class`나 파일을 나누는 것은 하드웨어 자원을 낭비하는 것이 아니라, 사람(개발자)의 뇌 자원을 아껴주는 헹위.
- 하드웨어 관점: 파일이 1개든 100개든, 링킹을 거치면 그냥 똑같은 `0`과 `1`의 나열일 뿐임. (Flat Memory Model)
- 유지보수 관점: 기능별로 파일(`motor.c`, `led.c`)과 폴(`driver/`, `app/`)가 잘 나뉘어 있어야 나중에 코드를 고치기 쉬움.

**"빌드 후 생성되는 .map 파일(Map File)"** 을 분석하는 법

`motor.c`의 함수가 실제로 메모리 몇 번지에, 몇 바이트 크기로 박제되었는지 엑셀 표처럼 적나라하게 확인 가능.