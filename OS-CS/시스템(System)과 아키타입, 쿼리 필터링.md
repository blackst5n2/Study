시스템의 주요 목표는 단 하나: **"특정 조합의 컴포넌트 데이터에만 접근하고, 다른 데이터에는 절대로 접근하지 않는 것"**. 이 격리(Isolation)는 병렬 처리를 가능하게 하는 기반이 됨.

## 컴포넌트 시그니처 (Component Signature)와 비트마스크
모든 시스템은 자신이 처리할 엔티티를 필터링하기 위한 조건을 정의해야 함. 이 조건을 기술적으로 표현하는 방법이 **비트마스크(Bitmask)** 를 이용한 **컴포넌트 시그니처(Signature)** 임.

#### 작동 원리
1. 컴포넌트 ID 부여: 모든 컴포넌트 타입(예: `Position`, `Velocity`, `Health`)에 컴파일 시점에 유니크한 정수형 ID를 부여함.
	- `Position` -> ID 0
	- `Velocity` -> ID 1
	- `Health` -> ID 2
2. 엔티티 시그니처 생성: 엔티티가 특정 컴포넌트를 가질 떄, 해당 컴포넌트 ID에 해당하는 비트를 1로 설정함.
	- 엔티티 A가 \[`Position`, `Health`\]를 가진다면: $2^0 + 2^2 = (101)_2$
	- 엔티티 B가 \[`Velocity`, `Health`\]를 가진다면: $2^1 + 2^2 = (110)_2$
3. 시스템 시그니처 생성: 시스템도 자신이 필요로 하는 컴포넌트 조합을 비트마스크로 표현함.
	- `MovementSystem`이 \[`Position`, `Velocity`\]를 필요로 한다면: $2^0 + 2^1 = (011)_2$

## 쿼리 필터링: 비트 논리 연산
시스템이 엔티티를 필터링하는 과정은 매우 빠르고 효율적인 **비트 논리 연산(AND, OR, NOT)** 으로 수행됨.

#### 쿼리 규칙 (예시: `MovementSystem`)
`MovementSystem`은 \[`Position` (0), `Velocity` (1)\]이 반드시 있어야 함.

| 조건            | 비트 연산                                  | 설명                                                                |
| ------------- | -------------------------------------- | ----------------------------------------------------------------- |
| MUST HAVE     | `SystemSig AND EntitySIg == SystemSig` | 필수 조건: 엔티티 시그니처가 시스템 시그니처의 모든 비트를 포함하고 있는지 검사함.                   |
| MUST NOT HAVE | `SystemSig_NOT AND EntitySig == 0`     | 제외 조건: 엔티티 시그니처와 제외 컴포넌트 시그니처의 AND 연산 결과가 0이어야함 (겹치는 컴포넌트가 없어야 함) |

예시 (MUST HAVE): `MovementSystem` (Sig: $011_2$)이 엔티티 B (Sig: $110_2$)를 처리할 수 있을까?
- $011_2$ (System) AND $110_2$ (Entity) -> $010_2$
- $010_2$는 $110_2$와 같지 않음 -> 처리 불가. (Entity B는 포지션이 없음)

결론: 비트마스크를 사용하면, 수많은 엔티티를 루프 돌며 "if (hasPosition && hasVelocity)"와 같은 느린 비교 대신, 단 한 번의 정수 연산으로 필터링을 끝낼 수 있음. 이는 ECS 성능의 또 다른 핵심

## ECS 구현의 두 가지 주요 방식
ECS를 실제 구현하는 방식은 **데이터의 배치 방식** 에 따라 크게 두 가지로 나뉨.

#### 배열 기반 (Sparse Set 방식) 
- 데이터 배치: 각 컴포넌트 타입별로 별도의 **Packed Array (Sparse Set)** 를 유지함.
- 쿼리 방식: 시스템은 엔티티 리스트를 순회하며 위에서 설명한 **비트마스크 연산** 으로 필터링함. 필터링된 엔티티 ID를 이용해 각 컴포넌트의 `Packed Array`에 접근하여 데이터를 가져옴.
- 장점: 구현이 비교적 단순하고 유연하며, 런타임에 컴포넌트 추가/삭제가 매우 빠름 ($O(1)$).

#### 아키타입 기반 (Unity DOTS 방식) - 성능 극대화
- 데이터 배치 (아키타입): 엔티티들을 그들이 가진 **컴포넌트 조합(Signature)** 에 따라 그룹핑하여 **아키타입 테이블** 이라는 큰 메모리 블록에 묶어 저장함.
	- 예: 모든 \[`Position` ,`Velocity`\] 엔티티는 하나의 테이블에, 모든 \[`Position`, `Health`\] 엔티티는 다른 테이블에 저장됨.
- 쿼리 방식: 시스템은 자신이 원하는 시그니처와 일치하는 **아키타입 테이블 자체** 를 통째로 가져옴.
- 장점:
	- 필터링된 데이터가 이미 한 곳에 모여있으므로 시스템 순회 속도가 극한으로 빠름.
	- **"Component-of-Components"** 처럼 메모리에 컴포넌트들이 완벽히 연속적으로 배치됨.
- 단점: 엔티티에 컴포넌트가 추가/삭제될 때, 해당 엔티티를 다른 아키타입 테이블로 **통째로 복사** 해야하므로 런타임 변경(Mutation) 비용이 비쌈.

## 시스템의 실행 순서와 유의점
시스템은 데이터를 처리하는 순서도 중요함.
- 독립적 실행: 서로 다른 컴포넌트를 다루는 시스템들은 (예: `MovementSystem`과 `RenderSystem`) **완전히 병렬로 실행**할 수 있음.
- 종속적 실행: 한 컴포넌트를 공유하는 시스템들 (예: `DamageSystem`과 `HealthBarSystem`이 모두 `Health` 컴포넌트를 사용)은 **실행 순서가 정해져야 하거나 (Dependency)**, 데이터 경쟁을 막기 위해 **동기화**가 필요함.
	- 이상적으로는, **입력 데이터(Read)와 출력 데이터(Write)** 를 명확히 분리하여 병렬 처리가 가능하도록 시스템을 설계해야 함. (ECS의 핵심 설계 유의점)

# 요약
1. 필터링: 비트마스크를 이용한 **컴포넌트 시그니처** 로 엔티티를 빠르고 효율적으로 필터링함 ($O(1)$ 정수 연산).
2. 구현 방식: Sparse Set 기반은 유연하며 런타임 변경이 빠름, Archetype 기반은 순회 성능이 극한으로 빠름.
3. 병렬 처리: 시스템은 데이터를 독립적으로 Read/Write 하도록 설계되어야 병렬 실행이 가능해짐.
