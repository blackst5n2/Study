// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace Protocol {

struct C_Login;
struct C_LoginBuilder;
struct C_LoginT;

struct S_Login;
struct S_LoginBuilder;
struct S_LoginT;

struct C_Chat;
struct C_ChatBuilder;
struct C_ChatT;

struct S_Chat;
struct S_ChatBuilder;
struct S_ChatT;

struct C_Move;
struct C_MoveBuilder;
struct C_MoveT;

struct S_Move;
struct S_MoveBuilder;
struct S_MoveT;

struct C_Test;
struct C_TestBuilder;
struct C_TestT;

struct GamePacket;
struct GamePacketBuilder;
struct GamePacketT;

enum PacketPayload : uint8_t {
  PacketPayload_NONE = 0,
  PacketPayload_C_Login = 1,
  PacketPayload_S_Login = 2,
  PacketPayload_C_Chat = 3,
  PacketPayload_S_Chat = 4,
  PacketPayload_C_Move = 5,
  PacketPayload_S_Move = 6,
  PacketPayload_C_Test = 7,
  PacketPayload_MIN = PacketPayload_NONE,
  PacketPayload_MAX = PacketPayload_C_Test
};

inline const PacketPayload (&EnumValuesPacketPayload())[8] {
  static const PacketPayload values[] = {
    PacketPayload_NONE,
    PacketPayload_C_Login,
    PacketPayload_S_Login,
    PacketPayload_C_Chat,
    PacketPayload_S_Chat,
    PacketPayload_C_Move,
    PacketPayload_S_Move,
    PacketPayload_C_Test
  };
  return values;
}

inline const char * const *EnumNamesPacketPayload() {
  static const char * const names[9] = {
    "NONE",
    "C_Login",
    "S_Login",
    "C_Chat",
    "S_Chat",
    "C_Move",
    "S_Move",
    "C_Test",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacketPayload(PacketPayload e) {
  if (::flatbuffers::IsOutRange(e, PacketPayload_NONE, PacketPayload_C_Test)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacketPayload()[index];
}

template<typename T> struct PacketPayloadTraits {
  static const PacketPayload enum_value = PacketPayload_NONE;
};

template<> struct PacketPayloadTraits<Protocol::C_Login> {
  static const PacketPayload enum_value = PacketPayload_C_Login;
};

template<> struct PacketPayloadTraits<Protocol::S_Login> {
  static const PacketPayload enum_value = PacketPayload_S_Login;
};

template<> struct PacketPayloadTraits<Protocol::C_Chat> {
  static const PacketPayload enum_value = PacketPayload_C_Chat;
};

template<> struct PacketPayloadTraits<Protocol::S_Chat> {
  static const PacketPayload enum_value = PacketPayload_S_Chat;
};

template<> struct PacketPayloadTraits<Protocol::C_Move> {
  static const PacketPayload enum_value = PacketPayload_C_Move;
};

template<> struct PacketPayloadTraits<Protocol::S_Move> {
  static const PacketPayload enum_value = PacketPayload_S_Move;
};

template<> struct PacketPayloadTraits<Protocol::C_Test> {
  static const PacketPayload enum_value = PacketPayload_C_Test;
};

template<typename T> struct PacketPayloadUnionTraits {
  static const PacketPayload enum_value = PacketPayload_NONE;
};

template<> struct PacketPayloadUnionTraits<Protocol::C_LoginT> {
  static const PacketPayload enum_value = PacketPayload_C_Login;
};

template<> struct PacketPayloadUnionTraits<Protocol::S_LoginT> {
  static const PacketPayload enum_value = PacketPayload_S_Login;
};

template<> struct PacketPayloadUnionTraits<Protocol::C_ChatT> {
  static const PacketPayload enum_value = PacketPayload_C_Chat;
};

template<> struct PacketPayloadUnionTraits<Protocol::S_ChatT> {
  static const PacketPayload enum_value = PacketPayload_S_Chat;
};

template<> struct PacketPayloadUnionTraits<Protocol::C_MoveT> {
  static const PacketPayload enum_value = PacketPayload_C_Move;
};

template<> struct PacketPayloadUnionTraits<Protocol::S_MoveT> {
  static const PacketPayload enum_value = PacketPayload_S_Move;
};

template<> struct PacketPayloadUnionTraits<Protocol::C_TestT> {
  static const PacketPayload enum_value = PacketPayload_C_Test;
};

struct PacketPayloadUnion {
  PacketPayload type;
  void *value;

  PacketPayloadUnion() : type(PacketPayload_NONE), value(nullptr) {}
  PacketPayloadUnion(PacketPayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PacketPayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PacketPayloadUnion(const PacketPayloadUnion &);
  PacketPayloadUnion &operator=(const PacketPayloadUnion &u)
    { PacketPayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PacketPayloadUnion &operator=(PacketPayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PacketPayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = PacketPayloadUnionTraits<RT>::enum_value;
    if (type != PacketPayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, PacketPayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Protocol::C_LoginT *AsC_Login() {
    return type == PacketPayload_C_Login ?
      reinterpret_cast<Protocol::C_LoginT *>(value) : nullptr;
  }
  const Protocol::C_LoginT *AsC_Login() const {
    return type == PacketPayload_C_Login ?
      reinterpret_cast<const Protocol::C_LoginT *>(value) : nullptr;
  }
  Protocol::S_LoginT *AsS_Login() {
    return type == PacketPayload_S_Login ?
      reinterpret_cast<Protocol::S_LoginT *>(value) : nullptr;
  }
  const Protocol::S_LoginT *AsS_Login() const {
    return type == PacketPayload_S_Login ?
      reinterpret_cast<const Protocol::S_LoginT *>(value) : nullptr;
  }
  Protocol::C_ChatT *AsC_Chat() {
    return type == PacketPayload_C_Chat ?
      reinterpret_cast<Protocol::C_ChatT *>(value) : nullptr;
  }
  const Protocol::C_ChatT *AsC_Chat() const {
    return type == PacketPayload_C_Chat ?
      reinterpret_cast<const Protocol::C_ChatT *>(value) : nullptr;
  }
  Protocol::S_ChatT *AsS_Chat() {
    return type == PacketPayload_S_Chat ?
      reinterpret_cast<Protocol::S_ChatT *>(value) : nullptr;
  }
  const Protocol::S_ChatT *AsS_Chat() const {
    return type == PacketPayload_S_Chat ?
      reinterpret_cast<const Protocol::S_ChatT *>(value) : nullptr;
  }
  Protocol::C_MoveT *AsC_Move() {
    return type == PacketPayload_C_Move ?
      reinterpret_cast<Protocol::C_MoveT *>(value) : nullptr;
  }
  const Protocol::C_MoveT *AsC_Move() const {
    return type == PacketPayload_C_Move ?
      reinterpret_cast<const Protocol::C_MoveT *>(value) : nullptr;
  }
  Protocol::S_MoveT *AsS_Move() {
    return type == PacketPayload_S_Move ?
      reinterpret_cast<Protocol::S_MoveT *>(value) : nullptr;
  }
  const Protocol::S_MoveT *AsS_Move() const {
    return type == PacketPayload_S_Move ?
      reinterpret_cast<const Protocol::S_MoveT *>(value) : nullptr;
  }
  Protocol::C_TestT *AsC_Test() {
    return type == PacketPayload_C_Test ?
      reinterpret_cast<Protocol::C_TestT *>(value) : nullptr;
  }
  const Protocol::C_TestT *AsC_Test() const {
    return type == PacketPayload_C_Test ?
      reinterpret_cast<const Protocol::C_TestT *>(value) : nullptr;
  }
};

template <bool B = false>
bool VerifyPacketPayload(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, PacketPayload type);
template <bool B = false>
bool VerifyPacketPayloadVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct C_LoginT : public ::flatbuffers::NativeTable {
  typedef C_Login TableType;
  std::string id{};
  std::string pw{};
  int64_t timestamp = 0;
};

struct C_Login FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_LoginT NativeTableType;
  typedef C_LoginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PW = 6,
    VT_TIMESTAMP = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *pw() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PW);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PW) &&
           verifier.VerifyString(pw()) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
  C_LoginT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(C_LoginT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<C_Login> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_LoginT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct C_LoginBuilder {
  typedef C_Login Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(C_Login::VT_ID, id);
  }
  void add_pw(::flatbuffers::Offset<::flatbuffers::String> pw) {
    fbb_.AddOffset(C_Login::VT_PW, pw);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(C_Login::VT_TIMESTAMP, timestamp, 0);
  }
  explicit C_LoginBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_Login>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_Login> CreateC_Login(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pw = 0,
    int64_t timestamp = 0) {
  C_LoginBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_pw(pw);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C_Login> CreateC_LoginDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *pw = nullptr,
    int64_t timestamp = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto pw__ = pw ? _fbb.CreateString(pw) : 0;
  return Protocol::CreateC_Login(
      _fbb,
      id__,
      pw__,
      timestamp);
}

::flatbuffers::Offset<C_Login> CreateC_Login(::flatbuffers::FlatBufferBuilder &_fbb, const C_LoginT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct S_LoginT : public ::flatbuffers::NativeTable {
  typedef S_Login TableType;
  bool success = false;
  uint32_t player_id = 0;
  int64_t timestamp = 0;
};

struct S_Login FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S_LoginT NativeTableType;
  typedef S_LoginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_PLAYER_ID = 6,
    VT_TIMESTAMP = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  uint32_t player_id() const {
    return GetField<uint32_t>(VT_PLAYER_ID, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_ID, 4) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
  S_LoginT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(S_LoginT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<S_Login> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_LoginT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct S_LoginBuilder {
  typedef S_Login Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(S_Login::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_player_id(uint32_t player_id) {
    fbb_.AddElement<uint32_t>(S_Login::VT_PLAYER_ID, player_id, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(S_Login::VT_TIMESTAMP, timestamp, 0);
  }
  explicit S_LoginBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S_Login> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S_Login>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S_Login> CreateS_Login(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    uint32_t player_id = 0,
    int64_t timestamp = 0) {
  S_LoginBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_player_id(player_id);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<S_Login> CreateS_Login(::flatbuffers::FlatBufferBuilder &_fbb, const S_LoginT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct C_ChatT : public ::flatbuffers::NativeTable {
  typedef C_Chat TableType;
  std::string msg{};
};

struct C_Chat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_ChatT NativeTableType;
  typedef C_ChatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG = 4
  };
  const ::flatbuffers::String *msg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
  C_ChatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(C_ChatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<C_Chat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_ChatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct C_ChatBuilder {
  typedef C_Chat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg(::flatbuffers::Offset<::flatbuffers::String> msg) {
    fbb_.AddOffset(C_Chat::VT_MSG, msg);
  }
  explicit C_ChatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_Chat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_Chat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_Chat> CreateC_Chat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> msg = 0) {
  C_ChatBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C_Chat> CreateC_ChatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg = nullptr) {
  auto msg__ = msg ? _fbb.CreateString(msg) : 0;
  return Protocol::CreateC_Chat(
      _fbb,
      msg__);
}

::flatbuffers::Offset<C_Chat> CreateC_Chat(::flatbuffers::FlatBufferBuilder &_fbb, const C_ChatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct S_ChatT : public ::flatbuffers::NativeTable {
  typedef S_Chat TableType;
  std::string msg{};
};

struct S_Chat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S_ChatT NativeTableType;
  typedef S_ChatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG = 4
  };
  const ::flatbuffers::String *msg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
  S_ChatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(S_ChatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<S_Chat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_ChatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct S_ChatBuilder {
  typedef S_Chat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg(::flatbuffers::Offset<::flatbuffers::String> msg) {
    fbb_.AddOffset(S_Chat::VT_MSG, msg);
  }
  explicit S_ChatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S_Chat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S_Chat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S_Chat> CreateS_Chat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> msg = 0) {
  S_ChatBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S_Chat> CreateS_ChatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg = nullptr) {
  auto msg__ = msg ? _fbb.CreateString(msg) : 0;
  return Protocol::CreateS_Chat(
      _fbb,
      msg__);
}

::flatbuffers::Offset<S_Chat> CreateS_Chat(::flatbuffers::FlatBufferBuilder &_fbb, const S_ChatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct C_MoveT : public ::flatbuffers::NativeTable {
  typedef C_Move TableType;
  float x = 0.0f;
  float y = 0.0f;
};

struct C_Move FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_MoveT NativeTableType;
  typedef C_MoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
  C_MoveT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(C_MoveT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<C_Move> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_MoveT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct C_MoveBuilder {
  typedef C_Move Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(C_Move::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(C_Move::VT_Y, y, 0.0f);
  }
  explicit C_MoveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_Move> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_Move>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_Move> CreateC_Move(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  C_MoveBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

::flatbuffers::Offset<C_Move> CreateC_Move(::flatbuffers::FlatBufferBuilder &_fbb, const C_MoveT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct S_MoveT : public ::flatbuffers::NativeTable {
  typedef S_Move TableType;
  float x = 0.0f;
  float y = 0.0f;
};

struct S_Move FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S_MoveT NativeTableType;
  typedef S_MoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
  S_MoveT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(S_MoveT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<S_Move> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_MoveT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct S_MoveBuilder {
  typedef S_Move Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(S_Move::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(S_Move::VT_Y, y, 0.0f);
  }
  explicit S_MoveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S_Move> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S_Move>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S_Move> CreateS_Move(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  S_MoveBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

::flatbuffers::Offset<S_Move> CreateS_Move(::flatbuffers::FlatBufferBuilder &_fbb, const S_MoveT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct C_TestT : public ::flatbuffers::NativeTable {
  typedef C_Test TableType;
  int32_t a = 0;
  int32_t b = 0;
  int32_t c = 0;
};

struct C_Test FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_TestT NativeTableType;
  typedef C_TestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  int32_t c() const {
    return GetField<int32_t>(VT_C, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           VerifyField<int32_t>(verifier, VT_B, 4) &&
           VerifyField<int32_t>(verifier, VT_C, 4) &&
           verifier.EndTable();
  }
  C_TestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(C_TestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<C_Test> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_TestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct C_TestBuilder {
  typedef C_Test Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(C_Test::VT_A, a, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(C_Test::VT_B, b, 0);
  }
  void add_c(int32_t c) {
    fbb_.AddElement<int32_t>(C_Test::VT_C, c, 0);
  }
  explicit C_TestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_Test> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_Test>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_Test> CreateC_Test(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0,
    int32_t b = 0,
    int32_t c = 0) {
  C_TestBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

::flatbuffers::Offset<C_Test> CreateC_Test(::flatbuffers::FlatBufferBuilder &_fbb, const C_TestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GamePacketT : public ::flatbuffers::NativeTable {
  typedef GamePacket TableType;
  Protocol::PacketPayloadUnion payload{};
};

struct GamePacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GamePacketT NativeTableType;
  typedef GamePacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  Protocol::PacketPayload payload_type() const {
    return static_cast<Protocol::PacketPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const Protocol::C_Login *payload_as_C_Login() const {
    return payload_type() == Protocol::PacketPayload_C_Login ? static_cast<const Protocol::C_Login *>(payload()) : nullptr;
  }
  const Protocol::S_Login *payload_as_S_Login() const {
    return payload_type() == Protocol::PacketPayload_S_Login ? static_cast<const Protocol::S_Login *>(payload()) : nullptr;
  }
  const Protocol::C_Chat *payload_as_C_Chat() const {
    return payload_type() == Protocol::PacketPayload_C_Chat ? static_cast<const Protocol::C_Chat *>(payload()) : nullptr;
  }
  const Protocol::S_Chat *payload_as_S_Chat() const {
    return payload_type() == Protocol::PacketPayload_S_Chat ? static_cast<const Protocol::S_Chat *>(payload()) : nullptr;
  }
  const Protocol::C_Move *payload_as_C_Move() const {
    return payload_type() == Protocol::PacketPayload_C_Move ? static_cast<const Protocol::C_Move *>(payload()) : nullptr;
  }
  const Protocol::S_Move *payload_as_S_Move() const {
    return payload_type() == Protocol::PacketPayload_S_Move ? static_cast<const Protocol::S_Move *>(payload()) : nullptr;
  }
  const Protocol::C_Test *payload_as_C_Test() const {
    return payload_type() == Protocol::PacketPayload_C_Test ? static_cast<const Protocol::C_Test *>(payload()) : nullptr;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPacketPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  GamePacketT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GamePacketT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GamePacket> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GamePacketT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Protocol::C_Login *GamePacket::payload_as<Protocol::C_Login>() const {
  return payload_as_C_Login();
}

template<> inline const Protocol::S_Login *GamePacket::payload_as<Protocol::S_Login>() const {
  return payload_as_S_Login();
}

template<> inline const Protocol::C_Chat *GamePacket::payload_as<Protocol::C_Chat>() const {
  return payload_as_C_Chat();
}

template<> inline const Protocol::S_Chat *GamePacket::payload_as<Protocol::S_Chat>() const {
  return payload_as_S_Chat();
}

template<> inline const Protocol::C_Move *GamePacket::payload_as<Protocol::C_Move>() const {
  return payload_as_C_Move();
}

template<> inline const Protocol::S_Move *GamePacket::payload_as<Protocol::S_Move>() const {
  return payload_as_S_Move();
}

template<> inline const Protocol::C_Test *GamePacket::payload_as<Protocol::C_Test>() const {
  return payload_as_C_Test();
}

struct GamePacketBuilder {
  typedef GamePacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(Protocol::PacketPayload payload_type) {
    fbb_.AddElement<uint8_t>(GamePacket::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(GamePacket::VT_PAYLOAD, payload);
  }
  explicit GamePacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GamePacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GamePacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GamePacket> CreateGamePacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Protocol::PacketPayload payload_type = Protocol::PacketPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  GamePacketBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

::flatbuffers::Offset<GamePacket> CreateGamePacket(::flatbuffers::FlatBufferBuilder &_fbb, const GamePacketT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline C_LoginT *C_Login::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<C_LoginT>(new C_LoginT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void C_Login::UnPackTo(C_LoginT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = pw(); if (_e) _o->pw = _e->str(); }
  { auto _e = timestamp(); _o->timestamp = _e; }
}

inline ::flatbuffers::Offset<C_Login> CreateC_Login(::flatbuffers::FlatBufferBuilder &_fbb, const C_LoginT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return C_Login::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<C_Login> C_Login::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_LoginT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const C_LoginT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _pw = _o->pw.empty() ? 0 : _fbb.CreateString(_o->pw);
  auto _timestamp = _o->timestamp;
  return Protocol::CreateC_Login(
      _fbb,
      _id,
      _pw,
      _timestamp);
}

inline S_LoginT *S_Login::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<S_LoginT>(new S_LoginT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void S_Login::UnPackTo(S_LoginT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = success(); _o->success = _e; }
  { auto _e = player_id(); _o->player_id = _e; }
  { auto _e = timestamp(); _o->timestamp = _e; }
}

inline ::flatbuffers::Offset<S_Login> CreateS_Login(::flatbuffers::FlatBufferBuilder &_fbb, const S_LoginT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return S_Login::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<S_Login> S_Login::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_LoginT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const S_LoginT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _success = _o->success;
  auto _player_id = _o->player_id;
  auto _timestamp = _o->timestamp;
  return Protocol::CreateS_Login(
      _fbb,
      _success,
      _player_id,
      _timestamp);
}

inline C_ChatT *C_Chat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<C_ChatT>(new C_ChatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void C_Chat::UnPackTo(C_ChatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg(); if (_e) _o->msg = _e->str(); }
}

inline ::flatbuffers::Offset<C_Chat> CreateC_Chat(::flatbuffers::FlatBufferBuilder &_fbb, const C_ChatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return C_Chat::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<C_Chat> C_Chat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_ChatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const C_ChatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg = _o->msg.empty() ? 0 : _fbb.CreateString(_o->msg);
  return Protocol::CreateC_Chat(
      _fbb,
      _msg);
}

inline S_ChatT *S_Chat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<S_ChatT>(new S_ChatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void S_Chat::UnPackTo(S_ChatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg(); if (_e) _o->msg = _e->str(); }
}

inline ::flatbuffers::Offset<S_Chat> CreateS_Chat(::flatbuffers::FlatBufferBuilder &_fbb, const S_ChatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return S_Chat::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<S_Chat> S_Chat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_ChatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const S_ChatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg = _o->msg.empty() ? 0 : _fbb.CreateString(_o->msg);
  return Protocol::CreateS_Chat(
      _fbb,
      _msg);
}

inline C_MoveT *C_Move::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<C_MoveT>(new C_MoveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void C_Move::UnPackTo(C_MoveT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
}

inline ::flatbuffers::Offset<C_Move> CreateC_Move(::flatbuffers::FlatBufferBuilder &_fbb, const C_MoveT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return C_Move::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<C_Move> C_Move::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_MoveT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const C_MoveT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  return Protocol::CreateC_Move(
      _fbb,
      _x,
      _y);
}

inline S_MoveT *S_Move::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<S_MoveT>(new S_MoveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void S_Move::UnPackTo(S_MoveT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
}

inline ::flatbuffers::Offset<S_Move> CreateS_Move(::flatbuffers::FlatBufferBuilder &_fbb, const S_MoveT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return S_Move::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<S_Move> S_Move::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const S_MoveT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const S_MoveT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  return Protocol::CreateS_Move(
      _fbb,
      _x,
      _y);
}

inline C_TestT *C_Test::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<C_TestT>(new C_TestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void C_Test::UnPackTo(C_TestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = a(); _o->a = _e; }
  { auto _e = b(); _o->b = _e; }
  { auto _e = c(); _o->c = _e; }
}

inline ::flatbuffers::Offset<C_Test> CreateC_Test(::flatbuffers::FlatBufferBuilder &_fbb, const C_TestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return C_Test::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<C_Test> C_Test::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const C_TestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const C_TestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _a = _o->a;
  auto _b = _o->b;
  auto _c = _o->c;
  return Protocol::CreateC_Test(
      _fbb,
      _a,
      _b,
      _c);
}

inline GamePacketT *GamePacket::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GamePacketT>(new GamePacketT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GamePacket::UnPackTo(GamePacketT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = Protocol::PacketPayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<GamePacket> CreateGamePacket(::flatbuffers::FlatBufferBuilder &_fbb, const GamePacketT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return GamePacket::Pack(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GamePacket> GamePacket::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GamePacketT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GamePacketT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return Protocol::CreateGamePacket(
      _fbb,
      _payload_type,
      _payload);
}

template <bool B>
inline bool VerifyPacketPayload(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, PacketPayload type) {
  switch (type) {
    case PacketPayload_NONE: {
      return true;
    }
    case PacketPayload_C_Login: {
      auto ptr = reinterpret_cast<const Protocol::C_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_S_Login: {
      auto ptr = reinterpret_cast<const Protocol::S_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_C_Chat: {
      auto ptr = reinterpret_cast<const Protocol::C_Chat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_S_Chat: {
      auto ptr = reinterpret_cast<const Protocol::S_Chat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_C_Move: {
      auto ptr = reinterpret_cast<const Protocol::C_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_S_Move: {
      auto ptr = reinterpret_cast<const Protocol::S_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PacketPayload_C_Test: {
      auto ptr = reinterpret_cast<const Protocol::C_Test *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyPacketPayloadVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacketPayload(
        verifier,  values->Get(i), types->GetEnum<PacketPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PacketPayloadUnion::UnPack(const void *obj, PacketPayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case PacketPayload_C_Login: {
      auto ptr = reinterpret_cast<const Protocol::C_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_S_Login: {
      auto ptr = reinterpret_cast<const Protocol::S_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_C_Chat: {
      auto ptr = reinterpret_cast<const Protocol::C_Chat *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_S_Chat: {
      auto ptr = reinterpret_cast<const Protocol::S_Chat *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_C_Move: {
      auto ptr = reinterpret_cast<const Protocol::C_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_S_Move: {
      auto ptr = reinterpret_cast<const Protocol::S_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case PacketPayload_C_Test: {
      auto ptr = reinterpret_cast<const Protocol::C_Test *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> PacketPayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case PacketPayload_C_Login: {
      auto ptr = reinterpret_cast<const Protocol::C_LoginT *>(value);
      return CreateC_Login(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_S_Login: {
      auto ptr = reinterpret_cast<const Protocol::S_LoginT *>(value);
      return CreateS_Login(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_C_Chat: {
      auto ptr = reinterpret_cast<const Protocol::C_ChatT *>(value);
      return CreateC_Chat(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_S_Chat: {
      auto ptr = reinterpret_cast<const Protocol::S_ChatT *>(value);
      return CreateS_Chat(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_C_Move: {
      auto ptr = reinterpret_cast<const Protocol::C_MoveT *>(value);
      return CreateC_Move(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_S_Move: {
      auto ptr = reinterpret_cast<const Protocol::S_MoveT *>(value);
      return CreateS_Move(_fbb, ptr, _rehasher).Union();
    }
    case PacketPayload_C_Test: {
      auto ptr = reinterpret_cast<const Protocol::C_TestT *>(value);
      return CreateC_Test(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PacketPayloadUnion::PacketPayloadUnion(const PacketPayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case PacketPayload_C_Login: {
      value = new Protocol::C_LoginT(*reinterpret_cast<Protocol::C_LoginT *>(u.value));
      break;
    }
    case PacketPayload_S_Login: {
      value = new Protocol::S_LoginT(*reinterpret_cast<Protocol::S_LoginT *>(u.value));
      break;
    }
    case PacketPayload_C_Chat: {
      value = new Protocol::C_ChatT(*reinterpret_cast<Protocol::C_ChatT *>(u.value));
      break;
    }
    case PacketPayload_S_Chat: {
      value = new Protocol::S_ChatT(*reinterpret_cast<Protocol::S_ChatT *>(u.value));
      break;
    }
    case PacketPayload_C_Move: {
      value = new Protocol::C_MoveT(*reinterpret_cast<Protocol::C_MoveT *>(u.value));
      break;
    }
    case PacketPayload_S_Move: {
      value = new Protocol::S_MoveT(*reinterpret_cast<Protocol::S_MoveT *>(u.value));
      break;
    }
    case PacketPayload_C_Test: {
      value = new Protocol::C_TestT(*reinterpret_cast<Protocol::C_TestT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PacketPayloadUnion::Reset() {
  switch (type) {
    case PacketPayload_C_Login: {
      auto ptr = reinterpret_cast<Protocol::C_LoginT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_S_Login: {
      auto ptr = reinterpret_cast<Protocol::S_LoginT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_C_Chat: {
      auto ptr = reinterpret_cast<Protocol::C_ChatT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_S_Chat: {
      auto ptr = reinterpret_cast<Protocol::S_ChatT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_C_Move: {
      auto ptr = reinterpret_cast<Protocol::C_MoveT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_S_Move: {
      auto ptr = reinterpret_cast<Protocol::S_MoveT *>(value);
      delete ptr;
      break;
    }
    case PacketPayload_C_Test: {
      auto ptr = reinterpret_cast<Protocol::C_TestT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PacketPayload_NONE;
}

inline const Protocol::GamePacket *GetGamePacket(const void *buf) {
  return ::flatbuffers::GetRoot<Protocol::GamePacket>(buf);
}

inline const Protocol::GamePacket *GetSizePrefixedGamePacket(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Protocol::GamePacket>(buf);
}

template <bool B = false>
inline bool VerifyGamePacketBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<Protocol::GamePacket>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedGamePacketBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<Protocol::GamePacket>(nullptr);
}

inline void FinishGamePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protocol::GamePacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGamePacketBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Protocol::GamePacket> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Protocol::GamePacketT> UnPackGamePacket(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Protocol::GamePacketT>(GetGamePacket(buf)->UnPack(res));
}

inline std::unique_ptr<Protocol::GamePacketT> UnPackSizePrefixedGamePacket(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Protocol::GamePacketT>(GetSizePrefixedGamePacket(buf)->UnPack(res));
}

}  // namespace Protocol

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
